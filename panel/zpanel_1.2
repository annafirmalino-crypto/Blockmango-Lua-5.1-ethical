---<[{ Start GMPanel }]>---

UIGMControlPanel = require("engine_client.ui.layout.GUIGMControlPanel")

---<[{ Show/Close GMPanel }]>---

function UIGMControlPanel:show()
    SoundUtil.playSound(0)
    self.super.show(self)
    UIHelper.showOpenAnim(self)
end

function UIGMControlPanel:hide()
    SoundUtil.playSound(0)
    self.super.hide(self)
end

---<[{ Take Version Of Apks }]>---

local function getGameVersion()
    local info = HostApi.getClientInfo()
    if info then
        info = json.decode(info)
        if info.app_version then
            return info.app_version
        else
            return ""
        end
    else
        return ""
    end
end

---<[{ Game Init Func }]>---

function Game:init()

---<[{ Apply Credits For No Remove }]>---

local ModsList = {
    "GUIRoot-xuy60"
}

LuaTimer:scheduleTimer(function()
    for _, mod in ipairs(ModsList) do
        local gui = GUIManager:getWindowByName(mod)
        if not gui then
            Toast("Detected : Panel modified!")
            LuaTimer:scheduleTimer(function()
                CGame.Instance():exitGame("normal")
            end, 2000, 1)
            return
        end
    end
    UIHelper.showCenterToast("Game Loaded..")
end, 2000, 1)

---<[{ Color }]>---

local function interpolatePurple(brightness)
    local r, g, b = 0.784, 0, 1
    r = r * brightness
    g = g * brightness
    b = b * brightness
    return r, g, b, 1
end







local brightness = 1.0
local direction = -0.01
local animationTime = 0
local pulseOffset = 0
local glowIntensity = 0.6



local function easeInOutQuad(t)
    if t < 0.5 then
        return 2 * t * t
    else
        return -1 + (4 - 2 * t) * t
    end
end

local function breathingScale(time)
    return 1 + math.sin(time * 0.08) * 0.03
end

local function floatingMotion(time)
    return math.sin(time * 0.06) * 8
end

function xuy60()
    local GUI = GUIManager:createGUIWindow(GUIType.StaticText, "GUIRoot-xuy60")
    GUI:SetVisible(true)
    GUI:SetBordered(true)
    GUI:SetTouchable(false)
    GUI:SetHorizontalAlignment(HorizontalAlignment.Center)
    GUI:SetTextHorzAlign(HorizontalAlignment.Center)
    GUI:SetWidth({ 0, 556 })
    GUI:SetHeight({ 0, 30 })
    GUI:SetYPosition({ 0, 120 })
    GUISystem.Instance():GetRootWindow():AddChildWindow(GUI)
    
    local baseY = 120
    local baseWidth = 556
    local baseHeight = 30
    
    local function Update()
        animationTime = animationTime + 1
        local HUD = "Credits: ZentexHacker & CyberBg, 1.3, (" .. getGameVersion() .. ")"
        GUI:SetText(HUD)
        brightness = brightness + direction
        if brightness <= 0.3 then 
            direction = 0.015
        end
        if brightness >= 1.0 then 
            direction = -0.008
        end
        local normalizedBrightness = (brightness - 0.3) / 0.7
        normalizedBrightness = math.max(0, math.min(1, normalizedBrightness))
        local easedBrightness = 0.3 + (easeInOutQuad(normalizedBrightness) * 0.7)
        local scale = breathingScale(animationTime)
        local scaledWidth = baseWidth * scale
        local scaledHeight = baseHeight * scale
        local yOffset = floatingMotion(animationTime)
        local xOffset = math.cos(animationTime * 0.04) * 3
        GUI:SetWidth({ 0, scaledWidth })
        GUI:SetHeight({ 0, scaledHeight })
        GUI:SetYPosition({ 0, baseY + yOffset })
        GUI:SetXPosition({ 0, xOffset })
        local r, g, b, a = interpolatePurple(easedBrightness)
        local alphaPulse = math.sin(animationTime * 0.1) * 0.1 + 0.9
        local finalAlpha = a * glowIntensity * alphaPulse
        GUI:SetTextColor({ r, g, b, finalAlpha })
    end
    
    LuaTimer:scheduleTimer(Update, 20, -1)
end

function xuy60_enhanced()
    local GUI = GUIManager:createGUIWindow(GUIType.StaticText, "GUIRoot-xuy60")
    GUI:SetVisible(true)
    GUI:SetBordered(true)
    GUI:SetTouchable(false)
    GUI:SetHorizontalAlignment(HorizontalAlignment.Center)
    GUI:SetTextHorzAlign(HorizontalAlignment.Center)
    GUI:SetWidth({ 0, 556 })
    GUI:SetHeight({ 0, 30 })
    GUI:SetYPosition({ 0, 120 })
    GUISystem.Instance():GetRootWindow():AddChildWindow(GUI)
    
    local time = 0
    local phaseShift = 0
    
    local function interpolateEnhanced(brightness, phase)
        local r, g, b = 1, 0.5, 0
        local colorShift = math.sin(phase * 0.02) * 0.1
        r = math.min(1, r + colorShift)
        g = math.max(0.3, g - colorShift * 0.5)
        r = r * brightness
        g = g * brightness
        b = b * brightness
        return r, g, b, 1
    end
    
    local function Update()
        time = time + 1
        local HUD = "Credits: ZentexHacker & CyberBg, 1.3, (" .. getGameVersion() .. ")"
        GUI:SetText(HUD)
        brightness = brightness + direction
        if brightness <= 0.2 then 
            direction = 0.012
            phaseShift = phaseShift + 1
        end
        if brightness >= 1.0 then 
            direction = -0.009
        end
        local wave1 = math.sin(time * 0.05) * 0.1
        local wave2 = math.sin(time * 0.08 + 1.57) * 0.05
        local combinedBrightness = brightness + wave1 + wave2
        combinedBrightness = math.max(0.1, math.min(1.2, combinedBrightness))
        local primaryFloat = math.sin(time * 0.06) * 12
        local secondaryFloat = math.cos(time * 0.04 + 0.5) * 4
        local microFloat = math.sin(time * 0.12) * 2
        local totalYOffset = primaryFloat + secondaryFloat + microFloat
        local scalePulse = 1 + (math.sin(time * 0.07) * 0.04)
        local xDrift = math.sin(time * 0.035) * 8 + math.cos(time * 0.025) * 3
        GUI:SetYPosition({ 0, 120 + totalYOffset })
        GUI:SetXPosition({ 0, xDrift })
        GUI:SetWidth({ 0, 556 * scalePulse })
        GUI:SetHeight({ 0, 30 * scalePulse })
        local r, g, b, a = interpolateEnhanced(combinedBrightness, time + phaseShift)
        local alpha1 = math.sin(time * 0.08) * 0.15 + 0.7
        local alpha2 = math.cos(time * 0.05 + 1) * 0.1 + 0.8
        local finalAlpha = (alpha1 + alpha2) * 0.5 * a
        GUI:SetTextColor({ r, g, b, finalAlpha })
    end
    
    LuaTimer:scheduleTimer(Update, 16, -1)
end


function ChatColor()
    local selectedColorHex = "FF3333"
    local isAnimating = false
    local glowIntensity, glowDir = 0.3, 1

    local function clamp(v) return math.max(0, math.min(255, math.floor(v * 255))) end
    local function rgbToHex(r, g, b) return string.format("%02X%02X%02X", clamp(r*255), clamp(g*255), clamp(b*255)) end
    local function hexToRgb(hex)
        if #hex == 6 then
            return tonumber(hex:sub(1, 2), 16) / 255,
                   tonumber(hex:sub(3, 4), 16) / 255,
                   tonumber(hex:sub(5, 6), 16) / 255
        end
        return 1,1,1
    end
    local function hsvToRgb(h, s, v)
        local i = math.floor(h * 6)
        local f = h * 6 - i
        local p = v * (1 - s)
        local q = v * (1 - f * s)
        local t = v * (1 - (1 - f) * s)
        local mod = i % 6
        if mod == 0 then return v,t,p
        elseif mod == 1 then return q,v,p
        elseif mod == 2 then return p,v,t
        elseif mod == 3 then return p,q,v
        elseif mod == 4 then return t,p,v
        else return v,p,q end
    end
    local function applyColorToChat(hex)
        if not hex or #hex ~= 6 then return false end
        local ChatInputBox = GUIManager:getWindowByName("Chat-Input-Box")
        if not ChatInputBox then return false end
        local originalMessage = ChatInputBox:GetText() or ""
        originalMessage = originalMessage:gsub("^%^[%x][%x][%x][%x][%x][%x]", "")
        ChatInputBox:SetText("^" .. hex:upper() .. originalMessage)
        return true
    end

    local PickerWin = GUIManager:createGUIWindow(GUIType.DefaultWindow, "AdvancedColorPicker")
    PickerWin:SetHorizontalAlignment(HorizontalAlignment.Center)
    PickerWin:SetVerticalAlignment(HorizontalAlignment.Center)
    PickerWin:SetHeight({0, 620})
    PickerWin:SetWidth({0, 520})
    PickerWin:SetBackgroundColor({0.08,0.08,0.15,0.97})
    PickerWin:SetVisible(false)
    GUISystem.Instance():GetRootWindow():AddChildWindow(PickerWin)

   local TitleBar = GUIManager:createGUIWindow(GUIType.Layout, "ColorPickerTitle")
   TitleBar:SetHorizontalAlignment(HorizontalAlignment.Center)
   TitleBar:SetVerticalAlignment(VerticalAlignment.Top)
   TitleBar:SetHeight({0, 50})
   TitleBar:SetWidth({0, 500})
   TitleBar:SetBackgroundColor({0.15, 0.07, 0.25, 0.96})
   TitleBar:SetLevel(1)
   PickerWin:AddChildWindow(TitleBar)

   local TitleText = GUIManager:createGUIWindow(GUIType.Text, "ColorPickerText")
    TitleText:SetHorizontalAlignment(HorizontalAlignment.Center)
    TitleText:SetVerticalAlignment(VerticalAlignment.Center)
    TitleText:SetWidth({0, 420})
    TitleText:SetHeight({0, 50})
    TitleText:SetText("Chat Color Premium")
    TitleText:SetVisible(true)
    TitleText:SetLevel(0)
    TitleBar:AddChildWindow(TitleText)

    local CloseBtn = GUIManager:createGUIWindow(GUIType.Button, "ColorPickerClose")
    CloseBtn:SetHorizontalAlignment(HorizontalAlignment.Right)
    CloseBtn:SetVerticalAlignment(VerticalAlignment.Center)
    CloseBtn:SetHeight({0, 40})
    CloseBtn:SetWidth({0, 40})
    CloseBtn:SetXPosition({0, -5})
    CloseBtn:SetNormalImage("set:tip_dialog.json image:btn_close")
    CloseBtn:SetPushedImage("set:tip_dialog.json image:btn_close")
    TitleBar:AddChildWindow(CloseBtn)

    CloseBtn:registerEvent(GUIEvent.ButtonClick, function()
        if not isAnimating then
            isAnimating = true
            local scale, alpha = 1, 1
            LuaTimer:scheduleTicker(function()
                scale = scale - 0.05
                alpha = alpha - 0.06
                if scale <= 0 then
                    PickerWin:SetVisible(false)
                    PickerWin:SetScale(VectorUtil.newVector3(1,1,1))
                    PickerWin:SetAlpha(1)
                    isAnimating = false
                else
                    PickerWin:SetScale(VectorUtil.newVector3(scale, scale, scale))
                    PickerWin:SetAlpha(alpha)
                end
            end, 1, 20)
        end
    end)

    local PreviewSection = GUIManager:createGUIWindow(GUIType.Layout, "PreviewSection")
    PreviewSection:SetHorizontalAlignment(HorizontalAlignment.Center)
    PreviewSection:SetVerticalAlignment(VerticalAlignment.Top)
    PreviewSection:SetHeight({0, 60})
    PreviewSection:SetWidth({0, 200})
    PreviewSection:SetYPosition({0, 60})
    PreviewSection:SetBackgroundColor({1,0.25,0.35,1})
    PickerWin:AddChildWindow(PreviewSection)

    local HueContainer = GUIManager:createGUIWindow(GUIType.Layout, "HueCircle")
    HueContainer:SetHorizontalAlignment(HorizontalAlignment.Center)
    HueContainer:SetVerticalAlignment(VerticalAlignment.Top)
    HueContainer:SetHeight({0, 260})
    HueContainer:SetWidth({0, 260})
    HueContainer:SetYPosition({0, 130})
    PickerWin:AddChildWindow(HueContainer)

    local radius, steps = 110, 36
    for i=1,steps do
        local angle = (i/steps) * 2 * math.pi
        local r,g,b = hsvToRgb(i/steps, 1, 1)
        local btn = GUIManager:createGUIWindow(GUIType.Button, "Hue_"..i)
        btn:SetHeight({0, 20})
        btn:SetWidth({0, 20})
        btn:SetBackgroundColor({r,g,b,1})
        btn:SetXPosition({0, radius * math.cos(angle) + 120})
        btn:SetYPosition({0, radius * math.sin(angle) + 120})
        HueContainer:AddChildWindow(btn)
        btn:registerEvent(GUIEvent.ButtonClick, function()
            PreviewSection:SetBackgroundColor({r,g,b,1})
            selectedColorHex = rgbToHex(r,g,b)
            applyColorToChat(selectedColorHex)
        end)
    end

    local EmojiBtn = GUIManager:createGUIWindow(GUIType.Button, "EmojiCenterBtn")
    EmojiBtn:SetHorizontalAlignment(HorizontalAlignment.Center)
    EmojiBtn:SetVerticalAlignment(VerticalAlignment.Center)
    EmojiBtn:SetHeight({0, 80})
    EmojiBtn:SetWidth({0, 80})
    EmojiBtn:SetNormalImage("set:emoji.json image:img_0_phiz_good")
    EmojiBtn:SetPushedImage("set:emoji.json image:img_0_phiz_good")
    EmojiBtn:SetXPosition({0, 0})
    EmojiBtn:SetYPosition({0, 0})
    HueContainer:AddChildWindow(EmojiBtn)

    EmojiBtn:registerEvent(GUIEvent.ButtonClick, function()
        local ChatInputBox = GUIManager:getWindowByName("Chat-Input-Box")
        if ChatInputBox then
            local msg = ChatInputBox:GetText() or ""
            ChatInputBox:SetText(msg .. "Cyber ♡")
        end
    end)

    local SwatchGrid = GUIManager:createGUIWindow(GUIType.GridView, "SwatchGrid")
    SwatchGrid:SetHorizontalAlignment(HorizontalAlignment.Center)
    SwatchGrid:SetVerticalAlignment(VerticalAlignment.Bottom)
    SwatchGrid:SetHeight({0, 200})
    SwatchGrid:SetWidth({0, 480})
    SwatchGrid:SetYPosition({0, -20})
    SwatchGrid:InitConfig(44, 44, 6)
    PickerWin:AddChildWindow(SwatchGrid)

    local palettes = {
        "FF0000","00FF00","0000FF","FFFF00","FF00FF","00FFFF","FFFFFF","000000","808080",
        "DC143C","FF8C00","FFD700","FF69B4","F08080","FFDAB9","8B0000","800000",
        "00BFFF","9932CC","32CD32","ADD8E6","90EE90","E6E6FA","00008B","006400","9400D3",
        "FFB6C1","FFFFE0","F5FFFA","D8BFD8","A9A9A9","2F4F4F",
        "39FF14","FF073A","FF6EC7","FFAE42","0FF0FC","FF4500","7DF9FF","9D00FF","FFD1DC"
    }
    for _,hex in ipairs(palettes) do
        local r,g,b = hexToRgb(hex)
        local Swatch = GUIManager:createGUIWindow(GUIType.Button, "Swatch_"..hex)
        Swatch:SetHeight({0, 40})
        Swatch:SetWidth({0, 40})
        Swatch:SetBackgroundColor({r,g,b,1})
        SwatchGrid:AddItem(Swatch)
        Swatch:registerEvent(GUIEvent.ButtonClick, function()
            PreviewSection:SetBackgroundColor({r,g,b,1})
            selectedColorHex = hex
            applyColorToChat(selectedColorHex)
        end)
    end

    for i=0,15 do
        local gray = i/15
        local hex = rgbToHex(gray, gray, gray)
        local Swatch = GUIManager:createGUIWindow(GUIType.Button, "Gray_"..i)
        Swatch:SetHeight({0, 40})
        Swatch:SetWidth({0, 40})
        Swatch:SetBackgroundColor({gray,gray,gray,1})
        SwatchGrid:AddItem(Swatch)
        Swatch:registerEvent(GUIEvent.ButtonClick, function()
            PreviewSection:SetBackgroundColor({gray,gray,gray,1})
            selectedColorHex = hex
            applyColorToChat(selectedColorHex)
        end)
    end

    for i=0,11 do
        local r,g,b = hsvToRgb(i/12, 1, 1)
        local hex = rgbToHex(r,g,b)
        local Swatch = GUIManager:createGUIWindow(GUIType.Button, "Rainbow_"..i)
        Swatch:SetHeight({0, 40})
        Swatch:SetWidth({0, 40})
        Swatch:SetBackgroundColor({r,g,b,1})
        SwatchGrid:AddItem(Swatch)
        Swatch:registerEvent(GUIEvent.ButtonClick, function()
            PreviewSection:SetBackgroundColor({r,g,b,1})
            selectedColorHex = hex
            applyColorToChat(selectedColorHex)
        end)
    end

    local ChatInputBox = GUIManager:getWindowByName("Chat-Input-Box")
    if ChatInputBox then
        local OpenBtn = GUIManager:createGUIWindow(GUIType.Button, "ColorOpenBtn")
        OpenBtn:SetHorizontalAlignment(HorizontalAlignment.Right)
        OpenBtn:SetVerticalAlignment(VerticalAlignment.Center)
        OpenBtn:SetHeight({0, 36})
        OpenBtn:SetWidth({0, 36})
        OpenBtn:SetBackgroundColor({1,0.4,0.5,1})
        OpenBtn:SetXPosition({0, -45})
        ChatInputBox:AddChildWindow(OpenBtn)

        local Glow = GUIManager:createGUIWindow(GUIType.Layout, "GlowBorder")
        Glow:SetHorizontalAlignment(HorizontalAlignment.Center)
        Glow:SetVerticalAlignment(VerticalAlignment.Center)
        Glow:SetHeight({0, 46})
        Glow:SetWidth({0, 46})
        Glow:SetBackgroundColor({1,0.3,0.4,glowIntensity})
        Glow:SetTouchable(false)
        OpenBtn:AddChildWindow(Glow)

        LuaTimer:scheduleTicker(function()
            glowIntensity = glowIntensity + (glowDir * 0.02)
            if glowIntensity >= 0.6 then glowDir = -1 end
            if glowIntensity <= 0.2 then glowDir = 1 end
            Glow:SetBackgroundColor({1,0.3,0.4,glowIntensity})
        end, 1, 0)

        OpenBtn:registerEvent(GUIEvent.ButtonClick, function()
            if not isAnimating then
                isAnimating = true
                PickerWin:SetVisible(true)
                local scale, alpha = 0.2, 0
                LuaTimer:scheduleTicker(function()
                    scale = math.min(1, scale + 0.05)
                    alpha = math.min(1, alpha + 0.07)
                    PickerWin:SetScale(VectorUtil.newVector3(scale, scale, scale))
                    PickerWin:SetAlpha(alpha)
                    if scale >= 1 then
                        isAnimating = false
                    end
                end, 1, 20)
            end
        end)
    end

    return {
        getCurrentColor = function() return selectedColorHex end,
        applyColor = function(hex) return applyColorToChat(hex) end,
        showPicker = function() PickerWin:SetVisible(true) end,
        hidePicker = function() PickerWin:SetVisible(false) end
    }
end

function chat()
    CEvents.PlayerLogoutEvent:registerCallBack(function(userId)
        local date = os.date("^FF0000[%Y-%m-%d]")
        local name = playerNameCache[userId] or "Unknown"
        MsgSender.sendMsg(date .. "^FF0000 Player Left : ^FFFF00 Name = ^FFFFFF" .. name .. "^FF0000 UserId = ^FFFFFF" .. userId)
        playerNameCache[userId] = nil
    end)
end

local savedPos = nil

local function setPosTest(targetPos)
    if targetPos.y < 10 then return end

    local clientWrapper = PlayerManager:getClientPlayer()
    if not clientWrapper or not clientWrapper.Player then return end
    local clientPlayer = clientWrapper.Player

    local myPos = clientPlayer:getPosition()
    local yaw = clientPlayer.rotationYaw
    local pitch = clientPlayer.rotationPitch

    local disTp = { x = targetPos.x - myPos.x, z = targetPos.z - myPos.z }
    local totalDistance = math.sqrt(disTp.x * disTp.x + disTp.z * disTp.z)

    UIHelper.showToast("Distance: " .. string.format("%.2f", totalDistance))

    if myPos.y < 165 then myPos.y = 165 end

    if math.abs(disTp.x) > 16 then
        myPos.x = myPos.x + (disTp.x > 0 and 16 or -16)
        clientPlayer:setPosition(myPos)
        LuaTimer:scheduleTimer(function()
            setPosTest(targetPos)
        end, 0.015, 1)
        return
    end

    if math.abs(disTp.z) > 16 then
        myPos.z = myPos.z + (disTp.z > 0 and 16 or -16)
        clientPlayer:setPosition(myPos)
        LuaTimer:scheduleTimer(function()
            setPosTest(targetPos)
        end, 0.015, 1)
        return
    end

    local function checkBlock(pos)
        while EngineWorld:getBlockId(pos) ~= BlockID.AIR do
            pos.y = pos.y + 1
            if pos.y > 256 then break end
        end
        return pos
    end

    targetPos = checkBlock(targetPos)
    local abovePos = VectorUtil.newVector3(targetPos.x, targetPos.y + 1.2, targetPos.z)

    clientPlayer.noClip = true
    clientPlayer:setPosition(abovePos)
    clientPlayer.noClip = false

    clientPlayer:setPosition(abovePos)
    clientPlayer.rotationYaw = yaw
    clientPlayer.rotationPitch = pitch

    clientPlayer:setVelocity(VectorUtil.newVector3(0, 0.3, 0))
    clientPlayer:setAllowFlying(false)
    clientPlayer:setFlying(false)

    LuaTimer:scheduleOnce(function()
        clientPlayer:setAllowFlying(false)
        clientPlayer:setFlying(false)
    end, 0.0005)

    savedPos = abovePos

    for i = 1, 5 do
        LuaTimer:scheduleOnce(function()
            clientPlayer:setPosition(savedPos)
        end, i * 0.0005)
    end
end

function GMHelper:GUI()
    if self.Shadi and not self.Shadi:IsDestroyed() then
        self.Shadi:SetVisible(not self.Shadi:IsVisible())
        return
    end

    local Shadi = GUIManager:createGUIWindow(GUIType.Layout, "Layout-Shadie")
    self.Shadi = Shadi
    Shadi:SetBackgroundColor({0, 0, 0, 0.8})
    Shadi:SetHorizontalAlignment(HorizontalAlignment.Center)
    Shadi:SetVerticalAlignment(VerticalAlignment.Top)
    Shadi:SetHeight({0, 680})
    Shadi:SetWidth({0, 1400})
    Shadi:SetYPosition({0, 25})
    Shadi:SetLevel(0)
    Shadi:SetVisible(true)
    Shadi:SetTouchable(true)
    Shadi:SetAlwaysOnTop(true)

    local Close = GUIManager:createGUIWindow(GUIType.Button, "button-Close")
    Close:SetWidth({0, 40})
    Close:SetHeight({0, 40})
    Close:SetNormalImage("set:tip_dialog.json image:btn_close")
    Close:SetPushedImage("set:tip_dialog.json image:btn_close")
    Close:SetXPosition({0, 1355})
    Close:SetYPosition({0, 5})
    Close:SetVisible(true)
    Close:registerEvent(GUIEvent.ButtonClick, function()
        Shadi:SetVisible(false)
    end)
    Shadi:AddChildWindow(Close)

    local header = GUIManager:createGUIWindow(GUIType.StaticText, "Header-Teleport")
    header:SetHorizontalAlignment(HorizontalAlignment.Center)
    header:SetVerticalAlignment(VerticalAlignment.Top)
    header:SetHeight({0, 50})
    header:SetWidth({1, 0})
    header:SetXPosition({0, 0})
    header:SetYPosition({0, 0})
    header:SetTouchable(false)
    header:SetText("Teleport Player List")
    header:SetTextColor(Color.WHITE)
    header:SetTextHorzAlign(HorizontalAlignment.Center)
    header:SetTextVertAlign(VerticalAlignment.Center)
    header:SetProperty("Font", "HT11")
    header:SetBackgroundColor({0.5, 0.5, 0.5, 1})
    Shadi:AddChildWindow(header)

    local players = PlayerManager:getPlayers()
    for index, player in ipairs(players) do
        local button = GUIManager:createGUIWindow(GUIType.StaticText, "Button-"..player.name)
        button:SetText(player.name)
        button:SetWidth({0, 150})
        button:SetHeight({0, 39})
        button:SetBackgroundColor({1, 0, 0, 1})

        local row = math.floor((index-1)/6)
        local col = (index-1)%6
        button:SetXPosition({0, 55 + (col*220)})
        button:SetYPosition({0, 90 + (row*60)})

        button:SetBordered(true)
        button:SetTextBoader(Color.BLACK)
        button:SetTextHorzAlign(HorizontalAlignment.Center)
        button:SetTextVertAlign(VerticalAlignment.Center)
        button:SetTouchable(true)
        button:SetTextScale(1.0)
        button:SetProperty("Font", "HT8")
        button:SetProperty("RTL", "True")

        button:registerEvent(GUIEvent.Click, function()
            local me = PlayerManager:getClientPlayer()
            if me and player then
                local pos = player:getPosition()
                local newPos = VectorUtil.newVector3(pos.x, pos.y + 2.0, pos.z)
                setPosTest(newPos)
                UIHelper.showToast("Teleported Enabled")
            end
        end)

        Shadi:AddChildWindow(button)
    end

    GUISystem.Instance():GetRootWindow():AddChildWindow(Shadi)
end

---<[{ Button System }]>---

-- Btn Sys
local ButtonRegistryUI = {}
local TotalBtnsUI = 0

-- Save Item
local ButtonRegistrySave = {}
local TotalBtnsSave = 0

local function getButtonColor(name)
    return _G["tog" .. name] and {0.8,0.4,0.0,1} or {0,0,0,0.4}
end

local function getButtonPosition(index, startY)
    local col = math.floor((index - 1) / 13)
    local row = (index - 1) % 13
    return {0, 250 * col}, {0, startY + row * 50}
end

function createUIButton(label, name)
    if ButtonRegistryUI[name] then return ButtonRegistryUI[name].gui end
    TotalBtnsUI = TotalBtnsUI + 1
    local uid = "BtnUI-" .. TotalBtnsUI
    local btn = GUIManager:createGUIWindow(GUIType.Button, "GUIRoot-" .. uid)
    btn:SetText(label)
    btn:SetHorizontalAlignment(HorizontalAlignment.Left)
    btn:SetVerticalAlignment(HorizontalAlignment.Top)
    btn:SetVisible(true)
    btn:SetLevel(1)
    if btn.setEnableLongTouch then btn:setEnableLongTouch(true) end
    btn:SetWidth({0, btn:GetTextWidth() + 25})
    btn:SetHeight({0, 45})
    local _, yPos = getButtonPosition(TotalBtnsUI, 65)
    btn:SetXPosition({0, 15})
    btn:SetYPosition(yPos)

    btn:registerEvent(GUIEvent.ButtonClick, function()
        _G["tog" .. name] = not _G["tog" .. name]
        refreshButtonColorUI(name)
        if GMHelper and type(GMHelper[name]) == "function" then
            GMHelper[name](GMHelper, btn)
        end
    end)

    btn:SetBackgroundColor(getButtonColor(name))
    GUISystem.Instance():GetRootWindow():AddChildWindow(btn)
    ButtonRegistryUI[name] = {gui = btn}
    return btn
end

function refreshButtonColorUI(name)
    if ButtonRegistryUI[name] and ButtonRegistryUI[name].gui then
        ButtonRegistryUI[name].gui:SetBackgroundColor(getButtonColor(name))
    end
end

function SaveItem(label, name)
    if ButtonRegistrySave[name] then return ButtonRegistrySave[name].gui end
    TotalBtnsSave = TotalBtnsSave + 1
    local uid = "BtnSave-" .. TotalBtnsSave
    local btn = GUIManager:createGUIWindow(GUIType.Button, "GUIRoot-" .. uid)
    btn:SetText(label)
    btn:SetHorizontalAlignment(HorizontalAlignment.Left)
    btn:SetVerticalAlignment(HorizontalAlignment.Top)
    btn:SetVisible(true)
    btn:SetLevel(1)
    if btn.setEnableLongTouch then btn:setEnableLongTouch(true) end
    btn:SetWidth({0, btn:GetTextWidth() + 25})
    btn:SetHeight({0, 45})
    local _, yPos = getButtonPosition(TotalBtnsSave, 750)
    btn:SetXPosition({0, 15})
    btn:SetYPosition(yPos)

    btn:registerEvent(GUIEvent.ButtonClick, function()
        _G["tog" .. name] = not _G["tog" .. name]
        refreshButtonColorSave(name)
        if GMHelper and type(GMHelper[name]) == "function" then
            GMHelper[name](GMHelper, btn)
        end
    end)

    btn:SetBackgroundColor(getButtonColor(name))
    GUISystem.Instance():GetRootWindow():AddChildWindow(btn)
    ButtonRegistrySave[name] = {gui = btn}
    return btn
end

function refreshButtonColorSave(name)
    if ButtonRegistrySave[name] and ButtonRegistrySave[name].gui then
        ButtonRegistrySave[name].gui:SetBackgroundColor(getButtonColor(name))
    end
end

---<[{ Game For Loader Panel }]>---

self.CGame = CGame.Instance()
self.GameType = self.CGame:getGameType()
self.EnableIndie = self.CGame:isEnableIndie(true)
self.Blockman = Blockman.Instance()
self.World = self.Blockman:getWorld()
self.LowerDevice = self.CGame:isLowerDevice()
xuy60()
chat()
ChatColor()
UIHelper.showCenterToast("Admin Panel Bypass Version: " .. getGameVersion() .. "")
if self.World then
    EngineWorld:setWorld(self.World)
end
end

---<[{ GMSetting Tab, Item }]>---

function Game:isOpenGM()
    return isClient
end

local Settings = {}
GMHelper = {}
GMSetting = {}

local function isGMOpen(userId)
    if isServer then
        return true
    end
    return TableUtil.include(AdminIds, tostring(userId))
end

---<[{ Code Tab, Item }]>---

function GMSetting:addTab(tab_prefix, tab_name)
    if tab_prefix ~= "Zn" then
        return
    end 

    local final_tab_name = tab_name 

    for _, setting in pairs(Settings) do
        if setting.name == final_tab_name then
            setting.items = {}
            return
        end
    end

    table.insert(Settings, { name = final_tab_name, items = {} })
end

function GMSetting:addItem(tab_name, item_name, func_name, ...)
    local settings
    for _, group in pairs(Settings) do
        if group.name == tab_name then
            settings = group
            break
        end
    end

    if not settings then
        return
    end

    table.insert(settings.items, { name = item_name, func = func_name, params = { ... } })
end

function GMSetting:getSettings()
    return Settings
end

local function addCategory(tab, items)
    GMSetting:addTab("Zn", tab)
    for _, item in ipairs(items) do
        local text, key = item[1] or item.text, item[2] or item.key
        if text and key then
            GMSetting:addItem(tab, text, key)
        end
    end
end

local function addItemsWithSpacing(tab, items, spacing, itemsPerSpacing, addSpacerText)
    spacing = spacing or 2
    itemsPerSpacing = itemsPerSpacing or spacing
    local count = 0
    for _, item in ipairs(items) do
        local text, key = item.text, item.key
        if text and text ~= "" and key and key ~= "" then
            GMSetting:addItem(tab, text, key)
            count = count + 1
            if count % itemsPerSpacing == 0 then
                if addSpacerText then
                    GMSetting:addItem(tab, addSpacerText, "")
                else
                    GMSetting:addItem(tab, "", "")
                end
            end
        end
    end
    if count % itemsPerSpacing ~= 0 and addSpacerText then
        GMSetting:addItem(tab, addSpacerText, "")
    elseif count % itemsPerSpacing ~= 0 then
        GMSetting:addItem(tab, "", "")
    end
end

---<[{ Style Tab, Item }]>---

--[[local Zn = CGame.Instance():getGameType()
local bwGames = {
    g1008 = true,
    g1046 = true,
    g1061 = true,
    g1062 = true,
    g1063 = true,
    g1064 = true,
    g1065 = true,
}

local bw = bwGames[Zn] or false

local hacksItemsBW = {
    {"Fast Break", "FastBreak"},
    {"NoFall", "NoFall"},
    {"no fall damage", "NoFallDmg"},
    {"UnDeath", "UnDeath"},
    {"KillAura", "KillAura"},
    {"BowSpeed", "BowSpeed"},
    {"Skate", "Skate"},
    {"Aim Bow", "AimBow"},
    {"AttackCD", "BanClickCD"},
    {"HitBox", "HitBox"},
}
]]-- Wait New Version

local hacksItemsOther = {
    {"AimBot", "AimBot"},
    {"Anti void", "AntiVoid"},
    {"AttackCD", "BanClickCD"},
    {"attack button", "AtkBtn"},
    {"AutoRespawn", "AutoRespawn"},
    {"Blink", "Blink"},
    {"BreakBlock", "BreakBlock"},
    {"Button Bridge", "BtnBridge"},
    {"AutoBridge", "AutoBridge"},
    {"Cannon Button", "CannonBtn"},
    {"DropSpeed", "DropSpeed"},
    {"Fast Break", "FastBreak"},
    {"Fast jumps", "FastJump"},
    {"Fly", "DevFly"},
    {"Fly Parachute", "FlyParachute"},
    {"Free camera", "FreeCamera"},
    {"High Jump", "HighJump"},
    {"HitBox", "HitBox"},
    {"KillAura", "KillAura"},
    {"knock back Players", "KnockBackPlayer"},
    {"no clip", "DevNoClip"},
    {"NoFall", "NoFall"},
    {"no fall damage", "NoFallDmg"},
    {"QuickPlaceBlock", "QuickPlaceBlock"},
    {"RaketButton", "RaketButton"},
    {"Reach", "Reach"},
    {"ReachPlayers", "ReachPlayers"},
    {"Skate", "Skate"},
    {"Speed", "Speed"},
    {"Teleport Click", "TpClick"},
    {"Teleport Killer", "TeleportKiller"},
    {"long jump", "LongJump"},
    {"unlimited jumps", "Fly"},
    {"WallHack", "WallHack"},
    {"UnDeath", "UnDeath"},
}

local function addCategory(categoryName, items)
    GMSetting:addTab("Zn", categoryName)
    for _, item in ipairs(items) do
        local displayName, internalName = item[1], item[2]
        GMSetting:addItem(categoryName, "" .. displayName, internalName)
    end
end

if bw then
    addCategory("hacks", hacksItemsBW)
else
    addCategory("hacks", hacksItemsOther)
end

local effectsItems = {
    {"D-Pad Jump", "JumpDpad"},
    {"Dmg Ind", "DmgInc"},
    {"EquipNinjaShoes", "EquipNinjaShoes"},
    {"Esp", "EspMode"},
    {"EspV2", "EspV2"},
    {"find enemy", "CountEnemies"},
    {"Get My Data", "GetMyData"},
    {"Get Player Data", "GetDataPlayer"},
    {"Hide Armor", "HideArmor"},
    {"Hide Hold Item", "HideHoldItem"},
    {"Hide Me", "HideMe"},
    {"ModifyAllCarsSpeed", "ModifyAllCarsSpeed"},
    {"No Lag", "NoLag"},
    {"Show All Control", "ShowAllControl"},
    {"Sprint Run", "enableSprint"},
    {"stop players", "StopPlayers"},
    {"lag players", "LagPlayers"},
    {"Strafe", "Strafe"},
    {"Tracer", "Tracer"},
    {"Unlock FPS", "UnlockFps"},
    {"WWE Camera", "WWE_Camera"},
    {"Water Push", "WaterPush"},
    {"Fast Reload Gun", "instantReload"},
    {"run file", "RunFile"},
    {"runCode", "Runcode"},
}
addCategory("effects", effectsItems)

local Zn = CGame.Instance():getGameType()
local isJailBreak = (Zn == "g1027" or Zn == "g1014")

if isJailBreak then
    local visualItems = {
        {"^FF0000resetValues", "restValues"},
        {"SetHitBox", "SetHitBox"},
        {"SetSpeed", "SetSpeed"},
        {"SetHighJump", "SetHighJump"},
        {"SetAimBot", "SetAimBot"},
        {"SetFov", "SetFov"},
        {"SetMaxFPS", "SetMaxFPS"},
        {"ShowHP", "ShowHp"},
        {"HideHP", "HideHp"},
        {"Day", "Day"},
        {"Night", "Night"},
        {"Evening", "Evening"},
        {"Snow", "Snow"},
    }
    addCategory("visual", visualItems)
end

addCategory("teleport", {
    {"Teleport All To Me", "TpVisual"},
    {"Teleport Mobs To Me", "TpMobs"},
    {"Teleport By ID Players", "TeleportById"},
    {"Teleport Players List", "GUI"},
    {"SavePos", "TpBackMyPos"},
    {"Teleport To Saved Pos", "TeleportToSavedPosition"},
})

GMSetting:addTab("Zn", "clothes")

local clothesCategories = {
    {name = "Crown",   inc = "increaseCrownId",   dec = "decreaseCrownId",   set = "setCrownId"},
    {name = "Hair",    inc = "increaseHairId",    dec = "decreaseHairId",    set = "setHairId"},
    {name = "Face",    inc = "increaseFaceId",    dec = "decreaseFaceId",    set = "setFaceId"},
    {name = "Glasses", inc = "increaseGlassesId", dec = "decreaseGlassesId", set = "setGlassesId"},
    {name = "Scarf",   inc = "increaseScarfId",   dec = "decreaseScarfId",   set = "setScarfId"},
    {name = "Wings",   inc = "increaseBackId",    dec = "decreaseBackId",    set = "setBackId"},
    {name = "Tops",    inc = "increaseShirtId",   dec = "decreaseShirtId",   set = "setShirtId"},
    {name = "Pants",   inc = "increasePantsId",   dec = "decreasePantsId",   set = "setPantsId"},
    {name = "Shoes",   inc = "increaseShoesId",   dec = "decreaseShoesId",   set = "setShoesId"},
}

for _, item in ipairs(clothesCategories) do
    GMSetting:addItem("clothes", item.name .. " --->", "nil")
    GMSetting:addItem("clothes", "  Change Id [+]", item.inc)
    GMSetting:addItem("clothes", "  Change Id [-]", item.dec)
    GMSetting:addItem("clothes", "  Set [ID]", item.set)
    GMSetting:addItem("clothes", "<--- " .. item.name, "nil")
end

GMSetting:addTab("Zn", "vip player")
local vipItems = {
    {text = "Vip1", key = "UpdatePlayerNickname"},
    {text = "Vip2", key = "UpdatePlayerNickname2"},
    {text = "Vip3", key = "UpdatePlayerNickname3"},
    {text = "Vip4", key = "UpdatePlayerNickname4"},
    {text = "Vip5", key = "UpdatePlayerNickname5"},
    {text = "Vip6", key = "UpdatePlayerNickname6"},
    {text = "Vip7", key = "UpdatePlayerNickname7"},
    {text = "Vip8", key = "UpdatePlayerNickname8"},
    {text = "Vip9", key = "UpdatePlayerNickname9"},
    {text = "Vip10", key = "UpdatePlayerNickname10"},
    {text = "Vip10+", key = "UpdatePlayerNickname11"},
}
addItemsWithSpacing("vip player", vipItems, 2)

if Zn == "g1014" then
    GMSetting:addTab("Zn", "items")
    local items = {}

    LuaTimer:schedule(function()
        for id = 1, 6999 do
            local item = Item.getItemById(id)
            if item then
                local name = item:getUnlocalizedName() .. ".name"
                local lang = Lang:getString(name)
                if lang == name then
                    name = "item." .. string.gsub(item:getUnlocalizedName(), "item.", "") .. ".name"
                    lang = Lang:getString(name)
                    if lang == name then
                        lang = "Item: " .. tostring(id)
                    else
                        lang = lang .. " (" .. tostring(id) .. ")"
                    end
                else
                    lang = lang .. " (" .. tostring(id) .. ")"
                end
                table.insert(items, {text = lang, key = "getItem", param = tostring(id)})
            end
        end

        local function addItemsWithBatchSpacing(tab, items, batchSize)
            batchSize = batchSize or 4
            local count = 0
            for _, item in ipairs(items) do
                if item.text ~= "" and item.key ~= "" then
                    GMSetting:addItem(tab, item.text, item.key, item.param or "")
                    count = count + 1
                    if count % batchSize == 0 then
                        GMSetting:addItem(tab, "<-- More items -->", "")
                    end
                end
            end
            if count % batchSize ~= 0 then
                GMSetting:addItem(tab, "<-- More items -->", "")
            end
        end

        addItemsWithBatchSpacing("items", items, 4)
    end, 0)
end

addCategory("panel", {
    {"hide panel", "HidePanel"},
    {"MovablePanel", "MovablePanel"},
})

addCategory("button", {
    {"HitBox Button", "HitBoxBtn"},
    {"Speed Button", "SpeedBtn"},
    {"Tp Killer Button", "TeleportKillerBtn"},
    {"Tp Click Button", "TpClickBtn"},
    {"Blink Button", "BlinkBtn"},
    {"AimBot Button", "AimBotBtn"},
    {"Skate Button", "SkateBtn"},
    {"High Jump Button", "HighJumpBtn"},
})

addCategory("Customizer", {
    {"Add Function", "cb"},
})

addCategory("Chat", {
    {"Chat Bypass", "WordBypass"},
})

local Zn = CGame.Instance():getGameType()

if Zn == "g1008" then
    GMSetting:addTab("Zn", "bedwars")
    local bedwarsItems = {
--        {text = "Destroyed Bed", func = "BedDestroyer"}, Wait New Version
--        {text = "Inf Jump BW", func = "InfJumpBW"},
--        {text = "Fly For BW", func = "DevFlyBW"},
--        {text = "Speed For BW", func = "SpeedBW"},
--        {text = "Teleport Click BW", func = "TpClickBW"},
--        {text = "Bypass Speed", func = "SoftBypassSpeed"},
--        {text = "Fast Jump BW", func = "FastJumpBW"},
    }
    for _, item in ipairs(bedwarsItems) do
        GMSetting:addItem("bedwars", item.text, item.func)
    end

elseif Zn == "g1027" then
    GMSetting:addTab("Zn", "sky royale")
    local teams = {
        {name = "Red (new)", color = "^FF0000", func = "TpTeamRedNew"},
        {name = "Blue (new)", color = "^0000FF", func = "TpTeamBlueNew"},
        {name = "Yellow (new)", color = "^FFFF00", func = "TpTeamYellowNew"},
        {name = "Green (new)", color = "^008000", func = "TpTeamGreenNew"},
        {name = "Mid (new)", color = "^FF00FF", func = "TpMidNew"},
        {name = "Red (old)", color = "^FF0000", func = "TpTeamRedOld"},
        {name = "Blue (old)", color = "^0000FF", func = "TpTeamBlueOld"},
        {name = "Yellow (old)", color = "^FFFF00", func = "TpTeamYellowOld"},
        {name = "Green (old)", color = "^008000", func = "TpTeamGreenOld"},
        {name = "Mid (old)", color = "^FF00FF", func = "TpMidOld"},
    }
    for _, team in ipairs(teams) do
        GMSetting:addItem("sky royale", team.color .. "Tp to " .. team.name, team.func)
    end
end

if Zn == "g1072" then
    addCategory("clan wars", {
--        {"^FF0000Tp to Red Clan", "tp_flag1"}, Wait New Version
--        {"^0000FFTp to Blue Clan", "tp_flag2"},
--       {"^FF0000Steal Red Flag", "Soon"},
--       {"^0000FFSteal Flag Blue", "Soon"},
--       {"attack player", "Soon"},
    })
elseif Zn == "g1014" then
    addCategory("jail break", {
        {"Tp Police", "TpPolice"},
        {"Tp Jail", "TpJail"},
        {"Tp Bink", "TpBank"},
        {"Tp Shop", "TpShop"},
        {"Tp JailShop", "TpJailShop"},
        {"Tp Library", "TpLibrary"},
        {"Tp McDonald", "TpMcDonald"},
        {"Tp Church", "TpChurch"},
        {"Tp Trade (1)", "TpTrade1"},
        {"Tp TradeV2 (1)", "TpTrade2_V1"},
        {"Tp TradeV2 (2)", "TpTrade2_V2"},
        {"Auto Loot", "JBAutoLoot"},
        {"Item Thief", "ItemThief"},
    })
elseif Zn == "g1055" then
    addCategory("wwe sim", {
        {"Edit Size", "EditSize"},
        {"Auto Sell", "AutoSell"},
        {"Inf Shiled", "InfShield"},
        {"Equip Sun", "EquipSun"},
        {"Equip Earth", "EquipEarth"},
        {"Equip Air Craft", "EquipAirCraff"},
        {"Change Skin (WWE Sim)", "ChangeSkinSim"},
        {"Heal Skin (WWE Sim)", "HealSim"},
    })
end

GMSetting:addTab("Zn", "credits")
local creditsItems = {
    {text = "-->", key = "a"},
    {text = "^0000FFDis^FFFFFFcord", key = "b"},
    {text = "^FF0000You^FFFFFFTube", key = "c"},
    {text = "", key = "d"},
    {text = "", key = "e"},
    {text = "-->", key = "f"},
    {text = "^FF0000zentex^FFFFFFhacker", key = "g"},
    {text = "^FF0000@Zentex^FFFFFFHacker-12", key = "h"},
    {text = "", key = "s"},
    {text = "", key = "t"},
    {text = "-->", key = "u"},
    {text = "^FF0000vape^FFFFFFblockmango", key = "v"},
    {text = "^FF0000@1-khd^FFFFFFbg", key = "w"},
    {text = "", key = "s"},
    {text = "", key = "t"},
    {text = "-->", key = "u"},
    {text = "^FF0000cyber^FFFFFFbg14", key = "v"},
    {text = "^FF0000@cyber^FFFFFFbmgo", key = "w"},
    {text = "^00FFFFBGFX ^FFFFFFApk:", key = "x"},
    {text = "^00FFFFZNF^FFFFFFDev", key = "y"},
    {text = "^00FFFFKing^FFFFFFKM", key = "z"},
}
addItemsWithSpacing("credits", creditsItems, 3)

local function isGMOpen(userId)
    if isClient then
        return true
    end
    return TableUtil.include(AdminIds, tostring(userId))
end

function GMSetting:addTab(tab_prefix, tab_name)
    if tab_prefix ~= "Zn" then
        return
    end 

    local final_tab_name = tab_name 

    for _, setting in pairs(Settings) do
        if setting.name == final_tab_name then
            setting.items = {}
            return
        end
    end

    table.insert(Settings, { name = final_tab_name, items = {} })
end

function GMSetting:addItem(tab_name, item_name, func_name, ...)
    local settings
    for _, group in pairs(Settings) do
        if group.name == tab_name then
            settings = group
            break
        end
    end

    if not settings then
        return
    end

    table.insert(settings.items, { name = item_name, func = func_name, params = { ... } })
end

function GMSetting:getSettings()
    return Settings
end

function GMHelper:enableGM()
    if GUIGMControlPanel then
        return
    end

    GUIGMControlPanel = UIHelper.newEngineGUILayout("GUIGMControlPanel", "GMControlPanel.json")
    GUIGMControlPanel:hide()

    GUIGMMain = UIHelper.newEngineGUILayout("GUIGMMain", "GMMain.json")
    GUIGMMain:show()

    local isOpenEventDialog = ClientHelper.getBoolForKey("g1008_isOpenEventDialog", false)
    if GUIGMMain.changeOpenEventDialog then
        GUIGMMain:changeOpenEventDialog(isOpenEventDialog)
    end

    if GMSetting.addItemGMItems then
        GMSetting:addItemGMItems()
        GMSetting.addItemGMItems = nil
    end
end

function GMHelper:openInput(paramTexts, callBack)
    if type(paramTexts) ~= "table" then
        return
    end

    for _, paramText in pairs(paramTexts) do
        if type(paramText) ~= "string" then
            if isClient then
                error("param need string type")
            end
            return
        end
    end

    if GUIGMControlPanel and GUIGMControlPanel.openInput then
        GUIGMControlPanel:openInput(paramTexts, callBack)
    else
        error("GUIGMControlPanel or its method openInput is not available")
    end
end

---<[{ Call Function }]>---

function GMHelper:callCommand(name, ...)
    local func = self[name]
    if type(func) == "function" then
        func(self, ...)
    end

    local data = { name = name, params = { ... } }
end

---<[{ Effects Design Style }]>---

local brightness = 1.0
local direction = -0.01



local CONFIG = {
    ANIMATION = {
        TYPING_SPEED = 0.15,
        FADE_SPEED = 0.03,
        PAUSE_DURATION = 1.5,
        TIMER_INTERVAL = 30,
        TIMER_REPEAT = -1,
        PULSE_SPEED = 3,
        GLOW_SPEED = 5,
        ROTATION_SPEED = 2
    },
    UI = {
        BASE_FONT_SIZE = 14,
        GRID_CONFIG = { rows = 10, cols = 10, spacing = 5 },
        TAB_ITEM_SPACE = 5,
        MAX_INPUT_LENGTH = 1200,
        MAX_FILTER_LENGTH = 500,
        ITEM_HEIGHT = 40
    },
    TEXT = {
        CLOSE_BUTTON = "×",
        PLACEHOLDER = "Search Feature/Item",
        CREDIT_TEXT = "By: ZentexHacker, KhdBg, CyberBg"
    }
}

function UIGMControlPanel:onLoad()
    self:initializeBaseUI()
    self:setupComponents()
    self:setupEventHandlers()
    self:initializeAnimation()
end

function UIGMControlPanel:initializeBaseUI()
    self.root:SetLevel(1)
    self:getChildWindow("GMControlPanel-Close-Text"):SetText(CONFIG.TEXT.CLOSE_BUTTON)
end

function UIGMControlPanel:setupComponents()
    local llTabs = self:getChildWindow("GMControlPanel-Tabs")
    self.lvTabs = IGUIListView.new("GMControlPanel-Tabs-List", llTabs)
    self.lvTabs:setItemSpace(CONFIG.UI.TAB_ITEM_SPACE)
    self.llInput = self:getChildWindow("GMControlPanel-Input-Layout", GUIType.Layout)
    self.llInput:SetVisible(false)
    self.edInput = self:getChildWindow("GMControlPanel-Input-Edit", GUIType.Edit)
    self.edInput:SetMaxLength(CONFIG.UI.MAX_INPUT_LENGTH)
    self.edInput:SetVisible(true)
    self.edInput:SetTextColor({ 0, 0, 0, 0 })
    self.edInput:SetText(CONFIG.TEXT.PLACEHOLDER)
    local llContent = self:getChildWindow("GMControlPanel-Content")
    self.gvItems = IGUIGridView.new("GMControlPanel-Items-List", llContent)
    self.gvItems:setConfig(CONFIG.UI.GRID_CONFIG.rows, CONFIG.UI.GRID_CONFIG.cols, CONFIG.UI.GRID_CONFIG.spacing)
    local itemWidth = (self.gvItems:getWidth() - 60) / 5
    self.adapter = UIHelper.newEngineAdapter("GMItemAdapter")
    self.adapter:setItemSize(itemWidth, CONFIG.UI.ITEM_HEIGHT)
    self.gvItems:setAdapter(self.adapter)
    self.etFilterValue = self:getChildWindow("GMControlPanel-FilterValue", GUIType.Edit)
    self.etFilterValue:SetMaxLength(CONFIG.UI.MAX_FILTER_LENGTH)
    self.etFilterValue:SetBackgroundColor({ 0, 0, 0, 0 })
    self:setupAnimatedText()
end

function UIGMControlPanel:setupAnimatedText()
    self.stFilterText = self:getChildWindow("GMControlPanel-FilterText", GUIType.StaticText)
    self.stFilterText:SetBordered(true)
    self.baseX, self.baseY = self.stFilterText:GetPosition()
    self.animationState = {
        displayText = "",
        charIndex = 1,
        timerAcc = 0,
        fadeState = "typing",
        fadeAlpha = 1,
        pauseTime = 0,
        pulse = 0,
        glowPulse = 0,
        rotationPulse = 0
    }
end

function UIGMControlPanel:setupEventHandlers()
local btnClose = self:getChildWindow("GMControlPanel-Close", GUIType.Button)
btnClose:registerEvent(GUIEvent.ButtonClick, function() self:hide() end)


self.etFilterValue:registerEvent(GUIEvent.EditTextInput, function(args)
if args.trigger == 0 then self:selectTab(self.tab) end
end)


self.edInput:registerEvent(GUIEvent.EditTextInput, function(args)
if args.trigger == 0 then self:inputText() end
end)


self.llInput:registerEvent(GUIEvent.Click, function()
self:closeInput()
end)


if self.gvItems and self.gvItems.root then
self.gvItems.root:registerEvent(GUIEvent.ItemClick, function(args)
print("Item clicked in GMControlPanel")
end)
end
end

function UIGMControlPanel:initializeAnimation()
    local lastTime = os.clock()
    LuaTimer:scheduleTimer(function()
        local currentTime = os.clock()
        local dt = currentTime - lastTime
        lastTime = currentTime
        self:updateTextAnimation(dt)
    end, CONFIG.ANIMATION.TIMER_INTERVAL, CONFIG.ANIMATION.TIMER_REPEAT)
end

function UIGMControlPanel:updateTextAnimation(dt)
    local state = self.animationState
    local config = CONFIG.ANIMATION
    state.pulse = state.pulse + dt * config.PULSE_SPEED
    state.glowPulse = state.glowPulse + dt * config.GLOW_SPEED
    state.rotationPulse = state.rotationPulse + dt * config.ROTATION_SPEED
    self:handleTypingAnimation(dt, state, config)
    self:applyVisualEffects(state)
end

function UIGMControlPanel:handleTypingAnimation(dt, state, config)
    if state.fadeState == "typing" then
        self:handleTypingState(dt, state, config)
    elseif state.fadeState == "pause" then
        self:handlePauseState(dt, state, config)
    elseif state.fadeState == "fadeOut" then
        self:handleFadeOutState(state, config)
    elseif state.fadeState == "fadeIn" then
        self:handleFadeInState(state, config)
    end
end

function UIGMControlPanel:handleTypingState(dt, state, config)
    state.timerAcc = state.timerAcc + dt
    if state.timerAcc >= config.TYPING_SPEED then
        state.timerAcc = state.timerAcc - config.TYPING_SPEED
        if state.charIndex <= #CONFIG.TEXT.CREDIT_TEXT then
            local letter = CONFIG.TEXT.CREDIT_TEXT:sub(state.charIndex, state.charIndex)
            state.displayText = state.displayText .. letter
            self.stFilterText:SetText(state.displayText)
            state.charIndex = state.charIndex + 1
        else
            state.fadeState = "pause"
            state.pauseTime = 0
        end
    end
    state.fadeAlpha = 1
end

function UIGMControlPanel:handlePauseState(dt, state, config)
    state.pauseTime = state.pauseTime + dt
    if state.pauseTime >= config.PAUSE_DURATION then
        state.fadeState = "fadeOut"
    end
    state.fadeAlpha = 1
end

function UIGMControlPanel:handleFadeOutState(state, config)
    state.fadeAlpha = state.fadeAlpha - config.FADE_SPEED
    if state.fadeAlpha <= 0 then
        state.fadeAlpha = 0
        state.fadeState = "fadeIn"
        state.displayText = ""
        state.charIndex = 1
    end
    self.stFilterText:SetText(state.displayText)
end

function UIGMControlPanel:handleFadeInState(state, config)
    state.fadeAlpha = state.fadeAlpha + config.FADE_SPEED
    if state.fadeAlpha >= 1 then
        state.fadeAlpha = 1
        state.fadeState = "typing"
        state.displayText = ""
        state.charIndex = 1
    end
end

function UIGMControlPanel:applyVisualEffects(state)
    brightness = brightness + direction
    if brightness < 0.6 then
        brightness = 0.6
        direction = 0.01
    elseif brightness > 1.0 then
        brightness = 1.0
        direction = -0.01
    end
    local r, g, b, a = interpolatePurple(brightness)
    local glowAlpha = 0.8 + 0.2 * math.sin(state.glowPulse * math.pi * 2)
    local finalAlpha = state.fadeAlpha * glowAlpha
    self.stFilterText:SetTextColor({r, g, b, finalAlpha})
    local scale = 1 + 0.05 * math.sin(state.glowPulse * math.pi * 2)
    self.stFilterText:SetFontSize(CONFIG.UI.BASE_FONT_SIZE * scale)
    local moveY = 5 * math.sin(state.pulse)
    local moveX = 10 * math.sin(state.rotationPulse)
    self.stFilterText:SetPosition(self.baseX + moveX, self.baseY + moveY)
end

local brightness = 1.0
local direction = -0.01



local UIGMTab = require "engine_client.ui.window.GUIGMTab"
local UIGMItem = require "engine_client.ui.window.GUIGMItem"

local currentSelectedTab = nil

function UIGMTab:onLoad()
    self.tvTab = self:getChildWindowByName("GMButton", GUIType.StaticText)
    self.tvTab:SetBordered(true)

    self.tvTab:registerEvent(GUIEvent.Click, function()
        if currentSelectedTab and currentSelectedTab ~= self then
            currentSelectedTab:resetTabColor()
        end
        currentSelectedTab = self
        self:setSelectedTabColor()
        GUIGMControlPanel:selectTab(self.name)
    end)

    local function updateOrangeDarkOrange()
        brightness = brightness + direction
        if brightness < 0.6 then
            brightness = 0.6
            direction = 0.01
        elseif brightness > 1.0 then
            brightness = 1.0
            direction = -0.01
        end
        local r, g, b, a = interpolatePurple(brightness)
        self.tvTab:SetTextColor({ r, g, b, a })
    end

    LuaTimer:scheduleTimer(updateOrangeDarkOrange, 100, -1)

    self:resetTabColor()
end

local brightness = 1.0
local direction = -0.01



GUIGMItem = require("engine_client.ui.window.GUIGMItem")

function GUIGMItem:onLoad()
    self.tvItem = self:getChildWindowByName("GMButton", GUIType.StaticText)

    self.tvItem:registerEvent(GUIEvent.Click, function()
        if self.data and self.data.func ~= "" then
            local params = TableUtil.copyTable(self.data.params or {})
            table.insert(params, self.tvItem)
            GMHelper:callCommand(self.data.func, unpack(params))
        end
    end)
end

GUIGMItem = require("engine_client.ui.window.GUIGMItem")

function UIGMControlPanel:openInput(paramTexts, callBack)
    self.llInput:SetVisible(true)
    self.paramTexts = paramTexts
    self.inputTable = {}
    self.callBack = callBack

    local buttonWidth = 100
    local buttonHeight = 40
    local buttonSpacing = 10
    local baseX = 0
    local baseY = -625

    local enterName = "EnterButton_"..math.random(1000,9999)
    self.enterButton = GUIManager:createGUIWindow(GUIType.Button, enterName)
    self.enterButton:SetHeight({0, buttonHeight})
    self.enterButton:SetWidth({0, buttonWidth})
    self.enterButton:SetHorizontalAlignment(HorizontalAlignment.Left)
    self.enterButton:SetVerticalAlignment(VerticalAlignment.Bottom)
    self.enterButton:SetTouchable(true)
    self.enterButton:SetVisible(true)
    self.enterButton:SetXPosition({0, baseX})
    self.enterButton:SetYPosition({0, baseY})
    self.enterButton:SetText("Enter")
    self.enterButton:SetBackgroundColor({0, 1, 0, 1})
    self.enterButton:registerEvent(GUIEvent.ButtonClick, function()
        self:inputText()
    end)
    self.llInput:AddChildWindow(self.enterButton)

    local clearName = "ClearButton_"..math.random(1000,9999)
    self.clearButton = GUIManager:createGUIWindow(GUIType.Button, clearName)
    self.clearButton:SetHeight({0, buttonHeight})
    self.clearButton:SetWidth({0, buttonWidth})
    self.clearButton:SetHorizontalAlignment(HorizontalAlignment.Left)
    self.clearButton:SetVerticalAlignment(VerticalAlignment.Bottom)
    self.clearButton:SetTouchable(true)
    self.clearButton:SetVisible(true)
    self.clearButton:SetXPosition({0, baseX + buttonWidth + buttonSpacing})
    self.clearButton:SetYPosition({0, baseY})
    self.clearButton:SetText("Clear")
    self.clearButton:SetBackgroundColor({1, 0, 0, 1})
    self.clearButton:registerEvent(GUIEvent.ButtonClick, function()
        self.edInput:SetText("")
    end)
    self.llInput:AddChildWindow(self.clearButton)

    local copyName = "CopyButton_"..math.random(1000,9999)
    self.copyButton = GUIManager:createGUIWindow(GUIType.Button, copyName)
    self.copyButton:SetHeight({0, buttonHeight})
    self.copyButton:SetWidth({0, buttonWidth})
    self.copyButton:SetHorizontalAlignment(HorizontalAlignment.Left)
    self.copyButton:SetVerticalAlignment(VerticalAlignment.Bottom)
    self.copyButton:SetTouchable(true)
    self.copyButton:SetVisible(true)
    self.copyButton:SetXPosition({0, baseX + (buttonWidth + buttonSpacing) * 2})
    self.copyButton:SetYPosition({0, baseY})
    self.copyButton:SetText("Copy")
    self.copyButton:SetBackgroundColor({0, 0, 1, 1})
    self.copyButton:registerEvent(GUIEvent.ButtonClick, function()
        local text = self.edInput:GetText()
        if text ~= "" then
            GUIManager:CopyToClipboard(text)
        end
    end)
    self.llInput:AddChildWindow(self.copyButton)

    LuaTimer:schedule(function()
        self:showInputBox()
    end, 50)
end

function UIGMControlPanel:showInputBox()
    self.tipText = tostring(self.paramTexts[#self.inputTable + 1])
    self.edInput:SetText(self.tipText)
    self.edInput:OpenKeyboard()
    LuaTimer:schedule(function()
        self.edInput:TouchUp({VectorUtil.newVector2(0, 0)})
    end, 50)
end

function UIGMControlPanel:inputText()
    local text = self.edInput:GetText()
    if self.tipText == text then return end
    table.insert(self.inputTable, text)
    if #self.inputTable < #self.paramTexts then
        self:showInputBox()
    else
        self.edInput:SetText("")
        if self.callBack then
            self.callBack(unpack(self.inputTable))
            self:closeInput()
        end
    end
end

function UIGMControlPanel:closeInput()
    self.llInput:SetVisible(false)
    self.paramTexts = {}
    self.inputTable = {}
    self.callBack = nil
    self.edInput:SetText("")
    if self.enterButton then self.enterButton:SetVisible(false) end
    if self.clearButton then self.clearButton:SetVisible(false) end
    if self.copyButton then self.copyButton:SetVisible(false) end
end

GUIGMItem = require("engine_client.ui.window.GUIGMItem")
local pendingCb = nil
local pendingRemove = false
local allItems = allItems or {}

function GMHelper:cb(callback)
    pendingCb = callback or function() end
    pendingRemove = false
end

function GMHelper:Acb(callback)
    pendingCb = callback or function() end
    pendingRemove = true
end

function GMHelper:HandleCustomizeClick(clickedItem)
    if pendingCb and not pendingRemove then
        local cb = pendingCb
        pendingCb = nil
        local newItemName = (clickedItem.data and clickedItem.data.name) or "Custom"
        GMSetting:addItem("Customizer", newItemName, (clickedItem.data and clickedItem.data.func) or "")
        cb(clickedItem)
        if GUIGMControlPanel then
            GUIGMControlPanel:selectTab("Zn", "Customizer")
        end
    end
end

function GMHelper:HandleRemoveClick(clickedItem)
    if pendingCb and pendingRemove then
        local cb = pendingCb
        pendingCb = nil
        pendingRemove = false
        local itemName = clickedItem.data and clickedItem.data.name
        if itemName and itemName ~= "Add Function" and itemName ~= "Remove Function" then
            GMSetting:removeItem("Customizer", itemName)
            cb(clickedItem)
            if GUIGMControlPanel then
                GUIGMControlPanel:selectTab("Zn", "Customizer")
            end
        end
    end
end

function GUIGMItem:onLoad()
    self.tvItem = self:getChildWindowByName("GMButton", GUIType.StaticText)
    if self.tvItem then
        table.insert(allItems, self)
        self.tvItem:registerEvent(GUIEvent.Click, function()
            if pendingCb then
                if pendingRemove then
                    GMHelper:HandleRemoveClick(self)
                else
                    GMHelper:HandleCustomizeClick(self)
                end
                return
            end

            if self.data and self.data.func and self.data.func ~= "" then
                local params = TableUtil.copyTable(self.data.params or {})
                table.insert(params, self.tvItem)
                GMHelper:callCommand(self.data.func, unpack(params))
            end
        end)
    end
end

function GMSetting:removeItem(tabName, itemName)
    if not self.tabs or not self.tabs[tabName] then return end
    local items = self.tabs[tabName].items
    if not items then return end
    for i = #items, 1, -1 do
        if items[i].name == itemName then
            table.remove(items, i)
            break
        end
    end
end

function GUIGMItem:onDataChanged(data)
    self.data = data
    if not self.tvItem or not data then return end
    self.tvItem:SetProperty("Font", "HT12")
    self.tvItem:SetText(data.name or "Unnamed")
    if self.tvItem:GetTextWidth() > self.tvItem:GetPixelSize().x then
        self.tvItem:SetProperty("Font", "HT12")
        if self.tvItem:GetTextWidth() > self.tvItem:GetPixelSize().x then
            self.tvItem:SetProperty("Font", "HT10")
        end
    end
    if data.func == "" then
        self.tvItem:SetBackgroundColor(Color.TRANS)
    elseif data.color then
        self.tvItem:SetBackgroundColor(data.color)
    end
end

function UIHelper.showToast(content, time, hideBG)
    if ToastText == nil then
        ToastText = GUIManager:createGUIWindow(GUIType.StaticText, "GUIRoot-Toast")
        ToastText:SetHorizontalAlignment(HorizontalAlignment.Center)
        ToastText:SetVerticalAlignment(VerticalAlignment.Bottom)
        ToastText:SetTextHorzAlign(HorizontalAlignment.Center)
        ToastText:SetTextVertAlign(VerticalAlignment.Center)
        ToastText:SetHeight({ 0, 45 })
        ToastText:SetYPosition({ 0, -120 })
        ToastText:SetLevel(1)
        ToastText:SetTouchable(false)
        GUISystem.Instance():GetRootWindow():AddChildWindow(ToastText)
    end

    LuaTimer:cancel(ToastTimer)
    LuaTimer:cancel(SlideTimer)
    LuaTimer:cancel(FadeTimer)
    
    ToastText:SetVisible(true)
    ToastText:SetText(content)
    
    local animationDuration = time or 3000
    local slideInTime = 400
    local fadeOutTime = 300
    local slideOutTime = 400
    
    local baseYPosition = -120
    local hiddenYPosition = 50
    local currentYPosition = hiddenYPosition
    local currentAlpha = 1.0
    
    ToastText:SetYPosition({ 0, hiddenYPosition })
    ToastText:SetScale(VectorUtil.newVector3(1.0, 1.0, 1.0))
    
    if hideBG then
        ToastText:SetBackgroundColor(Color.TRANS)
        ToastText:SetTextColor({ 1, 1, 1, 0 })
    else
        ToastText:SetBackgroundColor({ 0.8, 0.4, 0.0, 0 })
        ToastText:SetTextColor({ 1, 1, 1, 0 })
        ToastText:SetWidth({ 0, ToastText:GetTextWidth() + 25 })
    end
    
    local slideInStartTime = os.clock()
    
    SlideTimer = LuaTimer:scheduleTicker(function()
        local elapsed = (os.clock() - slideInStartTime) * 1000
        local progress = math.min(elapsed / slideInTime, 1.0)
        
        local easeOut = 1 - math.pow(1 - progress, 4)
        currentYPosition = hiddenYPosition + (baseYPosition - hiddenYPosition) * easeOut
        currentAlpha = progress
        
        ToastText:SetYPosition({ 0, currentYPosition })
        
        if hideBG then
            ToastText:SetTextColor({ 1, 1, 1, currentAlpha })
        else
            ToastText:SetBackgroundColor({ 0.8, 0.4, 0.0, currentAlpha * 0.9 })
            ToastText:SetTextColor({ 1, 1, 1, currentAlpha })
        end
        
        if progress >= 1.0 then
            LuaTimer:cancel(SlideTimer)
        end
    end, 16, math.ceil(slideInTime / 16))
    
    ToastTimer = LuaTimer:schedule(function()
        local fadeStartTime = os.clock()
        local slideOutStartTime = os.clock()
        
        FadeTimer = LuaTimer:scheduleTicker(function()
            local elapsed = (os.clock() - fadeStartTime) * 1000
            local fadeProgress = math.min(elapsed / fadeOutTime, 1.0)
            local slideProgress = math.min(elapsed / slideOutTime, 1.0)
            
            currentAlpha = 1.0 - fadeProgress
            local easeIn = slideProgress * slideProgress
            currentYPosition = baseYPosition + (hiddenYPosition - baseYPosition) * easeIn
            
            ToastText:SetYPosition({ 0, currentYPosition })
            
            if hideBG then
                ToastText:SetTextColor({ 1, 1, 1, currentAlpha })
            else
                ToastText:SetBackgroundColor({ 0.8, 0.4, 0.0, currentAlpha * 0.9 })
                ToastText:SetTextColor({ 1, 1, 1, currentAlpha })
            end
            
            if fadeProgress >= 1.0 and slideProgress >= 1.0 then
                ToastText:SetVisible(false)
                LuaTimer:cancel(FadeTimer)
            end
        end, 16, math.ceil(math.max(fadeOutTime, slideOutTime) / 16))
    end, animationDuration - math.max(fadeOutTime, slideOutTime))
end

function UIGMItem:setBackgroundColor(color)
    self.itemBackground:SetBackgroundColor(color)
    self.currentBgColor = color
end

function UIGMTab:setSelectedTabColor()
    self.tvTab:SetBackgroundColor({0.8, 0.4, 0.0, 1})
    SoundUtil.playSound(0)
end

function UIGMTab:resetTabColor()
    self.tvTab:SetBackgroundColor({0, 0, 0, 0.8})
end

function UIGMTab:onTabChange(newTab)
    if newTab ~= self.name then
        self:resetTabColor()
        UIGMItem:setBackgroundColor({0.8, 0.4, 0.0, 1})
        UIGMItem:onDataChanged(data)
        UIHelper.showOpenAnim(self)
        GMSetting:addItem(itemName)
        SoundUtil.playSound(0)
    end
end

function UIGMItem:onItemChange(newItem)
    if newItem ~= self.name then
        UIGMItem:setBackgroundColor({0.8, 0.4, 0.0, 1})
        UIGMItem:onDataChanged(data)
        UIHelper.showOpenAnim(self)
        GMSetting:addItem(itemName)
        SoundUtil.playSound(0)
    end
end

---<[{ Mod Menu Code }]>---

function GMHelper:Fly(button)
    self.isFlyEnabled = not self.isFlyEnabled
    _G["togFly"] = self.isFlyEnabled
    refreshButtonColorSave("Fly")

    local player = PlayerManager:getClientPlayer()

    if self.isFlyEnabled then
        SaveItem("Fly", "Fly")
        ClientHelper.putBoolPrefs("EnableDoubleJumps", true)
        player.doubleJumpCount = math.huge
        item.color = {0.8, 0.4, 0.0, 1}
        button:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
        UIHelper.showToast("^00FF00Enabled")
    else
        ClientHelper.putBoolPrefs("EnableDoubleJumps", false)
        player.doubleJumpCount = 1
        item.color = Color.BLACK
        button:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
    end
end

function GMHelper:getItem(id)
    PlayerManager:getClientPlayer().Player:getInventory():addItemToInventory(Item.getItemById(tonumber(id), 1, nil, nil), 1)
end

local savedPos = nil

function setPosTest(targetPos)
    if targetPos.y < 10 then return end

    local clientWrapper = PlayerManager:getClientPlayer()
    if not clientWrapper or not clientWrapper.Player then return end
    local clientPlayer = clientWrapper.Player

    local myPos = clientPlayer:getPosition()
    local yaw = clientPlayer.rotationYaw
    local pitch = clientPlayer.rotationPitch

    local disTp = { x = targetPos.x - myPos.x, z = targetPos.z - myPos.z }
    local totalDistance = math.sqrt(disTp.x * disTp.x + disTp.z * disTp.z)

    UIHelper.showToast("Distance: " .. string.format("%.2f", totalDistance))

    if myPos.y < 165 then myPos.y = 165 end

    if math.abs(disTp.x) > 16 then
        myPos.x = myPos.x + (disTp.x > 0 and 16 or -16)
        clientPlayer:setPosition(myPos)
        LuaTimer:scheduleTimer(function()
            setPosTest(targetPos)
        end, 0.015, 1)
        return
    end

    if math.abs(disTp.z) > 16 then
        myPos.z = myPos.z + (disTp.z > 0 and 16 or -16)
        clientPlayer:setPosition(myPos)
        LuaTimer:scheduleTimer(function()
            setPosTest(targetPos)
        end, 0.015, 1)
        return
    end

    local function checkBlock(pos)
        while EngineWorld:getBlockId(pos) ~= BlockID.AIR do
            pos.y = pos.y + 1
            if pos.y > 256 then break end
        end
        return pos
    end

    targetPos = checkBlock(targetPos)
    local abovePos = VectorUtil.newVector3(targetPos.x, targetPos.y + 1.2, targetPos.z)

    clientPlayer.noClip = true
    clientPlayer:setPosition(abovePos)
    clientPlayer.noClip = false

    clientPlayer:setPosition(abovePos)
    clientPlayer.rotationYaw = yaw
    clientPlayer.rotationPitch = pitch

    clientPlayer:setVelocity(VectorUtil.newVector3(0, 0.3, 0))
    clientPlayer:setAllowFlying(false)
    clientPlayer:setFlying(false)

    LuaTimer:scheduleOnce(function()
        clientPlayer:setAllowFlying(false)
        clientPlayer:setFlying(false)
    end, 0.0005)

    savedPos = abovePos

    for i = 1, 5 do
        LuaTimer:scheduleOnce(function()
            clientPlayer:setPosition(savedPos)
        end, i * 0.0005)
    end
end

function GMHelper:TpTeamGreenNew()
    local targetPos = VectorUtil.newVector3(565.60, 17.62, 66.16)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:TpTeamRedNew()
    local targetPos = VectorUtil.newVector3(480.45, 16.62, 67.71)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:TpTeamYellowNew()
    local targetPos = VectorUtil.newVector3(478.83, 17.62, -20.16)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:TpTeamBlueNew()
    local targetPos = VectorUtil.newVector3(566.29, 17.62, -21.16)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:TpMidNew()
    local targetPos = VectorUtil.newVector3(521.40, 48.62, 22.70)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:TpTeamGreenOld()
    local targetPos = VectorUtil.newVector3(127.87, 24.62, 507.99)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:TpTeamRedOld()
    local targetPos = VectorUtil.newVector3(66.89, 24.62, 445.73)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:TpTeamYellowOld()
    local targetPos = VectorUtil.newVector3(189.33, 24.62, 446.17)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:TpTeamBlueOld()
    local targetPos = VectorUtil.newVector3(127.95, 24.62, 384.40)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:TpMidOld()
    local targetPos = VectorUtil.newVector3(126.60, 24.62, 445.29)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:TpJailShop()
    local clientWrapper = PlayerManager:getClientPlayer()
    if not clientWrapper or not clientWrapper.Player then return end
    local clientPlayer = clientWrapper.Player
    local targetPos = VectorUtil.newVector3(394.98, 64.62, 164.05)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:TpShop()
    local targetPos = VectorUtil.newVector3(228.16, 63.62, 47.35)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:TpChurch()
    local targetPos = VectorUtil.newVector3(262.40, 63.62, 102.52)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:TpBank()
    local targetPos = VectorUtil.newVector3(124.05, 63.62, 178.14)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:TpMcDonald()
    local targetPos = VectorUtil.newVector3(217.14, 63.62, 178.98)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:TpPolice()
    local targetPos = VectorUtil.newVector3(312.23, 63.62, 232.14)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:TpJail()
    local targetPos = VectorUtil.newVector3(339.97, 63.62, 290.51)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:TpLibrary()
    local targetPos = VectorUtil.newVector3(228.67, 63.62, 259.24)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:TpTrade1()
    local targetPos = VectorUtil.newVector3(180.57, 66.62, 236.83)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:TpTrade2_V1()
    local targetPos = VectorUtil.newVector3(180.43, 66.62, 230.84)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:TpTrade2_V2()
    local targetPos = VectorUtil.newVector3(179.61, 66.62, 225.33)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:tp_flag1()
    local targetPos = VectorUtil.newVector3(-173.54, 67.62, -22.40)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:tp_flag2()
    local targetPos = VectorUtil.newVector3(60.40, 67.62, -52.78)
    setPosTest(targetPos)
    GUIGMControlPanel:hide()
end

function GMHelper:NoKnockBack(text)
    self.NoKnockbackEnabled = not self.NoKnockbackEnabled
    local lastPosition, lastHealth
    local timerHandle = self.NoKnockbackTimer

    if self.NoKnockbackEnabled then
        self.data.color = {0.8, 0.4, 0.0, 1}
        text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
        UIHelper.showToast("^00FF00Enabled")
        lastPosition, lastHealth = nil, nil

        self.NoKnockbackTimer = LuaTimer:scheduleTimer(function()
            local playerClient = PlayerManager:getClientPlayer()
            if not playerClient or not playerClient.Player then
                return
            end

            local player = playerClient.Player
            local currentHealth = player:getHealth()
            local currentPosition = player:getPosition()

            if lastHealth and currentHealth < lastHealth and lastPosition then
                player:setPosition(lastPosition)
            end

            lastHealth = currentHealth
            lastPosition = currentPosition
        end, 10, -1)

    else
        text:SetBackgroundColor({0, 0, 0, 0.8})
        self.data.color = Color.BLACK
        UIHelper.showToast("^FF0000Disabled")

        if timerHandle then
            LuaTimer:cancel(timerHandle)
            self.NoKnockbackTimer = nil
        end
        lastPosition, lastHealth = nil, nil
    end
end

function GMHelper:HitBox(text)
    
    self.HitBoxEnabled = not self.HitBoxEnabled
    _G["togHitBox"] = self.HitBoxEnabled
    refreshButtonColorSave("HitBox")

    if self.HitBoxEnabled then
        SaveItem("HitBox", "HitBox")
    end
A = not A
    local players = PlayerManager:getPlayers()
    local clientPlayer = PlayerManager:getClientPlayer()
    
    if A then
        text:SetBackgroundColor({0.8, 0.4, 0.0, 1})
        UIHelper.showToast("^00FF00Enabled")
        LuaTimer:cancel(HitBoxPerm)
        HitBoxPerm = LuaTimer:scheduleTimer(function()
            for _, player in ipairs(players) do
                local entity = player.Player
                if player ~= clientPlayer and clientPlayer.Player:getTeamId() ~= player:getTeamId() then
                    entity.height = 8
                    entity.width = 8
                    entity.length = 8
                end
            end
        end, 30, -1)
    else
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
        LuaTimer:cancel(HitBoxPerm)
        for _, player in ipairs(players) do
            local entity = player.Player
            if player ~= clientPlayer and clientPlayer.Player:getTeamId() ~= player:getTeamId() then
                entity.height = 1.8
                entity.width = 0.6
                entity.length = 0.6
            end
        end
    end
end

function GMHelper:WallHack(text)
    
    self.WallHackEnabled = not self.WallHackEnabled
    _G["togWallHack"] = self.WallHackEnabled
    refreshButtonColorSave("WallHack")

    if self.WallHackEnabled then
        SaveItem("WallHack", "WallHack")
    end
self._wallhackEnabled = not self._wallhackEnabled
    
    local color = self._wallhackEnabled and { 0.8, 0.4, 0.0, 1 } or Color.BLACK
    text:SetBackgroundColor(color)

if self._wallhackEnabled then
    UIHelper.showToast("^00FF00Enabled")
else
    UIHelper.showToast("^FF0000Disabled")
end

    local players = PlayerManager:getPlayers()
    local clientPlayer = PlayerManager:getClientPlayer()
    local wallhack = self._wallhackEnabled and 10 or 1
    
    for _, player in ipairs(players) do
        local entity = player.Player
        if player ~= clientPlayer then
            entity.height = WallHackSize
            entity.width = WallHackSize
            entity.length = WallHackSize
            entity.wallhackMultiplier = damageMultiplier
            entity.criticalGodChance = self._wallhackEnabled and 1.0 or 0.1
            entity.movementSpeed = self._wallhackEnabled and 0.1 or 1.0
            entity.visibility = self._wallhackEnabled and 2.0 or 1.0
            entity.headshot_modifier = self._wallhackEnabled and 5.0 or 1.0
        else
            entity.height = originalHeight
            entity.width = originalWidth
            entity.length = originalLength
            entity.wallhackMultiplier = 1
            entity.criticalGodChance = 0.1
            entity.movementSpeed = 1.5
            entity.visibility = 0.5
            entity.health_regen = self._wallhackEnabled and 50 or 1
            entity.infinite_ammo = self._wallhackEnabled
            entity.no_recoil = self._wallhackEnabled
        end
    end
    
    if self._wallhackEnabled then
        clientPlayer.Player.god_mode = true
        clientPlayer.Player.wall_hack = true
        clientPlayer.Player.auto_aim = true
        ClientHelper.putBoolPrefs("EnableDoubleJumps", true)
        player.doubleJumpCount = math.huge + 0
    else
        clientPlayer.Player.god_mode = false
        clientPlayer.Player.wall_hack = false
        clientPlayer.Player.auto_aim = false
        ClientHelper.putBoolPrefs("EnableDoubleJumps", false)
        player.doubleJumpCount = 1
    end
end

function GMHelper:CountEnemies()
    
    self.CountEnemiesEnabled = not self.CountEnemiesEnabled
    _G["togCountEnemies"] = self.CountEnemiesEnabled
    refreshButtonColorSave("CountEnemies")

    if self.CountEnemiesEnabled then
        SaveItem("CountEnemies", "CountEnemies")
    end
local me = PlayerManager:getClientPlayer()
    if not me or not me.Player then
        print("Error: Client player not found")
        return
    end

    local myTeamId = me:getTeamId()
    local players = PlayerManager:getPlayers()
    local enemyCount = 0

    for _, player in pairs(players) do
        if player ~= me and player.Player and player:getTeamId() ~= myTeamId then
            enemyCount = enemyCount + 1
        end
    end

    UIHelper.showCenterToast("^FF0000Enemies found: " .. enemyCount)
    return enemyCount
end

function GMHelper:AntiVoid(text)
    
    self.AntiVoidEnabled = not self.AntiVoidEnabled
    _G["togAntiVoid"] = self.AntiVoidEnabled
    refreshButtonColorUI("AntiVoid")

    if self.AntiVoidEnabled then
        createUIButton("AntiVoid", "AntiVoid")
    end
    antiVoidEnabled = not antiVoidEnabled

    if antiVoidEnabled then
        text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
        UIHelper.showToast("^00FF00Enabled")

        if not antiVoidTimer then
            void = LuaTimer:scheduleTimer(function()
                local clientPlayer = PlayerManager:getClientPlayer().Player
                local fallDistance = clientPlayer.fallDistance

                if not originalPos and fallDistance == 0 then
                    originalPos = clientPlayer:getPosition()
                elseif fallDistance >= 10 then
                    clientPlayer:setPosition(originalPos)
                    clientPlayer.fallDistance = 0
                    clientPlayer.noClip = true
                    LuaTimer:scheduleTimer(function()
                        clientPlayer.noClip = false
                    end, 50)
                end
            end, 100, -1)
        end
    else
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
        if void then
            LuaTimer:cancel(void)
            void = nil
        end
        originalPos = nil
    end
end

function GMHelper:Reach(text)
    
    self.ReachEnabled = not self.ReachEnabled
    _G["togReach"] = self.ReachEnabled
    refreshButtonColorSave("Reach")

    if self.ReachEnabled then
        SaveItem("Reach", "Reach")
    end
togReachDistance = not togReachDistance

    if togReachDistance then
        text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
        UIHelper.showToast("^00FF00Enabled")
        if not reachTimer then
            reachTimer = LuaTimer:scheduleTimer(function()
                togReachToggle = not togReachToggle

                if togReachToggle then
                    ClientHelper.putFloatPrefs("BlockReachDistance", 999)
                    ClientHelper.putFloatPrefs("EntityReachDistance", 10)
                else
                    ClientHelper.putFloatPrefs("BlockReachDistance", 4.5)
                    ClientHelper.putFloatPrefs("EntityReachDistance", 3)
                end
            end, 20, -1)
        end
    else
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
        if reachTimer then
            LuaTimer:cancel(reachTimer)
            reachTimer = nil
        end

        togReachToggle = false
        ClientHelper.putFloatPrefs("BlockReachDistance", 4.5)
        ClientHelper.putFloatPrefs("EntityReachDistance", 3)
    end
end

function GMHelper:WWE_Camera(text)

    self.WWE_CameraEnabled = not self.WWE_CameraEnabled
    _G["togWWE_Camera"] = self.WWE_CameraEnabled
    refreshButtonColorSave("WWE_Camera")

    if self.WWE_CameraEnabled then
        SaveItem("WWE_Camera", "WWE_Camera")
    end
A = not A
    ClientHelper.putBoolPrefs("IsSeparateCamera", true)
    text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
    UIHelper.showToast("^00FF00Enabled")
   if A then
     return
   end
    ClientHelper.putBoolPrefs("IsSeparateCamera", false)
    text:SetBackgroundColor({0, 0, 0, 0.8})
    UIHelper.showToast("^FF0000Disabled")
end

function GMHelper:BowSpeed(text)
	
    self.BowSpeedEnabled = not self.BowSpeedEnabled
    _G["togBowSpeed"] = self.BowSpeedEnabled
    refreshButtonColorSave("BowSpeed")

    if self.BowSpeedEnabled then
        SaveItem("BowSpeed", "BowSpeed")
    end
ClientHelper.putFloatPrefs("BowPullingSpeedMultiplier", 1000)
	ClientHelper.putFloatPrefs("BowPullingFOVMultiplier", 0)
	text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
	UIHelper.showToast("^00FF00Enabled")
	GUIGMControlPanel:hide()
end

function GMHelper:BanClickCD(text)
   
    self.BanClickCDEnabled = not self.BanClickCDEnabled
    _G["togBanClickCD"] = self.BanClickCDEnabled
    refreshButtonColorSave("BanClickCD")

    if self.BanClickCDEnabled then
        SaveItem("BanClickCD", "BanClickCD")
    end
A = not A
    ClientHelper.putBoolPrefs("banClickCD", true)
    text:SetBackgroundColor({0, 0, 0, 0.8})
    UIHelper.showToast("^FF0000Disabled")
   if A then
     return
   end
    ClientHelper.putBoolPrefs("banClickCD", false)
	text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
	UIHelper.showToast("^00FF00Enabled")
end

function GMHelper:RunFile()
    
    self.RunFileEnabled = not self.RunFileEnabled
    _G["togRunFile"] = self.RunFileEnabled
    refreshButtonColorSave("RunFile")

    if self.RunFileEnabled then
        SaveItem("RunFile", "RunFile")
    end
local file_path = "/storage/emulated/0/Android/data/com.sandboxol.blockymods.official/Runcode.lua/"
    local file, error = io.open(file_path, "r")
    if file then
        local content = file:read("*a")
        file:close()
        local func, error = load(content)
        if func then
            pcall(func)
        end
    end
end

function GMHelper:Speed(text)
    
    self.SpeedEnabled = not self.SpeedEnabled
    _G["togSpeed"] = self.SpeedEnabled
    refreshButtonColorSave("Speed")

    if self.SpeedEnabled then
        SaveItem("Speed", "Speed")
    end
self._speedEnabled = not self._speedEnabled

    local speedLevel = self._speedEnabled and 15000 or 7
    local backgroundColor = self._speedEnabled and { 0.8, 0.4, 0.0, 1 } or Color.BLACK

    PlayerManager:getClientPlayer().Player:setSpeedAdditionLevel(speedLevel)
    text:SetBackgroundColor(backgroundColor)

    if self._speedEnabled then
        UIHelper.showToast("^00FF00Enabled")
    else
        UIHelper.showToast("^FF0000Disabled")
    end
end

-- Enhanced Attack Button System
local AtkBtnSystem = {
    -- State variables
    togAtkBtn = false,
    atkBtnInitialized = false,
    eventHandlers = {},
    isBreaking = false,
    unHungryEnabled = false,
    timers = {},
    
    -- Constants
    CONSTANTS = {
        BUTTON_NAME = "Main-Gun-Operate-RightShootBtn",
        THROWPOT_NAME = "Main-throwpot-Controls",
        MAIN_LAYOUT = "Main",
        BOW_OPERATE = "Main-BedWar-BowShoot-Operate",
        CROSSHAIRS = "Main-BedWar-BowShoot-CrossHairs",
        
        -- Position and size
        BUTTON_X = {1, -355},
        BUTTON_Y = {0, 400},
        BUTTON_WIDTH = {0, 120},
        BUTTON_HEIGHT = {0, 120},
        
        THROWPOT_X = {0, 0},
        THROWPOT_Y = {0, -170},
        
        -- Colors
        ACTIVE_COLOR = {0.8, 0.4, 0.0, 1},
        INACTIVE_COLOR = Color.BLACK,
        
        -- Settings
        HUNGER_TIMER_INTERVAL = 1000,
        BREAK_DISTANCE = 999,
        NORMAL_DISTANCE = 6,
        BREAK_SPEED = 10,
        NORMAL_SPEED = 1,
        MAX_HUNGER = 20,
        MAX_SATURATION = 20
    }
}

-- Initialize HostApi settings and event callbacks
function AtkBtnSystem:initializeHostSettings()
    pcall(function()
        HostApi.setNeedFoodStats(false)
        HostApi.setFoodHeal(false) 
        HostApi.setSneakShowName(true)
    end)
    
    self:registerCoreEvents()
end

-- Register core game events
function AtkBtnSystem:registerCoreEvents()
    local events = {
        {CEvents.BlockBreakWithMetaEvent, self.onPlayerAIBreakBlock},
        {CEvents.PlayerPlaceBlockEvent, self.onBlockPlace},
        {CEvents.BlockTNTExplodeEvent, self.onBlockTNTExplode},
        {CEvents.BlockTNTExplodeBreakBlockEvent, self.onBlockTNTExplodeBreakBlockEnd},
        {CEvents.SchemeticPlaceBlockEvent, self.onSchemeticPlaceBlock},
        {CEvents.BlockStationaryNotStationaryEvent, self.onBlockStationaryNotStationary},
        {CEvents.BlockTNTExplodeHurtEntityEvent, self.onBlockTNTExplodeHurtEntity},
        {CEvents.ItemPickaxeCanHarvestEvent, self.onItemPickaxeCanHarvest},
        {CEvents.PlayerPlaceBlockBoxJudgeEvent, self.onPlayerPlaceBlockBoxJudge},
        {CEvents.SchemeticPlaceCoverEvent, self.onSchemeticPlaceCoverEvent},
        {CEvents.BlockChangeEvent, self.onBlockChange},
        {Events.PlayerPlaceBlockByLuaEvent, self.onPlayerPlaceBlockByLua}
    }
    
    for _, eventData in ipairs(events) do
        local event, callback = eventData[1], eventData[2]
        pcall(function()
            if event and callback then
                event:registerCallBack(callback)
            end
        end)
    end
end

-- Event callback functions (placeholders - implement as needed)
function AtkBtnSystem:onPlayerAIBreakBlock(...)
    -- Handle AI block breaking
end

function AtkBtnSystem:onBlockPlace(...)
    -- Handle block placement
end

function AtkBtnSystem:onBlockTNTExplode(...)
    -- Handle TNT explosion
end

function AtkBtnSystem:onBlockTNTExplodeBreakBlockEnd(...)
    -- Handle TNT explosion block breaking end
end

function AtkBtnSystem:onSchemeticPlaceBlock(...)
    -- Handle schematic block placement
end

function AtkBtnSystem:onBlockStationaryNotStationary(...)
    -- Handle block stationary state changes
end

function AtkBtnSystem:onBlockTNTExplodeHurtEntity(...)
    -- Handle TNT explosion entity damage
end

function AtkBtnSystem:onItemPickaxeCanHarvest(...)
    -- Handle pickaxe harvest check
end

function AtkBtnSystem:onPlayerPlaceBlockBoxJudge(...)
    -- Handle block placement box judgment
end

function AtkBtnSystem:onSchemeticPlaceCoverEvent(...)
    -- Handle schematic cover placement
end

function AtkBtnSystem:onBlockChange(...)
    -- Handle block changes
end

function AtkBtnSystem:onPlayerPlaceBlockByLua(...)
    -- Handle Lua-based block placement
end

-- Main toggle function
function AtkBtnSystem:toggle(text)
    self.togAtkBtn = not self.togAtkBtn
    
    if self.togAtkBtn then
        self:enable(text)
    else
        self:disable(text)
    end
    
    return self.togAtkBtn
end

-- Enable attack button system
function AtkBtnSystem:enable(text)
    local success, error = pcall(function()
        self:initializeHostSettings()
        
        local AtkBtn = self:getButton()
        if not AtkBtn then
            self:showError("Attack button not found!", text)
            return false
        end
        
        self:setupThrowpotControls()
        self:configureButton(AtkBtn)
        
        if not self.atkBtnInitialized then
            self:setupEventHandlers(AtkBtn, text)
            self.atkBtnInitialized = true
        end
        
        self:enableUnHungry()
        self:updateButtonAppearance(text, true)
        self:showSuccess("Attack button enabled with enhanced features")
        
        return true
    end)
    
    if not success then
        self:showError("Failed to enable attack button: " .. tostring(error), text)
        self.togAtkBtn = false
    end
end

-- Disable attack button system
function AtkBtnSystem:disable(text)
    pcall(function()
        local AtkBtn = self:getButton()
        if AtkBtn then
            AtkBtn:SetVisible(false)
            self:disableCollimatorMode()
        end
        
        self:hideThrowpotControls()
        self:disableUnHungry()
        self:updateButtonAppearance(text, false)
        self:showSuccess("Attack button disabled")
    end)
end

-- Get attack button reference
function AtkBtnSystem:getButton()
    return GUIManager:getWindowByName(self.CONSTANTS.BUTTON_NAME)
end

-- Setup throwpot controls
function AtkBtnSystem:setupThrowpotControls()
    local throwpotControls = GUIManager:getWindowByName(self.CONSTANTS.THROWPOT_NAME)
    if throwpotControls then
        throwpotControls:SetVisible(true)
        throwpotControls:SetXPosition(self.CONSTANTS.THROWPOT_X)
        throwpotControls:SetYPosition(self.CONSTANTS.THROWPOT_Y)
    end
end

-- Hide throwpot controls
function AtkBtnSystem:hideThrowpotControls()
    local throwpotControls = GUIManager:getWindowByName(self.CONSTANTS.THROWPOT_NAME)
    if throwpotControls then
        throwpotControls:SetVisible(false)
    end
end

-- Configure attack button properties
function AtkBtnSystem:configureButton(AtkBtn)
    if not AtkBtn then return end
    
    pcall(function()
        AtkBtn:SetVisible(true)
        AtkBtn:SetAlwaysOnTop(true)
        AtkBtn:SetLevel(1)
        
        local mainLayout = GUIManager:getWindowByName(self.CONSTANTS.MAIN_LAYOUT)
        if mainLayout then
            mainLayout:AddChildWindow(AtkBtn)
        end
        
        -- Set position and size
        AtkBtn:SetXPosition(self.CONSTANTS.BUTTON_X)
        AtkBtn:SetYPosition(self.CONSTANTS.BUTTON_Y)
        AtkBtn:SetWidth(self.CONSTANTS.BUTTON_WIDTH)
        AtkBtn:SetHeight(self.CONSTANTS.BUTTON_HEIGHT)
        
        -- Set button images
        AtkBtn:SetProperty("NormalImage", "set:main_btn.json image:skill_btn")
        AtkBtn:SetProperty("PushedImage", "set:main_btn.json image:skill_btn_pressed")
        AtkBtn:SetProperty("HoverImage", "set:main_btn.json image:skill_btn_hover")
        
        -- Enable special features
        AtkBtn:setEnableLongTouch(true)
        AtkBtn:SetProperty("WantsMultiClickEvents", "True")
        AtkBtn:SetProperty("EnableBlockBreaking", "True")
    end)
end

-- Setup comprehensive event handlers
function AtkBtnSystem:setupEventHandlers(AtkBtn, text)
    if not AtkBtn then return end
    
    self:clearEventHandlers(AtkBtn)
    
    -- Enable events (start breaking/attacking)
    local enableEvents = {
        GUIEvent.DragStart,
        GUIEvent.LongTouchStart,
        GUIEvent.ButtonClick,
        GUIEvent.TouchMove,
        GUIEvent.MouseButtonDown
    }
    
    -- Disable events (stop breaking/attacking)
    local disableEvents = {
        GUIEvent.LongTouchEnd,
        GUIEvent.Release,
        GUIEvent.TouchUp,
        GUIEvent.MouseButtonUp
    }
    
    -- Register enable events
    for _, event in ipairs(enableEvents) do
        local handler = function() 
            self:enableCombatMode(text)
        end
        self:registerEvent(AtkBtn, event, handler)
    end
    
    -- Register disable events
    for _, event in ipairs(disableEvents) do
        local handler = function() 
            self:disableCombatMode(text)
        end
        self:registerEvent(AtkBtn, event, handler)
    end
    
    -- Register block interaction events
    self:registerBlockEvents(AtkBtn)
end

-- Register a single event handler
function AtkBtnSystem:registerEvent(button, event, handler)
    pcall(function()
        button:registerEvent(event, handler)
        table.insert(self.eventHandlers, {
            button = button, 
            event = event, 
            handler = handler
        })
    end)
end

-- Register block-related events
function AtkBtnSystem:registerBlockEvents(AtkBtn)
    -- Block break event
    if CEvent and CEvent.BlockBreak then
        local blockBreakHandler = function(pos, blockID)
            if pos and blockID then
                self:handleBlockBreak(pos, blockID)
            end
        end
        self:registerEvent(AtkBtn, CEvent.BlockBreak, blockBreakHandler)
    end
    
    -- Block touch event
    if CEvent and CEvent.BlockTouch then
        local blockTouchHandler = function(pos, blockID)
            if pos and blockID then
                self:handleBlockTouch(pos, blockID)
            end
        end
        self:registerEvent(AtkBtn, CEvent.BlockTouch, blockTouchHandler)
    end
end

-- Enable combat mode (collimator + block breaking)
function AtkBtnSystem:enableCombatMode(text)
    self:enableCollimatorMode(text)
    self:enableBlockBreaking()
end

-- Disable combat mode
function AtkBtnSystem:disableCombatMode(text)
    self:disableCollimatorMode(text)
    self:disableBlockBreaking()
end

-- Enable block breaking with enhanced settings
function AtkBtnSystem:enableBlockBreaking()
    if self.isBreaking then return end
    
    self.isBreaking = true
    
    pcall(function()
        -- Set client preferences
        ClientHelper.putFloatPrefs("BlockBreakDistance", self.CONSTANTS.BREAK_DISTANCE)
        ClientHelper.putBoolPrefs("BlockBreakEnabled", true)
        ClientHelper.putIntPrefs("BlockBreakSpeed", self.CONSTANTS.BREAK_SPEED)
        
        -- Configure player properties
        local clientWrapper = PlayerManager:getClientPlayer()
        if clientWrapper and clientWrapper.Player then
            local player = clientWrapper.Player
            player:setFloatProperty("BlockBreakDistance", self.CONSTANTS.BREAK_DISTANCE)
            player:setBoolProperty("InfiniteBlockBreak", true)
            player:setIntProperty("BlockBreakSpeed", self.CONSTANTS.BREAK_SPEED)
        end
        
        self:showInfo("Block breaking enabled")
    end)
end

-- Disable block breaking
function AtkBtnSystem:disableBlockBreaking()
    if not self.isBreaking then return end
    
    self.isBreaking = false
    
    pcall(function()
        -- Reset client preferences
        ClientHelper.putFloatPrefs("BlockBreakDistance", self.CONSTANTS.NORMAL_DISTANCE)
        ClientHelper.putBoolPrefs("BlockBreakEnabled", false)
        ClientHelper.putIntPrefs("BlockBreakSpeed", self.CONSTANTS.NORMAL_SPEED)
        
        -- Reset player properties
        local clientWrapper = PlayerManager:getClientPlayer()
        if clientWrapper and clientWrapper.Player then
            local player = clientWrapper.Player
            player:setFloatProperty("BlockBreakDistance", self.CONSTANTS.NORMAL_DISTANCE)
            player:setBoolProperty("InfiniteBlockBreak", false)
            player:setIntProperty("BlockBreakSpeed", self.CONSTANTS.NORMAL_SPEED)
        end
    end)
end

-- Handle block touch interactions
function AtkBtnSystem:handleBlockTouch(pos, blockID)
    if not self.isBreaking or not pos or not blockID then return end
    
    pcall(function()
        local clientWrapper = PlayerManager:getClientPlayer()
        if not (clientWrapper and clientWrapper.Player) then return end
        
        local player = clientWrapper.Player
        
        -- Try multiple block breaking methods
        if EngineWorld then
            if EngineWorld.setBlockId then
                EngineWorld:setBlockId(pos, BlockID.AIR)
            end
            if EngineWorld.breakBlock then
                EngineWorld:breakBlock(pos)
            end
            if EngineWorld.destroyBlock then
                EngineWorld:destroyBlock(pos, true)
            end
        end
        
        -- Player-based breaking methods
        if player.breakBlock then
            player:breakBlock(pos)
        elseif player.destroyBlock then
            player:destroyBlock(pos)
        end
        
        self:showInfo("Breaking block at: " .. tostring(pos))
    end)
end

-- Handle successful block breaks
function AtkBtnSystem:handleBlockBreak(pos, blockID)
    if not pos or not blockID then return end
    
    pcall(function()
        self:showSuccess("Block broken: ID " .. tostring(blockID))
        
        -- Optional: Add items to inventory
        local clientWrapper = PlayerManager:getClientPlayer()
        if clientWrapper and clientWrapper.Player then
            local player = clientWrapper.Player
            if player.addItem then
                -- Add specific items based on block type or add all items
                for id = 1, 6999 do
                    player:addItem(id, 1)
                end
            end
        end
    end)
end

-- Enhanced UnHungry system
function AtkBtnSystem:enableUnHungry()
    if self.unHungryEnabled then return end
    
    self.unHungryEnabled = true
    
    -- Create persistent hunger timer
    local timerId = LuaTimer:scheduleTimer(function()
        if not self.unHungryEnabled then return end
        
        pcall(function()
            local clientWrapper = PlayerManager:getClientPlayer()
            if not (clientWrapper and clientWrapper.Player) then return end
            
            local player = clientWrapper.Player
            
            -- Set hunger/food levels
            if player.setHunger then
                player:setHunger(self.CONSTANTS.MAX_HUNGER)
            elseif player.setFood then
                player:setFood(self.CONSTANTS.MAX_HUNGER)
            elseif player.setFoodLevel then
                player:setFoodLevel(self.CONSTANTS.MAX_HUNGER)
            end
            
            -- Set saturation
            if player.setSaturation then
                player:setSaturation(self.CONSTANTS.MAX_SATURATION)
            end
            
            -- Update client preferences
            ClientHelper.putFloatPrefs("PlayerHunger", self.CONSTANTS.MAX_HUNGER)
            ClientHelper.putFloatPrefs("PlayerSaturation", self.CONSTANTS.MAX_SATURATION)
            ClientHelper.putBoolPrefs("UnlimitedHunger", true)
            
            -- Set player properties
            player:setFloatProperty("Hunger", self.CONSTANTS.MAX_HUNGER)
            player:setFloatProperty("Saturation", self.CONSTANTS.MAX_SATURATION)
            player:setBoolProperty("InfiniteHunger", true)
        end)
    end, self.CONSTANTS.HUNGER_TIMER_INTERVAL, -1)
    
    -- Store timer ID for cleanup
    table.insert(self.timers, timerId)
    self:showSuccess("UnHungry system enabled")
end

-- Disable UnHungry system
function AtkBtnSystem:disableUnHungry()
    if not self.unHungryEnabled then return end
    
    self.unHungryEnabled = false
    
    pcall(function()
        -- Reset client preferences
        ClientHelper.putBoolPrefs("UnlimitedHunger", false)
        
        -- Reset player properties
        local clientWrapper = PlayerManager:getClientPlayer()
        if clientWrapper and clientWrapper.Player then
            local player = clientWrapper.Player
            player:setBoolProperty("InfiniteHunger", false)
        end
        
        -- Clear timers
        for _, timerId in ipairs(self.timers) do
            pcall(function()
                LuaTimer:clearTimer(timerId)
            end)
        end
        self.timers = {}
        
        self:showSuccess("UnHungry system disabled")
    end)
end

-- Enable collimator mode with crosshairs
function AtkBtnSystem:enableCollimatorMode(text)
    pcall(function()
        local gameSettings = Blockman.Instance().m_gameSettings
        if gameSettings then
            gameSettings:setCollimatorMode(true)
        end
        
        -- Show aiming UI elements
        local bowOperate = GUIManager:getWindowByName(self.CONSTANTS.BOW_OPERATE)
        local crosshairs = GUIManager:getWindowByName(self.CONSTANTS.CROSSHAIRS)
        
        if bowOperate then bowOperate:SetVisible(true) end
        if crosshairs then crosshairs:SetVisible(true) end
        
        -- Update button appearance
        if text then
            text:SetBackgroundColor(self.CONSTANTS.ACTIVE_COLOR)
        end
        
        -- Simulate touch click for game interaction
        local gameInstance = CGame.Instance()
        if gameInstance and gameInstance.handleTouchClick then
            gameInstance:handleTouchClick(1, 1)
        end
    end)
end

-- Disable collimator mode
function AtkBtnSystem:disableCollimatorMode(text)
    pcall(function()
        local gameSettings = Blockman.Instance().m_gameSettings
        if gameSettings then
            gameSettings:setCollimatorMode(false)
        end
        
        -- Hide aiming UI elements
        local bowOperate = GUIManager:getWindowByName(self.CONSTANTS.BOW_OPERATE)
        local crosshairs = GUIManager:getWindowByName(self.CONSTANTS.CROSSHAIRS)
        
        if bowOperate then bowOperate:SetVisible(false) end
        if crosshairs then crosshairs:SetVisible(false) end
        
        -- Update button appearance
        if text then
            text:SetBackgroundColor(self.CONSTANTS.INACTIVE_COLOR)
        end
    end)
end

-- Clear all event handlers
function AtkBtnSystem:clearEventHandlers(AtkBtn)
    for _, handlerInfo in ipairs(self.eventHandlers) do
        if handlerInfo.button == AtkBtn then
            pcall(function()
                handlerInfo.button:unregisterEvent(handlerInfo.event, handlerInfo.handler)
            end)
        end
    end
    self.eventHandlers = {}
end

-- Update button visual appearance
function AtkBtnSystem:updateButtonAppearance(text, isActive)
    if text then
        text:SetBackgroundColor(isActive and self.CONSTANTS.ACTIVE_COLOR or self.CONSTANTS.INACTIVE_COLOR)
    end
end

-- Complete system cleanup
function AtkBtnSystem:cleanup()
    pcall(function()
        local AtkBtn = self:getButton()
        if AtkBtn then
            self:clearEventHandlers(AtkBtn)
            AtkBtn:SetVisible(false)
        end
        
        self:disableBlockBreaking()
        self:disableUnHungry()
        self:hideThrowpotControls()
        
        self.atkBtnInitialized = false
        self.togAtkBtn = false
        
        self:showSuccess("Attack button system cleanup completed")
    end)
end

-- Utility functions for user feedback
function AtkBtnSystem:showSuccess(message)
    if UIHelper and UIHelper.showToast then
        UIHelper.showToast("✓ " .. message)
    end
end

function AtkBtnSystem:showError(message, text)
    if UIHelper and UIHelper.showToast then
        UIHelper.showToast("✗ " .. message)
    end
    if text then
        text:SetBackgroundColor(self.CONSTANTS.INACTIVE_COLOR)
    end
    self.togAtkBtn = false
end

function AtkBtnSystem:showInfo(message)
    if UIHelper and UIHelper.showToast then
        UIHelper.showToast("ℹ " .. message)
    end
end

-- Integration with GMHelper
function GMHelper:AtkBtn(text)
    
    self.AtkBtnEnabled = not self.AtkBtnEnabled
    _G["togAtkBtn"] = self.AtkBtnEnabled
    refreshButtonColorSave("AtkBtn")

    if self.AtkBtnEnabled then
        SaveItem("AtkBtn", "AtkBtn")
    end
return AtkBtnSystem:toggle(text)
end

function GMHelper:cleanupAtkBtn()
    
    self.cleanupAtkBtnEnabled = not self.cleanupAtkBtnEnabled
    _G["togcleanupAtkBtn"] = self.cleanupAtkBtnEnabled
    refreshButtonColorSave("cleanupAtkBtn")

    if self.cleanupAtkBtnEnabled then
        SaveItem("cleanupAtkBtn", "cleanupAtkBtn")
    end
return AtkBtnSystem:cleanup()
end

-- Additional helper methods
function GMHelper:isAtkBtnEnabled()
    
    self.isAtkBtnEnabledEnabled = not self.isAtkBtnEnabledEnabled
    _G["togisAtkBtnEnabled"] = self.isAtkBtnEnabledEnabled
    refreshButtonColorSave("isAtkBtnEnabled")

    if self.isAtkBtnEnabledEnabled then
        SaveItem("isAtkBtnEnabled", "isAtkBtnEnabled")
    end
return AtkBtnSystem.togAtkBtn
end

function GMHelper:forceDisableAtkBtn(text)
    
    self.forceDisableAtkBtnEnabled = not self.forceDisableAtkBtnEnabled
    _G["togforceDisableAtkBtn"] = self.forceDisableAtkBtnEnabled
    refreshButtonColorSave("forceDisableAtkBtn")

    if self.forceDisableAtkBtnEnabled then
        SaveItem("forceDisableAtkBtn", "forceDisableAtkBtn")
    end
if AtkBtnSystem.togAtkBtn then
        AtkBtnSystem:disable(text)
        AtkBtnSystem.togAtkBtn = false
    end
end

function GMHelper:getAtkBtnStatus()
    
    self.getAtkBtnStatusEnabled = not self.getAtkBtnStatusEnabled
    _G["toggetAtkBtnStatus"] = self.getAtkBtnStatusEnabled
    refreshButtonColorSave("getAtkBtnStatus")

    if self.getAtkBtnStatusEnabled then
        SaveItem("getAtkBtnStatus", "getAtkBtnStatus")
    end
return {
        enabled = AtkBtnSystem.togAtkBtn,
        initialized = AtkBtnSystem.atkBtnInitialized,
        breaking = AtkBtnSystem.isBreaking,
        unHungry = AtkBtnSystem.unHungryEnabled
    }
end

local espEnabled = false
local processedPlayers = {}

local predefinedColors = {
    {1, 0, 0, 1},
    {0, 1, 0, 1},
    {0, 0, 1, 1},
    {1, 1, 0, 1},
    {1, 0, 1, 1},
    {0, 1, 1, 1},
    {0.5, 0.5, 0.5, 1},
    {1, 0.5, 0, 1},
    {0.5, 0, 0.5, 1},
    {0, 0.5, 0.5, 1},
    {0.7, 0.2, 0.2, 1},
    {0.2, 0.7, 0.2, 1},
    {0.2, 0.2, 0.7, 1},
    {0.8, 0.6, 0.1, 1},
    {0.6, 0.1, 0.8, 1},
    {0.3, 0.8, 0.5, 1},
}

local colorIndex = 1

function GMHelper:EspMode(text)
    
    self.EspModeEnabled = not self.EspModeEnabled
    _G["togEspMode"] = self.EspModeEnabled
    refreshButtonColorSave("EspMode")

    if self.EspModeEnabled then
        SaveItem("EspMode", "EspMode")
    end
LuaTimer:scheduleTimer(function()
        if espEnabled then
            local updatedHoomans = PlayerManager:getPlayers()
            local myclient = PlayerManager:getClientPlayer()
            for _, nubs in pairs(updatedHoomans) do
                if nubs.userId ~= myclient.userId and nubs.Player and not processedPlayers[nubs.userId] then
                    local color = predefinedColors[colorIndex]
                    nubs.Player:enableXRay(color)
                    processedPlayers[nubs.userId] = true
                    colorIndex = (colorIndex % #predefinedColors) + 1
                end
            end
        end
    end, 5)

    espEnabled = not espEnabled

    if espEnabled then
        text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
        UIHelper.showToast("^00FF00Enabled")
        local myclient = PlayerManager:getClientPlayer()
        local hoomans = PlayerManager:getPlayers()
        for _, nubs in pairs(hoomans) do
            if nubs.userId ~= myclient.userId and nubs.Player and not processedPlayers[nubs.userId] then
                local color = predefinedColors[colorIndex]
                nubs.Player:enableXRay(color)
                processedPlayers[nubs.userId] = true
                colorIndex = (colorIndex % #predefinedColors) + 1
            end
        end
    else
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
        local hoomans = PlayerManager:getPlayers()
        for _, nubs in pairs(hoomans) do
            if nubs.Player then
                nubs.Player:disableXRay()
            end
        end
        processedPlayers = {}
        colorIndex = 1
    end
end

function GMHelper:DmgInc(text)
    
    self.DmgIncEnabled = not self.DmgIncEnabled
    _G["togDmgInc"] = self.DmgIncEnabled
    refreshButtonColorSave("DmgInc")

    if self.DmgIncEnabled then
        SaveItem("DmgInc", "DmgInc")
    end
if self.dmgIncEnabled == false then
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
        return
    end

    local playerHealthData = {}

    local function updateHealth(entityId, health)
        for i, v in ipairs(playerHealthData) do
            if v.entityId == entityId then
                v.hp = health
                return
            end
        end
        table.insert(playerHealthData, {entityId = entityId, hp = health})
    end

    CEvents.PlayerLoginEvent:registerCallBack(function(userId)
        local player = PlayerManager:getPlayerByUserId(userId)
        if player and player ~= PlayerManager:getClientPlayer() then
            updateHealth(player.entityId, player:getHealth())
        end
    end)

    CEvents.EntityHealthChangeEvent:registerCallBack(function(entityId, health)
        LuaTimer:schedule(function()
            if PlayerManager:getPlayerByEntityId(entityId) then
                updateHealth(entityId, health)
            end
        end, 1000)
    end)

    CEvents.AttackEntityEvent:registerCallBack(function(entityId)
        local target = PlayerManager:getPlayerByEntityId(entityId)
        if not target then return end

        for _, v in ipairs(playerHealthData) do
            if v.entityId == entityId then
                local newHealth = target:getHealth()
                local dmg = v.hp - newHealth
                if dmg > 0 then
                    local flooredDmg = math.floor(dmg + 0.5)
                    local scale = 0.9
                    local offset = {x = 0, y = 1, z = 0}
                    local pos = target:getPosition()
                    local displayPos = {
                        x = pos.x + offset.x,
                        y = pos.y + offset.y,
                        z = pos.z + offset.z
                    }
                    WorldImageRender.Instance():addFloatNumber("number_" .. flooredDmg, displayPos, scale, 1)
                end
                break
            end
        end
    end)

    for _, p in pairs(PlayerManager:getPlayers()) do
        if p ~= PlayerManager:getClientPlayer() then
            updateHealth(p.entityId, p:getHealth())
        end
    end
    UIHelper.showToast("^00FF00Enabled")
    text:SetBackgroundColor({0.8, 0.4, 0.0, 1})
end

function GMHelper:InitESP()
    
    self.InitESPEnabled = not self.InitESPEnabled
    _G["togInitESP"] = self.InitESPEnabled
    refreshButtonColorSave("InitESP")

    if self.InitESPEnabled then
        SaveItem("InitESP", "InitESP")
    end
self.ESPEnabled = false
    self.ESPBoxes = {}
    self.ESPTimer = nil
    self.ESPRefreshInterval = 100
    self.ESPColorEnemy = {1, 0, 0, 0.8}
end

function GMHelper:GetOrCreateESPBox(player)
    
    self.GetOrCreateESPBoxEnabled = not self.GetOrCreateESPBoxEnabled
    _G["togGetOrCreateESPBox"] = self.GetOrCreateESPBoxEnabled
    refreshButtonColorSave("GetOrCreateESPBox")

    if self.GetOrCreateESPBoxEnabled then
        SaveItem("GetOrCreateESPBox", "GetOrCreateESPBox")
    end
local playerId = player:getId()
    if self.ESPBoxes[playerId] then
        return self.ESPBoxes[playerId]
    end

    local box = UIHelper:createPanel()
    box:SetSize(50, 100)
    box:SetBackgroundColor({0, 0, 0, 0.3})
    box:SetBorderColor(self.ESPColorEnemy)
    box:SetVisible(false)

    local nameText = UIHelper:createText(box)
    nameText:SetFontSize(14)
    nameText:SetText(player:getName() or "Unknown")
    nameText:SetPosition(0, -20)
    box.NameText = nameText

    self.ESPBoxes[playerId] = box
    return box
end

function GMHelper:WorldToScreen(pos)
    
    self.WorldToScreenEnabled = not self.WorldToScreenEnabled
    _G["togWorldToScreen"] = self.WorldToScreenEnabled
    refreshButtonColorSave("WorldToScreen")

    if self.WorldToScreenEnabled then
        SaveItem("WorldToScreen", "WorldToScreen")
    end
local cam = CGame.Instance():getMainCamera()
    if not cam or not pos then return nil, nil, false end
    local x, y, visible = cam:worldToScreen(pos.x, pos.y, pos.z)
    return x, y, visible
end

function GMHelper:UpdateESP()
    
    self.UpdateESPEnabled = not self.UpdateESPEnabled
    _G["togUpdateESP"] = self.UpdateESPEnabled
    refreshButtonColorSave("UpdateESP")

    if self.UpdateESPEnabled then
        SaveItem("UpdateESP", "UpdateESP")
    end
if not self.ESPEnabled then
        for _, box in pairs(self.ESPBoxes) do
            box:SetVisible(false)
        end
        return
    end

    local me = PlayerManager:getClientPlayer()
    if not me or not me.Player then return end

    local players = PlayerManager:getPlayers()
    for _, player in pairs(players) do
        if player ~= me and player.Player then
            local pos = player.Player:getPosition()
            local screenX, screenY, onScreen = self:WorldToScreen(pos)
            if onScreen and screenX and screenY then
                local box = self:GetOrCreateESPBox(player)
                box:SetVisible(true)
                box:SetPosition(screenX - 25, screenY - 100)
                box.NameText:SetText(player:getName() or "Unknown")
            else
                local box = self.ESPBoxes[player:getId()]
                if box then
                    box:SetVisible(false)
                end
            end
        end
    end
end

function GMHelper:ToggleESP(buttonText)
    
    self.ToggleESPEnabled = not self.ToggleESPEnabled
    _G["togToggleESP"] = self.ToggleESPEnabled
    refreshButtonColorSave("ToggleESP")

    if self.ToggleESPEnabled then
        SaveItem("ToggleESP", "ToggleESP")
    end
self.ESPEnabled = not self.ESPEnabled
    if self.ESPEnabled then
        buttonText:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
        UIHelper.showToast("^00FF00Enabled")
        if self.ESPTimer then
            LuaTimer:cancel(self.ESPTimer)
        end
        self.ESPTimer = LuaTimer:scheduleTimer(function()
            self:UpdateESP()
        end, self.ESPRefreshInterval, -1)
    else
        buttonText:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
        if self.ESPTimer then
            LuaTimer:cancel(self.ESPTimer)
            self.ESPTimer = nil
        end
        for _, box in pairs(self.ESPBoxes) do
            box:SetVisible(false)
        end
    end
end

function GMHelper:HidePanel(text)
    
    self.HidePanelEnabled = not self.HidePanelEnabled
    _G["togHidePanel"] = self.HidePanelEnabled
    refreshButtonColorSave("HidePanel")

    if self.HidePanelEnabled then
        SaveItem("HidePanel", "HidePanel")
    end
A = not A
    
    if A then
        text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
        UIHelper.showToast("^00FF00Enabled")
        GUIManager:getWindowByName("GUIRoot-xuy60"):SetVisible(false)
        GUIManager:getWindowByName("GMMain-Open"):SetAlpha(0)
    else
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
        GUIManager:getWindowByName("GUIRoot-xuy60"):SetVisible(true)
        GUIManager:getWindowByName("GMMain-Open"):SetAlpha(1)
    end
end

function GMHelper:MovablePanel(text)
    
    self.MovablePanelEnabled = not self.MovablePanelEnabled
    _G["togMovablePanel"] = self.MovablePanelEnabled
    refreshButtonColorSave("MovablePanel")

    if self.MovablePanelEnabled then
        SaveItem("MovablePanel", "MovablePanel")
    end
CenterToastg2 = GUIManager:getWindowByName("GMMain-Open")
    togmoving = not togmoving
    if togmoving then
        local mainLayout = GUIManager:getWindowByName("Main")
        if mainLayout then
            mainLayout:AddChildWindow(CenterToastg2)
        end
        CenterToastg2:SetHorizontalAlignment(HorizontalAlignment.Center)
        CenterToastg2:SetWidth({ 0, 64 }) 
        CenterToastg2:SetHeight({ 0, 64 })   
        CenterToastg2:SetVerticalAlignment(VerticalAlignment.Center)
  
        CenterToastg2:SetTouchable(true)
        
        GUISystem.Instance():GetRootWindow():AddChildWindow(CenterToastg2)
        
        GUISystem.Instance():GetRootWindow():AddChildWindow(CenterToastg2)
        text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
        UIHelper.showToast("^00FF00Enabled")
        CenterToastg2:SetVisible(true)
        CenterToastg2:SetYPosition({0, -273})
        CenterToastg2:SetXPosition({0, 0})
        local move = function(w)
            timer.cipka = LuaTimer:scheduleTimer(function()
                if not Blockman.Instance().m_gameSettings:isMouseMoving() then
                    local mousePos = Blockman.Instance().m_gameSettings:getMousePos()
                    CenterToastg2:SetXPosition({0, mousePos.x / 2.3 - 390})
                    CenterToastg2:SetYPosition({0, mousePos.y / 2.3 - 305})
                end
            end, 5, 250)
        end
        CenterToastg2:registerEvent(GUIEvent.TouchMove, move)
        
        
        CenterToastg2:registerEvent(GUIEvent.ButtonClick, function()
            isTest = true
            GUIGMControlPanel:show()
            LuaTimer:scheduleTimer(function() end, 5, 100)
            isTest = false
        end)
    else
        if CenterToastg2 then
            text:SetBackgroundColor({0, 0, 0, 0.8})
            UIHelper.showToast("^FF0000Disabled")
            CenterToastg2:SetTouchable(true)
            CenterToastg2:SetWidth({ 0, 50 })
            CenterToastg2:SetHeight({ 0, 50 })
            CenterToastg2:SetXPosition({0, 0})
            CenterToastg2:SetYPosition({0, -273})
if move then move = nil end
        end
    end
end

local CannonEnabled = false
local CannonTimer, SoundLoop

function GMHelper:CannonBtn(text)
    
    self.CannonBtnEnabled = not self.CannonBtnEnabled
    _G["togCannonBtn"] = self.CannonBtnEnabled
    refreshButtonColorSave("CannonBtn")

    if self.CannonBtnEnabled then
        SaveItem("CannonBtn", "CannonBtn")
    end
local canon = GUIManager:getWindowByName("Main-Cannon")
    if not canon then return end

    CannonEnabled = not CannonEnabled

    if not CannonEnabled then
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
        canon:SetVisible(false)
        return
    end

    text:SetBackgroundColor({0.8, 0.4, 0.0, 1})
    UIHelper.showToast("^00FF00Enabled")
    canon:SetVisible(true)

    local scale = 0.5
    canon:SetScale(VectorUtil.newVector3(scale, scale, scale))
    LuaTimer:scheduleTicker(function()
        if scale <= 1 then
            scale = scale + 0.05
        else
            scale = scale - 0.0125
        end
        canon:SetScale(VectorUtil.newVector3(scale, scale, scale))
    end, 1, 15)

    canon:registerEvent(GUIEvent.ButtonClick, function()
        local clientPlayer = PlayerManager:getClientPlayer()
        if clientPlayer then
            local pitch = clientPlayer.Player:getPitch()
            local yaw = clientPlayer.Player:getYaw()
            local pitchRad = math.rad(pitch)
            local yawRad = math.rad(-yaw)
            local x = math.cos(pitchRad) * math.sin(yawRad) * 3
            local y = -math.sin(pitchRad) * 4
            local z = math.cos(pitchRad) * math.cos(yawRad) * 3
            local newPos = VectorUtil.newVector3(x, y, z)
            clientPlayer.Player:setVelocity(newPos)
        end
    end)

    canon:setEnableLongTouch(true)

    canon:registerEvent(GUIEvent.LongTouchStart, function()
        SoundLoop = LuaTimer:scheduleTicker(function()
            SoundUtil.playSound(0)
        end, 100)
        CannonTimer = LuaTimer:scheduleTimer(function()
            local clientPlayer = PlayerManager:getClientPlayer()
            if clientPlayer and clientPlayer.Player then
                local yaw = clientPlayer.Player:getYaw()
                local pitch = clientPlayer.Player:getPitch()
                local yawRad = math.rad(yaw)
                local pitchRad = math.rad(pitch)
                local speed = 1.7
                local x = -speed * math.cos(pitchRad) * math.sin(yawRad)
                local y = -speed * math.sin(pitchRad)
                local z = speed * math.cos(pitchRad) * math.cos(yawRad)
                local velocity = VectorUtil.newVector3(x, y, z)
                clientPlayer.Player:setVelocity(velocity)
            end
        end, 5, 200000)
    end)

    canon:registerEvent(GUIEvent.LongTouchEnd, function()
        if CannonTimer then
            LuaTimer:cancel(CannonTimer)
            CannonTimer = nil
        end
        if SoundLoop then
            LuaTimer:cancel(SoundLoop)
            SoundLoop = nil
        end
    end)
end

function GMHelper:HairPositive()
    
    self.HairPositiveEnabled = not self.HairPositiveEnabled
    _G["togHairPositive"] = self.HairPositiveEnabled
    refreshButtonColorSave("HairPositive")

    if self.HairPositiveEnabled then
        SaveItem("HairPositive", "HairPositive")
    end
local player = PlayerManager:getClientPlayer().Player
    if not player.m_hairID then
        player.m_hairID = 0
    end
    player.m_hairID = player.m_hairID + 1
    player.m_outLooksChanged = true
end

function GMHelper:HairNegative()
    
    self.HairNegativeEnabled = not self.HairNegativeEnabled
    _G["togHairNegative"] = self.HairNegativeEnabled
    refreshButtonColorSave("HairNegative")

    if self.HairNegativeEnabled then
        SaveItem("HairNegative", "HairNegative")
    end
local player = PlayerManager:getClientPlayer().Player
    if not player.m_hairID then
        player.m_hairID = 0
    end
    player.m_hairID = player.m_hairID - 1
    player.m_outLooksChanged = true
end

function GMHelper:FacePositive()
    
    self.FacePositiveEnabled = not self.FacePositiveEnabled
    _G["togFacePositive"] = self.FacePositiveEnabled
    refreshButtonColorSave("FacePositive")

    if self.FacePositiveEnabled then
        SaveItem("FacePositive", "FacePositive")
    end
local player = PlayerManager:getClientPlayer().Player
    if not player.m_faceID then
        player.m_faceID = 0
    end
    player.m_faceID = player.m_faceID + 1
    player.m_outLooksChanged = true
end

function GMHelper:FaceNegative()
    
    self.FaceNegativeEnabled = not self.FaceNegativeEnabled
    _G["togFaceNegative"] = self.FaceNegativeEnabled
    refreshButtonColorSave("FaceNegative")

    if self.FaceNegativeEnabled then
        SaveItem("FaceNegative", "FaceNegative")
    end
local player = PlayerManager:getClientPlayer().Player
    if not player.m_faceID then
        player.m_faceID = 0
    end
    player.m_faceID = player.m_faceID - 1
    player.m_outLooksChanged = true
end

function GMHelper:TopsPositive()
    
    self.TopsPositiveEnabled = not self.TopsPositiveEnabled
    _G["togTopsPositive"] = self.TopsPositiveEnabled
    refreshButtonColorSave("TopsPositive")

    if self.TopsPositiveEnabled then
        SaveItem("TopsPositive", "TopsPositive")
    end
local player = PlayerManager:getClientPlayer().Player
    if not player.m_topsID then
        player.m_topsID = 0
    end
    player.m_topsID = player.m_topsID + 1
    player.m_outLooksChanged = true
end

function GMHelper:TopsNegative()
    
    self.TopsNegativeEnabled = not self.TopsNegativeEnabled
    _G["togTopsNegative"] = self.TopsNegativeEnabled
    refreshButtonColorSave("TopsNegative")

    if self.TopsNegativeEnabled then
        SaveItem("TopsNegative", "TopsNegative")
    end
local player = PlayerManager:getClientPlayer().Player
    if not player.m_topsID then
        player.m_topsID = 0
    end
    player.m_topsID = player.m_topsID - 1
    player.m_outLooksChanged = true
end

function GMHelper:PantsPositive()
    
    self.PantsPositiveEnabled = not self.PantsPositiveEnabled
    _G["togPantsPositive"] = self.PantsPositiveEnabled
    refreshButtonColorSave("PantsPositive")

    if self.PantsPositiveEnabled then
        SaveItem("PantsPositive", "PantsPositive")
    end
local player = PlayerManager:getClientPlayer().Player
    if not player.m_pantsID then
        player.m_pantsID = 0
    end
    player.m_pantsID = player.m_pantsID + 1
    player.m_outLooksChanged = true
end

function GMHelper:PantsNegative()
    
    self.PantsNegativeEnabled = not self.PantsNegativeEnabled
    _G["togPantsNegative"] = self.PantsNegativeEnabled
    refreshButtonColorSave("PantsNegative")

    if self.PantsNegativeEnabled then
        SaveItem("PantsNegative", "PantsNegative")
    end
local player = PlayerManager:getClientPlayer().Player
    if not player.m_pantsID then
        player.m_pantsID = 0
    end
    player.m_pantsID = player.m_pantsID - 1
    player.m_outLooksChanged = true
end

function GMHelper:ShoesPositive()
    
    self.ShoesPositiveEnabled = not self.ShoesPositiveEnabled
    _G["togShoesPositive"] = self.ShoesPositiveEnabled
    refreshButtonColorSave("ShoesPositive")

    if self.ShoesPositiveEnabled then
        SaveItem("ShoesPositive", "ShoesPositive")
    end
local player = PlayerManager:getClientPlayer().Player
    if not player.m_shoesID then
        player.m_shoesID = 0
    end
    player.m_shoesID = player.m_shoesID + 1
    player.m_outLooksChanged = true
end

function GMHelper:ShoesNegative()
    
    self.ShoesNegativeEnabled = not self.ShoesNegativeEnabled
    _G["togShoesNegative"] = self.ShoesNegativeEnabled
    refreshButtonColorSave("ShoesNegative")

    if self.ShoesNegativeEnabled then
        SaveItem("ShoesNegative", "ShoesNegative")
    end
local player = PlayerManager:getClientPlayer().Player
    if not player.m_shoesID then
        player.m_shoesID = 0
    end
    player.m_shoesID = player.m_shoesID - 1
    player.m_outLooksChanged = true
end

function GMHelper:GlassesPositive()
    
    self.GlassesPositiveEnabled = not self.GlassesPositiveEnabled
    _G["togGlassesPositive"] = self.GlassesPositiveEnabled
    refreshButtonColorSave("GlassesPositive")

    if self.GlassesPositiveEnabled then
        SaveItem("GlassesPositive", "GlassesPositive")
    end
local player = PlayerManager:getClientPlayer().Player
    if not player.m_glassesId then
        player.m_glassesId = 0
    end
    player.m_glassesId = player.m_glassesId + 1
    player.m_outLooksChanged = true
end

function GMHelper:GlassesNegative()
    
    self.GlassesNegativeEnabled = not self.GlassesNegativeEnabled
    _G["togGlassesNegative"] = self.GlassesNegativeEnabled
    refreshButtonColorSave("GlassesNegative")

    if self.GlassesNegativeEnabled then
        SaveItem("GlassesNegative", "GlassesNegative")
    end
local player = PlayerManager:getClientPlayer().Player
    if not player.m_glassesId then
        player.m_glassesId = 0
    end
    player.m_glassesId = player.m_glassesId - 1
    player.m_outLooksChanged = true
end

function GMHelper:ScarfPositive()
    
    self.ScarfPositiveEnabled = not self.ScarfPositiveEnabled
    _G["togScarfPositive"] = self.ScarfPositiveEnabled
    refreshButtonColorSave("ScarfPositive")

    if self.ScarfPositiveEnabled then
        SaveItem("ScarfPositive", "ScarfPositive")
    end
local player = PlayerManager:getClientPlayer().Player
    if not player.m_scarfId then
        player.m_scarfId = 0
    end
    player.m_scarfId = player.m_scarfId + 1
    player.m_outLooksChanged = true
end

function GMHelper:ScarfNegative()
    
    self.ScarfNegativeEnabled = not self.ScarfNegativeEnabled
    _G["togScarfNegative"] = self.ScarfNegativeEnabled
    refreshButtonColorSave("ScarfNegative")

    if self.ScarfNegativeEnabled then
        SaveItem("ScarfNegative", "ScarfNegative")
    end
local player = PlayerManager:getClientPlayer().Player
    if not player.m_scarfId then
        player.m_scarfId = 0
    end
    player.m_scarfId = player.m_scarfId - 1
    player.m_outLooksChanged = true
end

function GMHelper:WingPositive()
    
    self.WingPositiveEnabled = not self.WingPositiveEnabled
    _G["togWingPositive"] = self.WingPositiveEnabled
    refreshButtonColorSave("WingPositive")

    if self.WingPositiveEnabled then
        SaveItem("WingPositive", "WingPositive")
    end
local player = PlayerManager:getClientPlayer().Player
    if not player.m_wingId then
        player.m_wingId = 0
    end
    player.m_wingId = player.m_wingId + 1
    player.m_outLooksChanged = true
end

function GMHelper:WingPositive()
    
    self.WingPositiveEnabled = not self.WingPositiveEnabled
    _G["togWingPositive"] = self.WingPositiveEnabled
    refreshButtonColorSave("WingPositive")

    if self.WingPositiveEnabled then
        SaveItem("WingPositive", "WingPositive")
    end
local player = PlayerManager:getClientPlayer().Player
    if not player.m_wingId then
        player.m_wingId = 0
    end
    player.m_wingId = player.m_wingId + 1
    player.m_outLooksChanged = true
end

function GMHelper:WingNegative()
    
    self.WingNegativeEnabled = not self.WingNegativeEnabled
    _G["togWingNegative"] = self.WingNegativeEnabled
    refreshButtonColorSave("WingNegative")

    if self.WingNegativeEnabled then
        SaveItem("WingNegative", "WingNegative")
    end
local player = PlayerManager:getClientPlayer().Player
    if not player.m_wingId then
        player.m_wingId = 0
    end
    player.m_wingId = player.m_wingId - 1
    player.m_outLooksChanged = true
end

function GMHelper:CrownPositive()
    
    self.CrownPositiveEnabled = not self.CrownPositiveEnabled
    _G["togCrownPositive"] = self.CrownPositiveEnabled
    refreshButtonColorSave("CrownPositive")

    if self.CrownPositiveEnabled then
        SaveItem("CrownPositive", "CrownPositive")
    end
local player = PlayerManager:getClientPlayer().Player
    if not player.m_crownId then
        player.m_crownId = 0
    end
    player.m_crownId = player.m_crownId + 1
    player.m_outLooksChanged = true
end

function GMHelper:CrownNegative()
    
    self.CrownNegativeEnabled = not self.CrownNegativeEnabled
    _G["togCrownNegative"] = self.CrownNegativeEnabled
    refreshButtonColorSave("CrownNegative")

    if self.CrownNegativeEnabled then
        SaveItem("CrownNegative", "CrownNegative")
    end
local player = PlayerManager:getClientPlayer().Player
    if not player.m_crownId then
        player.m_crownId = 0
    end
    player.m_crownId = player.m_crownId - 1
    player.m_outLooksChanged = true
end

function GMHelper:increaseCrownId()
    
    self.increaseCrownIdEnabled = not self.increaseCrownIdEnabled
    _G["togincreaseCrownId"] = self.increaseCrownIdEnabled
    refreshButtonColorSave("increaseCrownId")

    if self.increaseCrownIdEnabled then
        SaveItem("increaseCrownId", "increaseCrownId")
    end
local player = PlayerManager:getClientPlayer()
    if not player then return end
    player.Player.m_crownId = (player.Player.m_crownId or 0) + 1
    player.Player.m_outLooksChanged = true
    Toast("Crown ID: " .. player.Player.m_crownId)
end

function GMHelper:decreaseCrownId()
    
    self.decreaseCrownIdEnabled = not self.decreaseCrownIdEnabled
    _G["togdecreaseCrownId"] = self.decreaseCrownIdEnabled
    refreshButtonColorSave("decreaseCrownId")

    if self.decreaseCrownIdEnabled then
        SaveItem("decreaseCrownId", "decreaseCrownId")
    end
local player = PlayerManager:getClientPlayer()
    if not player then return end
    player.Player.m_crownId = (player.Player.m_crownId or 0) - 1
    player.Player.m_outLooksChanged = true
    Toast("Crown ID: " .. player.Player.m_crownId)
end

function GMHelper:increaseHairId()
    
    self.increaseHairIdEnabled = not self.increaseHairIdEnabled
    _G["togincreaseHairId"] = self.increaseHairIdEnabled
    refreshButtonColorSave("increaseHairId")

    if self.increaseHairIdEnabled then
        SaveItem("increaseHairId", "increaseHairId")
    end
local player = PlayerManager:getClientPlayer()
    if not player then return end
    player.Player.m_hairID = (player.Player.m_hairID or 0) + 1
    player.Player.m_outLooksChanged = true
    Toast("Hair ID: " .. player.Player.m_hairID)
end

function GMHelper:decreaseHairId()
    
    self.decreaseHairIdEnabled = not self.decreaseHairIdEnabled
    _G["togdecreaseHairId"] = self.decreaseHairIdEnabled
    refreshButtonColorSave("decreaseHairId")

    if self.decreaseHairIdEnabled then
        SaveItem("decreaseHairId", "decreaseHairId")
    end
local player = PlayerManager:getClientPlayer()
    if not player then return end
    player.Player.m_hairID = (player.Player.m_hairID or 0) - 1
    player.Player.m_outLooksChanged = true
    Toast("Hair ID: " .. player.Player.m_hairID)
end

function GMHelper:increaseFaceId()
    
    self.increaseFaceIdEnabled = not self.increaseFaceIdEnabled
    _G["togincreaseFaceId"] = self.increaseFaceIdEnabled
    refreshButtonColorSave("increaseFaceId")

    if self.increaseFaceIdEnabled then
        SaveItem("increaseFaceId", "increaseFaceId")
    end
local player = PlayerManager:getClientPlayer()
    if not player then return end
    player.Player.m_faceID = (player.Player.m_faceID or 0) + 1
    player.Player.m_outLooksChanged = true
    Toast("Face ID: " .. player.Player.m_faceID)
end

function GMHelper:decreaseFaceId()
    
    self.decreaseFaceIdEnabled = not self.decreaseFaceIdEnabled
    _G["togdecreaseFaceId"] = self.decreaseFaceIdEnabled
    refreshButtonColorSave("decreaseFaceId")

    if self.decreaseFaceIdEnabled then
        SaveItem("decreaseFaceId", "decreaseFaceId")
    end
local player = PlayerManager:getClientPlayer()
    if not player then return end
    player.Player.m_faceID = (player.Player.m_faceID or 0) - 1
    player.Player.m_outLooksChanged = true
    Toast("Face ID: " .. player.Player.m_faceID)
end

function GMHelper:increaseGlassesId()
    
    self.increaseGlassesIdEnabled = not self.increaseGlassesIdEnabled
    _G["togincreaseGlassesId"] = self.increaseGlassesIdEnabled
    refreshButtonColorSave("increaseGlassesId")

    if self.increaseGlassesIdEnabled then
        SaveItem("increaseGlassesId", "increaseGlassesId")
    end
local player = PlayerManager:getClientPlayer()
    if not player then return end
    player.Player.m_glassesId = (player.Player.m_glassesId or 0) + 1
    player.Player.m_outLooksChanged = true
    Toast("Glasses ID: " .. player.Player.m_glassesId)
end

function GMHelper:decreaseGlassesId()
    
    self.decreaseGlassesIdEnabled = not self.decreaseGlassesIdEnabled
    _G["togdecreaseGlassesId"] = self.decreaseGlassesIdEnabled
    refreshButtonColorSave("decreaseGlassesId")

    if self.decreaseGlassesIdEnabled then
        SaveItem("decreaseGlassesId", "decreaseGlassesId")
    end
local player = PlayerManager:getClientPlayer()
    if not player then return end
    player.Player.m_glassesId = (player.Player.m_glassesId or 0) - 1
    player.Player.m_outLooksChanged = true
    Toast("Glasses ID: " .. player.Player.m_glassesId)
end

function GMHelper:increaseScarfId()
    
    self.increaseScarfIdEnabled = not self.increaseScarfIdEnabled
    _G["togincreaseScarfId"] = self.increaseScarfIdEnabled
    refreshButtonColorSave("increaseScarfId")

    if self.increaseScarfIdEnabled then
        SaveItem("increaseScarfId", "increaseScarfId")
    end
local player = PlayerManager:getClientPlayer()
    if not player then return end
    player.Player.m_scarfId = (player.Player.m_scarfId or 0) + 1
    player.Player.m_outLooksChanged = true
    Toast("Scarf ID: " .. player.Player.m_scarfId)
end

function GMHelper:decreaseScarfId()
    
    self.decreaseScarfIdEnabled = not self.decreaseScarfIdEnabled
    _G["togdecreaseScarfId"] = self.decreaseScarfIdEnabled
    refreshButtonColorSave("decreaseScarfId")

    if self.decreaseScarfIdEnabled then
        SaveItem("decreaseScarfId", "decreaseScarfId")
    end
local player = PlayerManager:getClientPlayer()
    if not player then return end
    player.Player.m_scarfId = (player.Player.m_scarfId or 0) - 1
    player.Player.m_outLooksChanged = true
    Toast("Scarf ID: " .. player.Player.m_scarfId)
end

function GMHelper:increaseBackId()
    
    self.increaseBackIdEnabled = not self.increaseBackIdEnabled
    _G["togincreaseBackId"] = self.increaseBackIdEnabled
    refreshButtonColorSave("increaseBackId")

    if self.increaseBackIdEnabled then
        SaveItem("increaseBackId", "increaseBackId")
    end
local player = PlayerManager:getClientPlayer()
    if not player then return end
    player.Player.m_wingId = (player.Player.m_wingId or 0) + 1
    player.Player.m_outLooksChanged = true
    Toast("Back Wings ID: " .. player.Player.m_wingId)
end

function GMHelper:decreaseBackId()
    
    self.decreaseBackIdEnabled = not self.decreaseBackIdEnabled
    _G["togdecreaseBackId"] = self.decreaseBackIdEnabled
    refreshButtonColorSave("decreaseBackId")

    if self.decreaseBackIdEnabled then
        SaveItem("decreaseBackId", "decreaseBackId")
    end
local player = PlayerManager:getClientPlayer()
    if not player then return end
    player.Player.m_wingId = (player.Player.m_wingId or 0) - 1
    player.Player.m_outLooksChanged = true
    Toast("Back Wings ID: " .. player.Player.m_wingId)
end

function GMHelper:increaseShirtId()
    
    self.increaseShirtIdEnabled = not self.increaseShirtIdEnabled
    _G["togincreaseShirtId"] = self.increaseShirtIdEnabled
    refreshButtonColorSave("increaseShirtId")

    if self.increaseShirtIdEnabled then
        SaveItem("increaseShirtId", "increaseShirtId")
    end
local player = PlayerManager:getClientPlayer()
    if not player then return end
    player.Player.m_topsID = (player.Player.m_topsID or 0) + 1
    player.Player.m_outLooksChanged = true
    Toast("Shirt ID: " .. player.Player.m_topsID)
end

function GMHelper:decreaseShirtId()
    
    self.decreaseShirtIdEnabled = not self.decreaseShirtIdEnabled
    _G["togdecreaseShirtId"] = self.decreaseShirtIdEnabled
    refreshButtonColorSave("decreaseShirtId")

    if self.decreaseShirtIdEnabled then
        SaveItem("decreaseShirtId", "decreaseShirtId")
    end
local player = PlayerManager:getClientPlayer()
    if not player then return end
    player.Player.m_topsID = (player.Player.m_topsID or 0) - 1
    player.Player.m_outLooksChanged = true
    Toast("Shirt ID: " .. player.Player.m_topsID)
end

function GMHelper:increasePantsId()
    
    self.increasePantsIdEnabled = not self.increasePantsIdEnabled
    _G["togincreasePantsId"] = self.increasePantsIdEnabled
    refreshButtonColorSave("increasePantsId")

    if self.increasePantsIdEnabled then
        SaveItem("increasePantsId", "increasePantsId")
    end
local player = PlayerManager:getClientPlayer()
    if not player then return end
    player.Player.m_pantsID = (player.Player.m_pantsID or 0) + 1
    player.Player.m_outLooksChanged = true
    Toast("Pants ID: " .. player.Player.m_pantsID)
end

function GMHelper:decreasePantsId()
    
    self.decreasePantsIdEnabled = not self.decreasePantsIdEnabled
    _G["togdecreasePantsId"] = self.decreasePantsIdEnabled
    refreshButtonColorSave("decreasePantsId")

    if self.decreasePantsIdEnabled then
        SaveItem("decreasePantsId", "decreasePantsId")
    end
local player = PlayerManager:getClientPlayer()
    if not player then return end
    player.Player.m_pantsID = (player.Player.m_pantsID or 0) - 1
    player.Player.m_outLooksChanged = true
    Toast("Pants ID: " .. player.Player.m_pantsID)
end

function GMHelper:increaseTailId()
    
    self.increaseTailIdEnabled = not self.increaseTailIdEnabled
    _G["togincreaseTailId"] = self.increaseTailIdEnabled
    refreshButtonColorSave("increaseTailId")

    if self.increaseTailIdEnabled then
        SaveItem("increaseTailId", "increaseTailId")
    end
local player = PlayerManager:getClientPlayer()
    if not player then return end
    player.Player.m_tailId = (player.Player.m_tailId or 0) + 1
    player.Player.m_outLooksChanged = true
    Toast("Tail ID: " .. player.Player.m_tailId)
end

function GMHelper:decreaseTailId()
    
    self.decreaseTailIdEnabled = not self.decreaseTailIdEnabled
    _G["togdecreaseTailId"] = self.decreaseTailIdEnabled
    refreshButtonColorSave("decreaseTailId")

    if self.decreaseTailIdEnabled then
        SaveItem("decreaseTailId", "decreaseTailId")
    end
local player = PlayerManager:getClientPlayer()
    if not player then return end
    player.Player.m_tailId = (player.Player.m_tailId or 0) - 1
    player.Player.m_outLooksChanged = true
    Toast("Tail ID: " .. player.Player.m_tailId)
end

function GMHelper:increaseShoesId()
    
    self.increaseShoesIdEnabled = not self.increaseShoesIdEnabled
    _G["togincreaseShoesId"] = self.increaseShoesIdEnabled
    refreshButtonColorSave("increaseShoesId")

    if self.increaseShoesIdEnabled then
        SaveItem("increaseShoesId", "increaseShoesId")
    end
local player = PlayerManager:getClientPlayer()
    if not player then return end
    player.Player.m_shoesID = (player.Player.m_shoesID or 0) + 1
    player.Player.m_outLooksChanged = true
    Toast("Shoes ID: " .. player.Player.m_shoesID)
end

function GMHelper:setShoesId()
    
    self.setShoesIdEnabled = not self.setShoesIdEnabled
    _G["togsetShoesId"] = self.setShoesIdEnabled
    refreshButtonColorSave("setShoesId")

    if self.setShoesIdEnabled then
        SaveItem("setShoesId", "setShoesId")
    end
GMHelper:openInput({ "number" }, function(input)
        local player = PlayerManager:getClientPlayer().Player
        if not player then return end
        player.m_shoesID = tonumber(input) or 0
        player.m_outLooksChanged = true
        Toast("^FF00EESuccess")
    end)
end

function GMHelper:setTailId()
    
    self.setTailIdEnabled = not self.setTailIdEnabled
    _G["togsetTailId"] = self.setTailIdEnabled
    refreshButtonColorSave("setTailId")

    if self.setTailIdEnabled then
        SaveItem("setTailId", "setTailId")
    end
GMHelper:openInput({ "number" }, function(input)
        local player = PlayerManager:getClientPlayer().Player
        if not player then return end
        player.m_tailId = tonumber(input) or 0
        player.m_outLooksChanged = true
        Toast("^FF00EESuccess")
    end)
end

function GMHelper:setPantsId()
    
    self.setPantsIdEnabled = not self.setPantsIdEnabled
    _G["togsetPantsId"] = self.setPantsIdEnabled
    refreshButtonColorSave("setPantsId")

    if self.setPantsIdEnabled then
        SaveItem("setPantsId", "setPantsId")
    end
GMHelper:openInput({ "number" }, function(input)
        local player = PlayerManager:getClientPlayer().Player
        if not player then return end
        player.m_pantsID = tonumber(input) or 0
        player.m_outLooksChanged = true
        Toast("^FF00EESuccess")
    end)
end

function GMHelper:setShirtId()
    
    self.setShirtIdEnabled = not self.setShirtIdEnabled
    _G["togsetShirtId"] = self.setShirtIdEnabled
    refreshButtonColorSave("setShirtId")

    if self.setShirtIdEnabled then
        SaveItem("setShirtId", "setShirtId")
    end
GMHelper:openInput({ "number" }, function(input)
        local player = PlayerManager:getClientPlayer().Player
        if not player then return end
        player.m_topsID = tonumber(input) or 0
        player.m_outLooksChanged = true
        Toast("^FF00EESuccess")
    end)
end

function GMHelper:setBackId()
    
    self.setBackIdEnabled = not self.setBackIdEnabled
    _G["togsetBackId"] = self.setBackIdEnabled
    refreshButtonColorSave("setBackId")

    if self.setBackIdEnabled then
        SaveItem("setBackId", "setBackId")
    end
GMHelper:openInput({ "number" }, function(input)
        local player = PlayerManager:getClientPlayer().Player
        if not player then return end
        player.m_wingId = tonumber(input) or 0
        player.m_outLooksChanged = true
        Toast("^FF00EESuccess")
    end)
end

function GMHelper:setScarfId()
    
    self.setScarfIdEnabled = not self.setScarfIdEnabled
    _G["togsetScarfId"] = self.setScarfIdEnabled
    refreshButtonColorSave("setScarfId")

    if self.setScarfIdEnabled then
        SaveItem("setScarfId", "setScarfId")
    end
GMHelper:openInput({ "number" }, function(input)
        local player = PlayerManager:getClientPlayer().Player
        if not player then return end
        player.m_scarfId = tonumber(input) or 0
        player.m_outLooksChanged = true
        Toast("^FF00EESuccess")
    end)
end

function GMHelper:setGlassesId()
    
    self.setGlassesIdEnabled = not self.setGlassesIdEnabled
    _G["togsetGlassesId"] = self.setGlassesIdEnabled
    refreshButtonColorSave("setGlassesId")

    if self.setGlassesIdEnabled then
        SaveItem("setGlassesId", "setGlassesId")
    end
GMHelper:openInput({ "number" }, function(input)
        local player = PlayerManager:getClientPlayer().Player
        if not player then return end
        player.m_glassesId = tonumber(input) or 0
        player.m_outLooksChanged = true
        Toast("^FF00EESuccess")
    end)
end

function GMHelper:setFaceId()
    
    self.setFaceIdEnabled = not self.setFaceIdEnabled
    _G["togsetFaceId"] = self.setFaceIdEnabled
    refreshButtonColorSave("setFaceId")

    if self.setFaceIdEnabled then
        SaveItem("setFaceId", "setFaceId")
    end
GMHelper:openInput({ "number" }, function(input)
        local player = PlayerManager:getClientPlayer().Player
        if not player then return end
        player.m_faceID = tonumber(input) or 0
        player.m_outLooksChanged = true
        Toast("^FF00EESuccess")
    end)
end

function GMHelper:setHairId()
    
    self.setHairIdEnabled = not self.setHairIdEnabled
    _G["togsetHairId"] = self.setHairIdEnabled
    refreshButtonColorSave("setHairId")

    if self.setHairIdEnabled then
        SaveItem("setHairId", "setHairId")
    end
GMHelper:openInput({ "number" }, function(input)
        local player = PlayerManager:getClientPlayer().Player
        if not player then return end
        player.m_hairID = tonumber(input) or 0
        player.m_outLooksChanged = true
        Toast("^FF00EESuccess")
    end)
end

function GMHelper:setCrownId()
    
    self.setCrownIdEnabled = not self.setCrownIdEnabled
    _G["togsetCrownId"] = self.setCrownIdEnabled
    refreshButtonColorSave("setCrownId")

    if self.setCrownIdEnabled then
        SaveItem("setCrownId", "setCrownId")
    end
GMHelper:openInput({ "number" }, function(input)
        local player = PlayerManager:getClientPlayer().Player
        if not player then return end
        player.m_crownId = tonumber(input) or 0
        player.m_outLooksChanged = true
        Toast("^FF00EESuccess")
    end)
end

function GMHelper:decreaseShoesId()
    
    self.decreaseShoesIdEnabled = not self.decreaseShoesIdEnabled
    _G["togdecreaseShoesId"] = self.decreaseShoesIdEnabled
    refreshButtonColorSave("decreaseShoesId")

    if self.decreaseShoesIdEnabled then
        SaveItem("decreaseShoesId", "decreaseShoesId")
    end
local player = PlayerManager:getClientPlayer()
    if not player then return end
    player.Player.m_shoesID = (player.Player.m_shoesID or 0) - 1
    player.Player.m_outLooksChanged = true
    Toast("Shoes ID: " .. player.Player.m_shoesID)
end

function GMHelper:NoLag(text)
    
    self.NoLagEnabled = not self.NoLagEnabled
    _G["togNoLag"] = self.NoLagEnabled
    refreshButtonColorSave("NoLag")

    if self.NoLagEnabled then
        SaveItem("NoLag", "NoLag")
    end
local FPS = 500000  
    togNoLag = not togNoLag
    if not togNoLag then
        CGame.Instance():SetMaxFps(60)
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
        return
    end
    CGame.Instance():SetMaxFps(FPS)
    text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
    UIHelper.showToast("^00FF00Enabled")
end

function GMHelper:UnlockFPS(text)
    
    self.UnlockFPSEnabled = not self.UnlockFPSEnabled
    _G["togUnlockFPS"] = self.UnlockFPSEnabled
    refreshButtonColorSave("UnlockFPS")

    if self.UnlockFPSEnabled then
        SaveItem("UnlockFPS", "UnlockFPS")
    end
self._unlockFPSEnabled = not self._unlockFPSEnabled

    if self._originalRenderDistance == nil then
        self._originalRenderDistance = ClientHelper.getIntPrefs("BlockRenderDistance")
    end

    local antiLagRenderDistance = 100

    if self._unlockFPSEnabled then
        text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
        UIHelper.showToast("^00FF00FPS Unlock Enabled")
        ClientHelper.putIntPrefs("BlockRenderDistance", antiLagRenderDistance)
    else
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000FPS Unlock Disabled")
        ClientHelper.putIntPrefs("BlockRenderDistance", self._originalRenderDistance)
    end
end

local highJumpValue = 1
function GMHelper:HighJump(text)
    
    self.HighJumpEnabled = not self.HighJumpEnabled
    _G["togHighJump"] = self.HighJumpEnabled
    refreshButtonColorSave("HighJump")

    if self.HighJumpEnabled then
        SaveItem("HighJump", "HighJump")
    end
local player = PlayerManager:getClientPlayer()
    togHighJump = not togHighJump
    if togHighJump then
        text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
        UIHelper.showToast("^00FF00Enabled")
        player.Player:setFloatProperty("JumpHeight", highJumpValue) 
        return
    end
    text:SetBackgroundColor({0, 0, 0, 0.8})
    UIHelper.showToast("^FF0000Disabled")
    player.Player:setFloatProperty("JumpHeight", 0.4)
end

function GMHelper:FreeCamera(text)
    
    self.FreeCameraEnabled = not self.FreeCameraEnabled
    _G["togFreeCamera"] = self.FreeCameraEnabled
    refreshButtonColorSave("FreeCamera")

    if self.FreeCameraEnabled then
        SaveItem("FreeCamera", "FreeCamera")
    end
togFreeCamera = not togFreeCamera
    if not togFreeCamera then
        GUIManager:getWindowByName("Main-HideAndSeek-Operate"):SetVisible(false)
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
        return
    end
    GUIManager:getWindowByName("Main-HideAndSeek-Operate"):SetVisible(true)
    text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
    UIHelper.showToast("^00FF00Enabled")
end

local function createButtonHandler(button, moveVector)
    local isTouching = false
    local timer
    local pos = PlayerManager:getClientPlayer():getPosition()

    local function movePlayer()
        if isTouching then
            pos = PlayerManager:getClientPlayer():getPosition()
            PlayerManager:getClientPlayer().Player:moveEntity(moveVector)
        end
    end

    local function startTouch()
        if not isTouching then
            isTouching = true
            timer = LuaTimer:scheduleTimer(movePlayer, 0.1, -1)
        end
    end

    local function stopTouch()
        isTouching = false
        if timer then
            LuaTimer:cancel(timer)
            timer = nil
        end
    end

    button:registerEvent(GUIEvent.TouchDown, startTouch)
    button:registerEvent(GUIEvent.TouchMove, movePlayer)
    button:registerEvent(GUIEvent.TouchUp, stopTouch)
    button:registerEvent(GUIEvent.LongTouchStart, startTouch)
    button:registerEvent(GUIEvent.LongTouchEnd, stopTouch)
    button:registerEvent(GUIEvent.Click, startTouch)
    button:registerEvent(GUIEvent.DoubleClick, startTouch)
    button:registerEvent(GUIEvent.DragStart, startTouch)
    button:registerEvent(GUIEvent.Dragging, movePlayer)
    button:registerEvent(GUIEvent.DragEnd, stopTouch)
    button:registerEvent(GUIEvent.Release, stopTouch)
end

function GMHelper:DevFly(text)
    self.DevFlyEnabled = not self.DevFlyEnabled
    _G["togDevFly"] = self.DevFlyEnabled
    refreshButtonColorSave("DevFly")

    if self.DevFlyEnabled then
        SaveItem("DevFly", "DevFly")
    end

    self.isFlying = self.isFlying or false

    if not self.flySpeedTimer then
        self.flySpeedTimer = LuaTimer:scheduleTimer(function()
            local player = PlayerManager:getClientPlayer().Player
            if player then
                if player:getIsFlying() then
                    player:setSpeedAdditionLevel(15000)
                else
                    player:setSpeedAdditionLevel(0)
                end
            end
        end, 50, -1)
    end

    if not self.flyButton then
        self.flyButton = GUIManager:createGUIWindow(GUIType.Button, "GUIRoot-FlyHack")
        self.flyButton:SetHorizontalAlignment(HorizontalAlignment.Center)
        self.flyButton:SetVerticalAlignment(VerticalAlignment.Center)
        self.flyButton:SetHeight({0, 55})
        self.flyButton:SetWidth({0, 55})
        self.flyButton:SetXPosition({0, 722})
        self.flyButton:SetYPosition({0, 93})

        local UpBtn = GUIManager:getWindowByName("Main-Down")
        createButtonHandler(UpBtn, VectorUtil.newVector3(0, -0.0020, 0))
        local DownBtn = GUIManager:getWindowByName("Main-Up")
        createButtonHandler(DownBtn, VectorUtil.newVector3(0, 0.0020, 0))

        self.flyButton:registerEvent(GUIEvent.ButtonClick, function()
            self.fly = LuaTimer:scheduleTimer(function()
                if PlayerManager:getClientPlayer().Player:getIsFlying() then        
                    self.flyButton:SetVisible(false)   
                else 
                    self.flyButton:SetVisible(true)
                end
            end, 50, -1)
            local player = PlayerManager:getClientPlayer().Player
            local moveDir = VectorUtil.newVector3(0.0, 1.35, 0.0)
            player:setAllowFlying(true)
            player:setFlying(true)
            player:moveEntity(moveDir)
        end)

        GUISystem.Instance():GetRootWindow():AddChildWindow(self.flyButton)
    end

    if self.DevFlyEnabled then
        self.flyButton:SetNormalImage("set:fly_control.json image:luodi")
        self.flyButton:SetPushedImage("set:fly_control.json image:luodi")
        self.flyButton:SetVisible(true)
        text:SetBackgroundColor({0.8, 0.4, 0.0, 1})
        UIHelper.showToast("^00FF00Enabled")
    else
        self.flyButton:SetNormalImage("")
        self.flyButton:SetPushedImage("")
        self.flyButton:SetVisible(false)
        local player = PlayerManager:getClientPlayer().Player
        player:setAllowFlying(false)
        player:setFlying(false)
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^00FF00Disabled")
    end
end

local p = {}
p['lock'] = 9e36
p['lock2'] = p['lock'] + 9e308
p['vec3'] = function(...)
    local b = {...}
    return {x = b[1], y = b[2], z = b[3]}
end

function tpToChest(chestPos)
    local clientWrapper = PlayerManager:getClientPlayer()
    if not clientWrapper or not clientWrapper.Player then return end
    local clientPlayer = clientWrapper.Player
    local yaw = clientPlayer.rotationYaw
    local pitch = clientPlayer.rotationPitch
    local farAway = p['vec3'](p['lock2'], p['lock2'], p['lock2'])
    clientPlayer.noClip = true
    clientPlayer:setPosition(farAway)

    local targetPos = p['vec3'](
        chestPos.x + 0.5,
        chestPos.y + 1.0,
        chestPos.z + 0.5
    )
    clientPlayer:setPosition(targetPos)

    clientPlayer.noClip = false
    clientPlayer.rotationYaw = yaw
    clientPlayer.rotationPitch = pitch
end

function GMHelper:JBAutoLoot(text)
    self.JBAutoLootEnabled = not self.JBAutoLootEnabled
    _G["togJBAutoLoot"] = self.JBAutoLootEnabled
    refreshButtonColorSave("JBAutoLoot")

    if self.JBAutoLootEnabled then
        SaveItem("JBAutoLoot", "JBAutoLoot")
        UIHelper.showToast("^00FF00Enabled")
        text:SetBackgroundColor({0.8, 0.4, 0.0, 1})

        if not autoLootTimer then
            local collectedTotal = 0
            autoLootTimer = LuaTimer:scheduleTimer(function()
                local player = PlayerManager:getClientPlayer()
                if not player then return end

                local chestPos = p['vec3'](124.55, 77.86, 143.302)
                tpToChest(chestPos)

                CGame.Instance():handleUseBlock(chestPos.x, chestPos.y, chestPos.z)

                local heldItemId = player.Player:getHeldItemId()
                if heldItemId == ItemID.EMERALD 
                    or heldItemId == ItemID.INGOT_GOLD 
                    or heldItemId == ItemID.DIAMOND then
                    collectedTotal = collectedTotal + 1
                    UIHelper.showToast("You collected: " .. tostring(collectedTotal))
                end
            end, 5000, -1)
        end
    else
        UIHelper.showToast("^00FF00Disabled")
        text:SetBackgroundColor({0, 0, 0, 0.8})
        if autoLootTimer then
            LuaTimer:cancel(autoLootTimer)
            autoLootTimer = nil
        end
    end
end

function GMHelper:BreakBlock(text)
    
    self.BreakBlockEnabled = not self.BreakBlockEnabled
    _G["togBreakBlock"] = self.BreakBlockEnabled
    refreshButtonColorSave("BreakBlock")

    if self.BreakBlockEnabled then
        SaveItem("BreakBlock", "BreakBlock")
    end
local curWorld = EngineWorld:getWorld()
    local playerPeer = PlayerManager:getClientPlayer()
    local innerPlayer = playerPeer.Player
    local pos = playerPeer:getPosition()
    local yaw = playerPeer:getYaw()
    local inv = playerPeer:getInventory()
    local invSize = 36
    local debugCount = 0

    local function breakBlock(rakssid, blockId, vec3)
        curWorld:destroyBlock(vec3, true)
        for i = 0, invSize do
            local curItemId = inv:getItemStackInfo(i).id
            if curItemId == blockId then
                inv:decrStackSize(i, -1)
                return true
            elseif curItemId == nil or curItemId == 0 then
                inv:addItemToInventory(Item.getItemById(blockId), 1)
                return true
            else
                debugCount = debugCount + 1
            end
        end
        curWorld:spawnItemInWorld(blockId, 1, 0, 480, vec3, VectorUtil.ZERO, false, true)
        return true
    end

    local function placeBlock(rakssid, itemId, meta, toPlacePos)
        local vec3 = VectorUtil.newVector3(toPlacePos.x, toPlacePos.y + 1, toPlacePos.z)
        EngineWorld:setBlock(vec3, inv:getItemStackInfo(inv:getCurrentItemIndex()).id)
        inv:decrStackSize(inv:getCurrentItemIndex(), 1)
        return true
    end

    togBreakBlock = not togBreakBlock

    if togBreakBlock then
        CEvents.BlockBreakEvent:registerCallBack(breakBlock)
        CEvents.PlayerPlaceBlockEvent:registerCallBack(placeBlock)
        text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
        UIHelper.showToast("^00FF00Enabled")
    else
        CEvents.BlockBreakEvent:unregisterCallBack(breakBlock)
        CEvents.PlayerPlaceBlockEvent:unregisterCallBack(placeBlock)
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
    end
end

function GMHelper:TpVisual()
    local players = PlayerManager:getPlayers()
    if not players then return end

    local clientPlayer = PlayerManager:getClientPlayer()
    if not clientPlayer then return end

    local clientPos = clientPlayer:getPosition()
    if not clientPos then return end

    for _, playerWrapper in pairs(players) do
        local player = playerWrapper.Player
        if player and player ~= clientPlayer then
            local success, err = pcall(function()
                local visualPos = {
                    x = clientPos.x + math.random(-2, 2),
                    y = clientPos.y,
                    z = clientPos.z + math.random(-2, 2)
                }
                player:setPosition(VectorUtil.newVector3(visualPos.x, visualPos.y, visualPos.z))
            end)

            if not success then
                print("Client TpVisual error for player "
                      .. tostring(playerWrapper.entityId)
                      .. ": " .. tostring(err))
            end
        end
    end
end

function GMHelper:SoftBypassSpeed()
    
    self.SoftBypassSpeedEnabled = not self.SoftBypassSpeedEnabled
    _G["togSoftBypassSpeed"] = self.SoftBypassSpeedEnabled
    refreshButtonColorSave("SoftBypassSpeed")

    if self.SoftBypassSpeedEnabled then
        SaveItem("SoftBypassSpeed", "SoftBypassSpeed")
    end
local lp
    local p = PlayerManager:getClientPlayer()
    LuaTimer:scheduleTimer(function()
        if p and p.Player then
            local cp = {p:getPosition()}
            if not lp or cp[1]~=lp[1] or cp[2]~=lp[2] or cp[3]~=lp[3] then
                p.Player.m_longMoveBeginTime, p.Player.m_longMoveCnt = 0, 0
                ClientHelper.putIntPrefs("longMoveCnt", 0)
                ClientHelper.putIntPrefs("longMoveBeginTime", 0)
                p.m_inTheAirBeginTime, p.m_inTheAirCnt = 0, 0
                ClientHelper.putIntPrefs("InTheAirCntLimit", math.huge)
                ClientHelper.putIntPrefs("InTheAirTimeLimit", math.huge)
                Blockman.Instance():getPlayer().onGround = true
                Blockman.Instance():getPlayer().m_flyingByPulled = true
                lp = cp
            end
        end
    end, 10, -1)
    MsgSender.sendMsg("Speed bypass active")
    UIHelper.showToast("^00FF00Enabled")
end

GMHelper.fastJumpBWEnabled = false

function GMHelper:FastJumpBW()
    
    self.FastJumpBWEnabled = not self.FastJumpBWEnabled
    _G["togFastJumpBW"] = self.FastJumpBWEnabled
    refreshButtonColorSave("FastJumpBW")

    if self.FastJumpBWEnabled then
        SaveItem("FastJumpBW", "FastJumpBW")
    end
self.fastJumpBWEnabled = not self.fastJumpBWEnabled

    local playerWrapper = PlayerManager:getClientPlayer()
    if not playerWrapper or not playerWrapper.Player then return end
    local player = playerWrapper.Player
    local bmPlayer = Blockman.Instance():getPlayer()

    if self.fastJumpBWEnabled then
        local myPos = player:getPosition()
        local nearestPos = nil
        local minDist = 9999

        for dx = -60, 60 do
            for dy = -10, 20 do
                for dz = -60, 60 do
                    local pos = VectorUtil.newVector3(myPos.x + dx, myPos.y + dy, myPos.z + dz)
                    local blockId = EngineWorld:getBlockId(pos)
                    if blockId == 133 or blockId == 57 then
                        local dist = VectorUtil.distance(myPos, pos)
                        if dist < minDist then
                            minDist = dist
                            nearestPos = pos
                        end
                    end
                end
            end
        end

        if nearestPos then
            player.m_keepJumping = false
            player.noClip = true
            bmPlayer.m_flyingByPulled = true
            player:setFakeOccupation(1)

            local tpPos = VectorUtil.newVector3(nearestPos.x + 0.5, nearestPos.y + 2, nearestPos.z + 0.5)
            LuaTimer:scheduleOnce(function()
                setPosTest(tpPos)
            end, 150)
            UIHelper.showToast("Fast Jump Enabled")
        else
            UIHelper.showToast("No valid block found nearby")
        end

    else
        player.m_keepJumping = true
        player.noClip = false
        bmPlayer.m_flyingByPulled = false
        player:setFakeOccupation(0)

        UIHelper.showToast("Fast Jump Disabled")
    end
end

local savedPos = nil

local function setPosTest(targetPos)
    if targetPos.y < 10 then return end

    local clientWrapper = PlayerManager:getClientPlayer()
    if not clientWrapper or not clientWrapper.Player then return end
    local clientPlayer = clientWrapper.Player

    local myPos = clientPlayer:getPosition()
    local yaw = clientPlayer.rotationYaw
    local pitch = clientPlayer.rotationPitch

    local disTp = { x = targetPos.x - myPos.x, z = targetPos.z - myPos.z }
    local totalDistance = math.sqrt(disTp.x * disTp.x + disTp.z * disTp.z)

    UIHelper.showToast("Distance: " .. string.format("%.2f", totalDistance))

    if myPos.y < 165 then myPos.y = 165 end

    if math.abs(disTp.x) > 18 then
        myPos.x = myPos.x + (disTp.x > 0 and 18 or -18)
        clientPlayer:setPosition(myPos)
        LuaTimer:scheduleTimer(function()
            setPosTest(targetPos)
        end, 0.015, 1)
        return
    end

    if math.abs(disTp.z) > 18 then
        myPos.z = myPos.z + (disTp.z > 0 and 18 or -18)
        clientPlayer:setPosition(myPos)
        LuaTimer:scheduleTimer(function()
            setPosTest(targetPos)
        end, 0.015, 1)
        return
    end

    local function checkBlock(pos)
        while EngineWorld:getBlockId(pos) ~= BlockID.AIR do
            pos.y = pos.y + 1
            if pos.y > 256 then break end
        end
        return pos
    end

    targetPos = checkBlock(targetPos)
    local abovePos = VectorUtil.newVector3(targetPos.x, targetPos.y + 1.3, targetPos.z)

    clientPlayer.noClip = true
    clientPlayer:setPosition(abovePos)
    clientPlayer.noClip = false

    clientPlayer:setPosition(abovePos)
    clientPlayer.rotationYaw = yaw
    clientPlayer.rotationPitch = pitch

    clientPlayer:setVelocity(VectorUtil.newVector3(0, 0.3, 0))
    clientPlayer:setAllowFlying(false)
    clientPlayer:setFlying(false)

    LuaTimer:scheduleOnce(function()
        clientPlayer:setAllowFlying(false)
        clientPlayer:setFlying(false)
    end, 0.05)

    savedPos = abovePos

    for i = 1, 5 do
        LuaTimer:scheduleOnce(function()
            clientPlayer:setPosition(savedPos)
        end, i * 0.05)
    end
end

function GMHelper:BedDestroyer(text)
    
    self.BedDestroyerEnabled = not self.BedDestroyerEnabled
    _G["togBedDestroyer"] = self.BedDestroyerEnabled
    refreshButtonColorSave("BedDestroyer")

    if self.BedDestroyerEnabled then
        SaveItem("BedDestroyer", "BedDestroyer")
    end
BedDestroyertog = not BedDestroyertog
    if not BedDestroyertog then
        UIHelper.showToast("BedTP: Off")
        text:SetBackgroundColor({0, 0, 0, 0.8})
        if self._bedTpTimer then
            LuaTimer:cancel(self._bedTpTimer)
            self._bedTpTimer = nil
        end

        local me = PlayerManager:getClientPlayer()
        if me and me.Player then
            me.Player.noClip = false
        end
        return
    end

    UIHelper.showToast("BedTP: On")
    text:SetBackgroundColor({0.8, 0.4, 0.0, 1})

    local currentTargetBed = nil
    local lastScanTime = 0
    local scanCooldown = 1500

    local function scanForEnemyBed()
        local meWrapper = PlayerManager:getClientPlayer()
        if not meWrapper or not meWrapper.Player then return nil end
        local me = meWrapper.Player
        local myPos = me:getPosition()
        local myTeam = meWrapper:getTeamId()

        local players = PlayerManager:getPlayers()
        local beds = {}
        for _, wrapper in ipairs(players) do
            if wrapper.Player and wrapper ~= meWrapper then
                local team = wrapper:getTeamId()
                if team ~= myTeam then
                    local ppos = wrapper.Player:getPosition()
                    for dx = -15, 15 do
                        for dy = -6, 6 do
                            for dz = -15, 15 do
                                local bpos = VectorUtil.newVector3(ppos.x + dx, ppos.y + dy, ppos.z + dz)
                                if EngineWorld:getBlockId(bpos) == BlockID.BED then
                                    local d = VectorUtil.distance(myPos, bpos)
                                    table.insert(beds, {pos = bpos, dist = d})
                                end
                            end
                        end
                    end
                end
            end
        end

        if #beds == 0 then return nil end
        table.sort(beds, function(a, b) return a.dist < b.dist end)
        return beds[1].pos
    end

    self._bedTpTimer = LuaTimer:scheduleTimer(function()
        local me = PlayerManager:getClientPlayer()
        if not me or not me.Player then return end

        local now = os.time() * 500
        if (not currentTargetBed or EngineWorld:getBlockId(currentTargetBed) ~= BlockID.BED) and (now - lastScanTime >= scanCooldown) then
            lastScanTime = now
            currentTargetBed = scanForEnemyBed()
            if currentTargetBed then
                me.Player.noClip = true
            else
                me.Player.noClip = false
                return
            end
        end

        if currentTargetBed then
            PacketSender:sendLuaCommonData("TeleportHallInitPos")

            local tp = VectorUtil.newVector3(
                currentTargetBed.x + 0.5,
                currentTargetBed.y + 2,
                currentTargetBed.z + 0.5
            )
            setPosTest(tp)
        end
    end, 70, -1)
end

GMHelper.infJumpBWEnabled = false

function GMHelper:InfJumpBW()
    
    self.InfJumpBWEnabled = not self.InfJumpBWEnabled
    _G["togInfJumpBW"] = self.InfJumpBWEnabled
    refreshButtonColorSave("InfJumpBW")

    if self.InfJumpBWEnabled then
        SaveItem("InfJumpBW", "InfJumpBW")
    end
self.infJumpBWEnabled = not self.infJumpBWEnabled

    local meWrapper = PlayerManager:getClientPlayer()
    if not meWrapper or not meWrapper.Player then return end
    local me = meWrapper.Player

    if self.infJumpBWEnabled then
        local myPos = me:getPosition()
        local found = nil
        local minDist = 9999

        for dx = -60, 60 do
            for dy = -10, 20 do
                for dz = -60, 60 do
                    local pos = VectorUtil.newVector3(myPos.x + dx, myPos.y + dy, myPos.z + dz)
                    local id = EngineWorld:getBlockId(pos)
                    if id == 133 or id == 57 then
                        local dist = VectorUtil.distance(myPos, pos)
                        if dist < minDist then
                            minDist = dist
                            found = pos
                        end
                    end
                end
            end
        end

        if found then
            me.noClip = true
            PacketSender:sendLuaCommonData("TeleportHallInitPos")

            LuaTimer:scheduleOnce(function()
                local tp = VectorUtil.newVector3(found.x + 0.5, found.y + 2, found.z + 0.5)
                setPosTest(tp)
            end, 150)

            UIHelper.showToast("Inf Jump Enabled")
        else
            UIHelper.showToast("Inf Jump (no Id 133 or 57 found)")
        end
    else
        me.noClip = false
        UIHelper.showToast("Inf Jump Disabled")
    end
end

local function createButtonHandler(button, moveVector)
    local isTouching = false
    local timer

    local function movePlayer()
        if isTouching then
            PlayerManager:getClientPlayer().Player:moveEntity(moveVector)
        end
    end

    local function startTouch()
        if not isTouching then
            isTouching = true
            timer = LuaTimer:scheduleTimer(movePlayer, 0.1, -1)
        end
    end

    local function stopTouch()
        isTouching = false
        if timer then
            LuaTimer:cancel(timer)
            timer = nil
        end
    end

    button:registerEvent(GUIEvent.TouchDown, startTouch)
    button:registerEvent(GUIEvent.TouchMove, movePlayer)
    button:registerEvent(GUIEvent.TouchUp, stopTouch)
    button:registerEvent(GUIEvent.LongTouchStart, startTouch)
    button:registerEvent(GUIEvent.LongTouchEnd, stopTouch)
    button:registerEvent(GUIEvent.Click, startTouch)
    button:registerEvent(GUIEvent.DoubleClick, startTouch)
    button:registerEvent(GUIEvent.DragStart, startTouch)
    button:registerEvent(GUIEvent.Dragging, movePlayer)
    button:registerEvent(GUIEvent.DragEnd, stopTouch)
    button:registerEvent(GUIEvent.Release, stopTouch)
end

GMHelper.devFlyEnabled = false

function GMHelper:DevFlyBW()
    
    self.DevFlyBWEnabled = not self.DevFlyBWEnabled
    _G["togDevFlyBW"] = self.DevFlyBWEnabled
    refreshButtonColorSave("DevFlyBW")

    if self.DevFlyBWEnabled then
        SaveItem("DevFlyBW", "DevFlyBW")
    end
self.devFlyEnabled = not self.devFlyEnabled
    local meWrapper = PlayerManager:getClientPlayer()
    if not meWrapper or not meWrapper.Player then return end
    local me = meWrapper.Player

    if self.devFlyEnabled then
        me:setAllowFlying(true)
        me:setFlying(true)
        me:setSpeedAdditionLevel(850)
        me:moveEntity(VectorUtil.newVector3(0.0, 1.35, 0.0))

        local UpBtn = GUIManager:getWindowByName("Main-Up")
        createButtonHandler(UpBtn, VectorUtil.newVector3(0, 0.0020, 0))

        local DownBtn = GUIManager:getWindowByName("Main-Down")
        createButtonHandler(DownBtn, VectorUtil.newVector3(0, -0.0020, 0))

        ClientHelper.putBoolPrefs("SyncClientPositionToServer", false)
        ClientHelper.putIntPrefs("InTheAirCntLimit", math.huge)
        ClientHelper.putIntPrefs("InTheAirTimeLimit", 9999)

        UIHelper.showToast("Dev Fly Enabled")
    else
        local pos = me:getPosition()
        local appliedPos = VectorUtil.newVector3(pos.x, pos.y, pos.z)
        me:setPosition(appliedPos)
        local isTest = true

        me:setFlying(false)
        me:setAllowFlying(false)
        me:setSpeedAdditionLevel(0)

        ClientHelper.putBoolPrefs("SyncClientPositionToServer", true)
        ClientHelper.putIntPrefs("InTheAirCntLimit", math.huge)
        ClientHelper.putIntPrefs("InTheAirTimeLimit", 9999)

        UIHelper.showToast("Dev Fly Disabled")
    end
end

GMHelper.speedBWEnabled = false

function GMHelper:SpeedBW()
    
    self.SpeedBWEnabled = not self.SpeedBWEnabled
    _G["togSpeedBW"] = self.SpeedBWEnabled
    refreshButtonColorSave("SpeedBW")

    if self.SpeedBWEnabled then
        SaveItem("SpeedBW", "SpeedBW")
    end
self.speedBWEnabled = not self.speedBWEnabled

    local meWrapper = PlayerManager:getClientPlayer()
    if not meWrapper or not meWrapper.Player then return end
    local me = meWrapper.Player

    if self.speedBWEnabled then
        local myPos = me:getPosition()

        ClientHelper.putFloatPrefs("SavedX", myPos.x)
        ClientHelper.putFloatPrefs("SavedY", myPos.y)
        ClientHelper.putFloatPrefs("SavedZ", myPos.z)

        local foundAir = false
         for dx = -60, 60 do
            for dy = -10, 20 do
                for dz = -60, 60 do
                    local checkPos = VectorUtil.newVector3(myPos.x + dx, myPos.y + dy, myPos.z + dz)
                    local blockId = EngineWorld:getBlockId(checkPos)
                    if blockId == BlockID.AIR then
                        foundAir = true
                        break
                    end
                end
                if foundAir then break end
            end
            if foundAir then break end
        end

        PacketSender:sendLuaCommonData("TeleportHallInitPos")
        me:setSpeedAdditionLevel(15000)

        UIHelper.showToast("SpeedBW Enabled")
    else
        me:setSpeedAdditionLevel(7)
        UIHelper.showToast("SpeedBW Disabled")
    end
end

function setPosTest(targetPos)
    if targetPos.y < 10 then return end

    local clientPlayer = PlayerManager:getClientPlayer().Player
    local myPos = clientPlayer:getPosition()

    yaw = clientPlayer.rotationYaw
    pitch = clientPlayer.rotationPitch

    local disTp = { x = targetPos.x - myPos.x, z = targetPos.z - myPos.z }
    local totalDistance = math.sqrt(disTp.x * disTp.x + disTp.z * disTp.z)

    UIHelper.showToast("Total distance left: " .. string.format("%.2f", totalDistance))

    if myPos.y < 165 then
        myPos.y = 165
    end

    if math.abs(disTp.x) > 18 then
        myPos.x = myPos.x + (disTp.x > 0 and 18 or -18)
        clientPlayer:setPosition(myPos)

        LuaTimer:scheduleTimer(function()
            setPosTest(targetPos)
        end, 0.015, 1)
        return
    end

    if math.abs(disTp.z) > 18 then
        myPos.z = myPos.z + (disTp.z > 0 and 18 or -18)
        clientPlayer:setPosition(myPos)

        LuaTimer:scheduleTimer(function()
            setPosTest(targetPos)
        end, 0.015, 1)
        return
    end

    local function checkBlock(pos)
        if EngineWorld:getBlockId(pos) ~= BlockID.AIR then
            while EngineWorld:getBlockId(pos) ~= BlockID.AIR do
                pos.y = pos.y + 1
                if pos.y > 256 then break end
            end
        end
        return pos
    end

    targetPos = checkBlock(targetPos)

    clientPlayer.noClip = true
    local abovePos = VectorUtil.newVector3(targetPos.x, targetPos.y + 1.3, targetPos.z)
    clientPlayer:setPosition(abovePos)
    clientPlayer.noClip = false

    clientPlayer:setAllowFlying(false)
    clientPlayer:setFlying(false)
    clientPlayer.rotationYaw = yaw
    clientPlayer.rotationPitch = pitch
    ClientHelper.putBoolPrefs("SyncClientPositionToServer", false)
    clientPlayer:setPosition(abovePos)

    local timeLeft = 1
    tmLft = LuaTimer:scheduleTimer(function()
        PacketSender:getSender():sendRebirth()
        timeLeft = timeLeft - 1
        if timeLeft <= 0 then
            ClientHelper.putBoolPrefs("SyncClientPositionToServer", true)
            LuaTimer:cancel(tmLft)
            clientPlayer:moveEntity(VectorUtil.newVector3(0, 1.35, 0))
            clientPlayer:setAllowFlying(true)
            clientPlayer:setFlying(true)
            LuaTimer:schedule(function()
                clientPlayer:setAllowFlying(false)
                clientPlayer:setFlying(false)
            end, 0.05)
        end
    end, 0.015, 1)
end

function GMHelper:TeleportKillerBW(text)
    
    self.TeleportKillerBWEnabled = not self.TeleportKillerBWEnabled
    _G["togTeleportKillerBW"] = self.TeleportKillerBWEnabled
    refreshButtonColorSave("TeleportKillerBW")

    if self.TeleportKillerBWEnabled then
        SaveItem("TeleportKillerBW", "TeleportKillerBW")
    end
enabledeee = not enabledeee
    LuaTimer:cancel(TpKillTimer)

    if not enabledeee then
        UIHelper.showToast("^FF0000KillTP: Off")
        text:SetBackgroundColor({0, 0, 0, 0.8})
        return
    end

    UIHelper.showToast("^00FF00KillTP: On")
    text:SetBackgroundColor({0.8, 0.4, 0.0, 1})

    local me = PlayerManager:getClientPlayer()

    TpKillTimer = LuaTimer:scheduleTimer(function()
        local others = PlayerManager:getPlayers()
        local minDis = math.huge
        local target = nil

        for _, p in pairs(others) do
            if p ~= me and p:getTeamId() ~= me:getTeamId() and p:getHealth() > 0 then
                local dis = MathUtil:distanceSquare3d(p:getPosition(), me:getPosition())
                if dis < minDis then
                    minDis = dis
                    target = p
                end
            end
        end

        if target then
            local targetPos = target:getPosition()
            PacketSender:sendLuaCommonData("TeleportHallInitPos")
            setPosTest(targetPos)
            AttackTargetManager:attackEntity(target)
        end
    end, 5, -1)
end

local A = false
local callbackId

function GMHelper:TpClickBW(text)
    
    self.TpClickBWEnabled = not self.TpClickBWEnabled
    _G["togTpClickBW"] = self.TpClickBWEnabled
    refreshButtonColorSave("TpClickBW")

    if self.TpClickBWEnabled then
        SaveItem("TpClickBW", "TpClickBW")
    end
local function issue(event)
        if not A or not event then return end
        local VIP = _G["PlayerManager"]:getClientPlayer()
        if not VIP or not VIP.Player then return end

        local targetPos = _G["VectorUtil"].newVector3(event.x, event.y, event.z)
        if setPosTest then
            setPosTest(targetPos)
        end

        PacketSender:sendLuaCommonData("TeleportHallInitPos")
    end

    A = not A

    if A then
        callbackId = _G["Listener"].registerCallBack(_G["CEvents"].ClickToBlockEvent, issue)
        ClientHelper.putFloatPrefs("BlockReachDistance", 9999)
        text:SetBackgroundColor({0.8, 0.4, 0.0, 1})
        UIHelper.showToast("^00FF00Enabled")
    else
        if callbackId then
            _G["Listener"].unregisterCallBack(_G["CEvents"].ClickToBlockEvent, callbackId)
            callbackId = nil
        end
        ClientHelper.putFloatPrefs("EntityReachDistance", 7)
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
    end
end

function GMHelper:QuickPlaceBlock(text)

    self.QuickPlaceBlockEnabled = not self.QuickPlaceBlockEnabled
    _G["togQuickPlaceBlock"] = self.QuickPlaceBlockEnabled
    refreshButtonColorSave("QuickPlaceBlock")

    if self.QuickPlaceBlockEnabled then
        SaveItem("QuickPlaceBlock", "QuickPlaceBlock")
    end
T = not T
text:SetBackgroundColor({0, 0, 0, 0.8})
UIHelper.showToast("^FF0000Disabled")
LuaTimer:cancel(self.block)
if T then
text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
UIHelper.showToast("^00FF00Enabled")
self.block = LuaTimer:scheduleTimer(function()
ClientHelper.putIntPrefs("QuicklyBuildBlockNum", 5)
end, 0.10, -1)
end
end

function GMHelper:NoFall(text)

    self.NoFallEnabled = not self.NoFallEnabled
    _G["togNoFall"] = self.NoFallEnabled
    refreshButtonColorSave("NoFall")

    if self.NoFallEnabled then
        SaveItem("NoFall", "NoFall")
    end
U = not U
LuaTimer:cancel(self.fall)
ClientHelper.putIntPrefs("SprintLimitCheck", 0)
text:SetBackgroundColor({0, 0, 0, 0.8})
UIHelper.showToast("^FF0000Disabled")
if U then
text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
UIHelper.showToast("^00FF00Enabled")
self.fall = LuaTimer:scheduleTimer(function()
ClientHelper.putIntPrefs("SprintLimitCheck", 1) 
end, 0.10, -1)
end
end

function GMHelper:Skate(text)
    
    self.SkateEnabled = not self.SkateEnabled
    _G["togSkate"] = self.SkateEnabled
    refreshButtonColorSave("Skate")

    if self.SkateEnabled then
        SaveItem("Skate", "Skate")
    end
A = not A
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
        self.data.color = Color.BLACK
        PlayerManager:getClientPlayer().Player:setBoolProperty("DisableUpdateAnimState", false)
    if A then
        GUIGMControlPanel:hide()
        PlayerManager:getClientPlayer().Player:setBoolProperty("DisableUpdateAnimState", true)
        text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
        UIHelper.showToast("^00FF00Enabled")
    end
end

function GMHelper:Blink(text)
    
    self.BlinkEnabled = not self.BlinkEnabled
    _G["togBlink"] = self.BlinkEnabled
    refreshButtonColorSave("Blink")

    if self.BlinkEnabled then
        SaveItem("Blink", "Blink")
    end
A = not A
        text:SetBackgroundColor({0, 0, 0, 0.8})
        self.data.color = Color.BLACK
        UIHelper.showToast("^FF0000Disabled")
        ClientHelper.putBoolPrefs("SyncClientPositionToServer", true)
    if A then
        text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
        UIHelper.showToast("^00FF00Enabled")
        ClientHelper.putBoolPrefs("SyncClientPositionToServer", false)
    end
end

local FastJumpToggle = false
local FastJumpPerm = nil

function GMHelper:FastJump(text)
    
    self.FastJumpEnabled = not self.FastJumpEnabled
    _G["togFastJump"] = self.FastJumpEnabled
    refreshButtonColorSave("FastJump")

    if self.FastJumpEnabled then
        SaveItem("FastJump", "FastJump")
    end
FastJumpToggle = not FastJumpToggle
    local player = PlayerManager:getClientPlayer()
    if not player or not player.Player then return end

    if FastJumpToggle then
        text:SetBackgroundColor({0.8, 0.4, 0.0, 1})
        UIHelper.showToast("^00FF00Enabled")
        ClientHelper.putBoolPrefs("EnableDoubleJumps", true)

        if FastJumpPerm then
            LuaTimer:cancel(FastJumpPerm)
        end

        FastJumpPerm = LuaTimer:scheduleTimer(function()
            local p = PlayerManager:getClientPlayer()
            if p and p.Player then
                p.Player.m_keepJumping = false
            end
        end, 0.05, -1)
    else
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
        ClientHelper.putBoolPrefs("EnableDoubleJumps", false)
        if FastJumpPerm then
            LuaTimer:cancel(FastJumpPerm)
            FastJumpPerm = nil
        end
        player.Player.m_keepJumping = true
    end
end

function GMHelper:StopPlayers(text)
    
    self.StopPlayersEnabled = not self.StopPlayersEnabled
    _G["togStopPlayers"] = self.StopPlayersEnabled
    refreshButtonColorSave("StopPlayers")

    if self.StopPlayersEnabled then
        SaveItem("StopPlayers", "StopPlayers")
    end
self._allPlayersStopped = not self._allPlayersStopped

    if self._allPlayersStopped then
        -- Set active state visual feedback
        text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
        UIHelper.showToast("^00FF00Enabled")

        -- Start the freeze timer with proper error handling
        self._freezeAllPacketTimer = LuaTimer:scheduleTimer(function()
            -- Get all players using ClientPlayer if available
            local players = {}
            if ClientPlayer and ClientPlayer.getAllPlayers then
                players = ClientPlayer:getAllPlayers()
            elseif PlayerManager and PlayerManager.getAllPlayers then
                players = PlayerManager:getAllPlayers()
            else
                -- Fallback method if neither is available
                print("Warning: No player manager available")
                return
            end

            -- Process each player
            for i = 1, #players do
                local player = players[i]
                
                -- Enhanced validation
                if player and player:isValid() then
                    -- Skip local player to avoid self-freeze
                    local isLocalPlayer = false
                    if player.isLocalPlayer then
                        isLocalPlayer = player:isLocalPlayer()
                    elseif ClientPlayer and ClientPlayer.getLocalPlayer then
                        local localPlayer = ClientPlayer:getLocalPlayer()
                        isLocalPlayer = (localPlayer and player:getEntityId() == localPlayer:getEntityId())
                    end
                    
                    if not isLocalPlayer then
                        -- Create zero motion vector
                        local motion
                        if VectorUtil and VectorUtil.newVector3 then
                            motion = VectorUtil.newVector3(0, 0, 0)
                        else
                            -- Fallback vector creation
                            motion = { x = 0, y = 0, z = 0 }
                        end

                        -- Create and send velocity packet with error handling
                        local success, packet = pcall(function()
                            if CPacketPlayerVelocity and CPacketPlayerVelocity.new then
                                local pkt = CPacketPlayerVelocity.new()
                                pkt.entityId = player:getEntityId()
                                pkt.motion = motion
                                return pkt
                            else
                                error("CPacketPlayerVelocity not available")
                            end
                        end)

                        if success and packet then
                            -- Send packet with error handling
                            if PacketManager and PacketManager.sendPacket then
                                local sendSuccess, sendError = pcall(function()
                                    PacketManager:sendPacket(packet)
                                end)
                                
                                if not sendSuccess then
                                    print("Failed to send velocity packet for player " .. player:getEntityId() .. ": " .. tostring(sendError))
                                end
                            else
                                print("Warning: PacketManager not available")
                            end
                        else
                            print("Failed to create velocity packet: " .. tostring(packet))
                        end
                    end
                end
            end
        end, 50, -1) -- 50ms interval, infinite repetitions

    else
        -- Stop the freeze effect
        if self._freezeAllPacketTimer then
            LuaTimer:cancel(self._freezeAllPacketTimer)
            self._freezeAllPacketTimer = nil
        end

        -- Reset visual feedback
        if Color and Color.BLACK then
            text:SetBackgroundColor({0, 0, 0, 0.8})
            UIHelper.showToast("^FF0000Disabled")
        else
            text:SetBackgroundColor({ 0, 0, 0, 1 })
            UIHelper.showToast("^FF0000Disabled")
        end
    end
end

-- Optional: Add a cleanup function to prevent memory leaks
function GMHelper:cleanup()
    
    self.cleanupEnabled = not self.cleanupEnabled
    _G["togcleanup"] = self.cleanupEnabled
    refreshButtonColorSave("cleanup")

    if self.cleanupEnabled then
        SaveItem("cleanup", "cleanup")
    end
if self._freezeAllPacketTimer then
        LuaTimer:cancel(self._freezeAllPacketTimer)
        self._freezeAllPacketTimer = nil
    end
end

-- Optional: Add a method to check if players are currently stopped
function GMHelper:arePlayersStopped()
    
    self.arePlayersStoppedEnabled = not self.arePlayersStoppedEnabled
    _G["togarePlayersStopped"] = self.arePlayersStoppedEnabled
    refreshButtonColorSave("arePlayersStopped")

    if self.arePlayersStoppedEnabled then
        SaveItem("arePlayersStopped", "arePlayersStopped")
    end
return self._allPlayersStopped or false
end

function GMHelper:LagPlayers(text, lagType)
    
    self.LagPlayersEnabled = not self.LagPlayersEnabled
    _G["togLagPlayers"] = self.LagPlayersEnabled
    refreshButtonColorSave("LagPlayers")

    if self.LagPlayersEnabled then
        SaveItem("LagPlayers", "LagPlayers")
    end
lagType = lagType or "network"
    self._lagActive = not self._lagActive
    if self._lagActive then
        text:SetBackgroundColor({0.8, 0.4, 0.0, 1})
        UIHelper.showToast("^00FF00Enabled")
        if lagType == "network" then
            self:StartNetworkLag()
        elseif lagType == "fps" then
            self:StartFPSLag()
        elseif lagType == "mixed" then
            self:StartMixedLag()
        end
    else
        self:StopAllLag()
        if Color and Color.BLACK then
            text:SetBackgroundColor({0, 0, 0, 0.8})
            UIHelper.showToast("^FF0000Disabled")
        else
            text:SetBackgroundColor({0, 0, 0, 0.8})
            UIHelper.showToast("^FF0000Disabled")
        end
    end
end

function GMHelper:StartNetworkLag()
    
    self.StartNetworkLagEnabled = not self.StartNetworkLagEnabled
    _G["togStartNetworkLag"] = self.StartNetworkLagEnabled
    refreshButtonColorSave("StartNetworkLag")

    if self.StartNetworkLagEnabled then
        SaveItem("StartNetworkLag", "StartNetworkLag")
    end
self._networkLagTimer = LuaTimer:scheduleTimer(function()
        local players = self:GetAllPlayers()
        for i = 1, #players do
            local player = players[i]
            if player and player:isValid() and not self:IsLocalPlayer(player) then
                for j = 1, 5 do
                    pcall(function()
                        player:sendPacket({ pid = "ShowDarkMask" })
                    end)
                end
            end
        end
    end, 1, -1)
end

function GMHelper:StartFPSLag()
    
    self.StartFPSLagEnabled = not self.StartFPSLagEnabled
    _G["togStartFPSLag"] = self.StartFPSLagEnabled
    refreshButtonColorSave("StartFPSLag")

    if self.StartFPSLagEnabled then
        SaveItem("StartFPSLag", "StartFPSLag")
    end
self._fpsLagTimer = LuaTimer:scheduleTimer(function()
        local dummy = 0
        for i = 1, 10000 do
            dummy = dummy + math.sin(i) * math.cos(i) * math.sqrt(i)
            dummy = dummy % 1000000
        end
        local wasteMemory = {}
        for i = 1, 1000 do
            wasteMemory[i] = string.rep("lag", 100)
        end
        collectgarbage("collect")
    end, 16, -1)
end

function GMHelper:StartMixedLag()
    
    self.StartMixedLagEnabled = not self.StartMixedLagEnabled
    _G["togStartMixedLag"] = self.StartMixedLagEnabled
    refreshButtonColorSave("StartMixedLag")

    if self.StartMixedLagEnabled then
        SaveItem("StartMixedLag", "StartMixedLag")
    end
self:StartNetworkLag()
    self:StartFPSLag()
    self._randomFreezeTimer = LuaTimer:scheduleTimer(function()
        if math.random() > 0.7 then
            local freezeStart = os.clock()
            while (os.clock() - freezeStart) < 0.1 do end
        end
    end, 500, -1)
end

function GMHelper:IntensiveLag(text)
    
    self.IntensiveLagEnabled = not self.IntensiveLagEnabled
    _G["togIntensiveLag"] = self.IntensiveLagEnabled
    refreshButtonColorSave("IntensiveLag")

    if self.IntensiveLagEnabled then
        SaveItem("IntensiveLag", "IntensiveLag")
    end
self._intensiveLagActive = not self._intensiveLagActive
    if self._intensiveLagActive then
        text:SetBackgroundColor({1.0, 0.0, 0.0, 1})
        self._intensiveTimer1 = LuaTimer:scheduleTimer(function()
            local players = self:GetAllPlayers()
            for i = 1, #players do
                local player = players[i]
                if player and player:isValid() and not self:IsLocalPlayer(player) then
                    for j = 1, 20 do
                        pcall(function()
                            player:sendPacket({ pid = "ShowDarkMask" })
                        end)
                    end
                end
            end
        end, 1, -1)
        self._intensiveTimer2 = LuaTimer:scheduleTimer(function()
            local start = os.clock()
            while (os.clock() - start) < 0.05 do
                local dummy = 0
                for i = 1, 1000 do dummy = dummy + math.random() * math.pi end
            end
        end, 10, -1)
        self._intensiveTimer3 = LuaTimer:scheduleTimer(function()
            local waste = {}
            for i = 1, 5000 do waste[i] = string.rep(tostring(math.random()), 50) end
            collectgarbage("collect")
        end, 100, -1)
    else
        self:StopAllLag()
        text:SetBackgroundColor({0, 0, 0, 0.8})
    end
end

function GMHelper:GetAllPlayers()
    
    self.GetAllPlayersEnabled = not self.GetAllPlayersEnabled
    _G["togGetAllPlayers"] = self.GetAllPlayersEnabled
    refreshButtonColorSave("GetAllPlayers")

    if self.GetAllPlayersEnabled then
        SaveItem("GetAllPlayers", "GetAllPlayers")
    end
if ClientPlayer and ClientPlayer.getAllPlayers then
        return ClientPlayer:getAllPlayers()
    elseif PlayerManager and PlayerManager.getAllPlayers then
        return PlayerManager:getAllPlayers()
    else
        return {}
    end
end

function GMHelper:IsLocalPlayer(player)
    
    self.IsLocalPlayerEnabled = not self.IsLocalPlayerEnabled
    _G["togIsLocalPlayer"] = self.IsLocalPlayerEnabled
    refreshButtonColorSave("IsLocalPlayer")

    if self.IsLocalPlayerEnabled then
        SaveItem("IsLocalPlayer", "IsLocalPlayer")
    end
if player.isLocalPlayer then return player:isLocalPlayer()
    elseif ClientPlayer and ClientPlayer.getLocalPlayer then
        local localPlayer = ClientPlayer:getLocalPlayer()
        return (localPlayer and player:getEntityId() == localPlayer:getEntityId())
    end
    return false
end

function GMHelper:CreateRandomVector()
    
    self.CreateRandomVectorEnabled = not self.CreateRandomVectorEnabled
    _G["togCreateRandomVector"] = self.CreateRandomVectorEnabled
    refreshButtonColorSave("CreateRandomVector")

    if self.CreateRandomVectorEnabled then
        SaveItem("CreateRandomVector", "CreateRandomVector")
    end
if VectorUtil and VectorUtil.newVector3 then
        return VectorUtil.newVector3(
            (math.random() - 0.5) * 10,
            (math.random() - 0.5) * 10,
            (math.random() - 0.5) * 10
        )
    else
        return {
            x = (math.random() - 0.5) * 10,
            y = (math.random() - 0.5) * 10,
            z = (math.random() - 0.5) * 10
        }
    end
end

function GMHelper:StopAllLag()
    
    self.StopAllLagEnabled = not self.StopAllLagEnabled
    _G["togStopAllLag"] = self.StopAllLagEnabled
    refreshButtonColorSave("StopAllLag")

    if self.StopAllLagEnabled then
        SaveItem("StopAllLag", "StopAllLag")
    end
local timers = {
        "_networkLagTimer", "_fpsLagTimer", "_randomFreezeTimer",
        "_intensiveTimer1", "_intensiveTimer2", "_intensiveTimer3"
    }
    for _, timerName in ipairs(timers) do
        if self[timerName] then
            LuaTimer:cancel(self[timerName])
            self[timerName] = nil
        end
    end
    collectgarbage("collect")
end

function GMHelper:CleanupLag()
    
    self.CleanupLagEnabled = not self.CleanupLagEnabled
    _G["togCleanupLag"] = self.CleanupLagEnabled
    refreshButtonColorSave("CleanupLag")

    if self.CleanupLagEnabled then
        SaveItem("CleanupLag", "CleanupLag")
    end
self:StopAllLag()
    self._lagActive = false
    self._intensiveLagActive = false
end

function GMHelper:LightLag(text)
    
    self.LightLagEnabled = not self.LightLagEnabled
    _G["togLightLag"] = self.LightLagEnabled
    refreshButtonColorSave("LightLag")

    if self.LightLagEnabled then
        SaveItem("LightLag", "LightLag")
    end
self:CreateLag(text, "network")
end

function GMHelper:HeavyLag(text)
    
    self.HeavyLagEnabled = not self.HeavyLagEnabled
    _G["togHeavyLag"] = self.HeavyLagEnabled
    refreshButtonColorSave("HeavyLag")

    if self.HeavyLagEnabled then
        SaveItem("HeavyLag", "HeavyLag")
    end
self:CreateLag(text, "mixed")
end

function GMHelper:MaxLag(text)
    
    self.MaxLagEnabled = not self.MaxLagEnabled
    _G["togMaxLag"] = self.MaxLagEnabled
    refreshButtonColorSave("MaxLag")

    if self.MaxLagEnabled then
        SaveItem("MaxLag", "MaxLag")
    end
self:IntensiveLag(text)
end

function GMHelper:EquipNinjaShoes(text)
  
    self.EquipNinjaShoesEnabled = not self.EquipNinjaShoesEnabled
    _G["togEquipNinjaShoes"] = self.EquipNinjaShoesEnabled
    refreshButtonColorSave("EquipNinjaShoes")

    if self.EquipNinjaShoesEnabled then
        SaveItem("EquipNinjaShoes", "EquipNinjaShoes")
    end
local player = PlayerManager:getClientPlayer()
  EnableJump = not EnableJump

  if EnableJump then
    player.Player:setFloatProperty("JumpHeight", 0.50)
    player.doubleJumpCount = 3
    text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
    UIHelper.showToast("^00FF00Enabled")
  else
    player.Player:setFloatProperty("JumpHeight", 0.42)
    player.doubleJumpCount = 1
    text:SetBackgroundColor({0, 0, 0, 0.8})
    UIHelper.showToast("^FF0000Disabled")
  end
end

function GMHelper:AimBow(text)
    
    self.AimBowEnabled = not self.AimBowEnabled
    _G["togAimBow"] = self.AimBowEnabled
    refreshButtonColorSave("AimBow")

    if self.AimBowEnabled then
        SaveItem("AimBow", "AimBow")
    end
AimbowEnabled = not AimbowEnabled  

    if AimbowEnabled then
        LuaTimer:scheduleTimer(function()
            local clientPlayer = PlayerManager:getClientPlayer().Player
            local heldItemId = clientPlayer:getHeldItemId()
            
            if heldItemId == 261 then  
                local players = PlayerManager:getPlayers()
                local closestPlayer = nil
                local closestDistance = math.huge
                local myTeamId = clientPlayer:getTeamId()

                for _, targetPlayer in ipairs(players) do
                    if targetPlayer ~= clientPlayer and targetPlayer:getTeamId() ~= myTeamId then  
                        local distance = MathUtil:distanceSquare2d(targetPlayer:getPosition(), clientPlayer:getPosition())

                        if distance < closestDistance then
                            closestDistance = distance
                            closestPlayer = targetPlayer
                        end
                    end
                end

                if closestPlayer then
                    local dir = VectorUtil.sub3(closestPlayer:getPosition(), clientPlayer:getPosition())
                    local yaw = math.atan2(dir.x, dir.z) * -180 / math.pi
                    local distance = math.sqrt(dir.x * dir.x + dir.z * dir.z)
                    local pitch = -math.atan2(dir.y, distance) * 180 / math.pi

                    clientPlayer.rotationYaw = yaw
                    clientPlayer.rotationPitch = pitch
                end
            end
        end, 0.1, 0)
        text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
        UIHelper.showToast("^00FF00Enabled")
    else
        LuaTimer:cancel(self.timer)
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
    end
end

function GMHelper:Night(text)
   
    self.NightEnabled = not self.NightEnabled
    _G["togNight"] = self.NightEnabled
    refreshButtonColorSave("Night")

    if self.NightEnabled then
        SaveItem("Night", "Night")
    end
HostApi.setSky("fanxing")
   text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
   UIHelper.showToast("^00FF00Enabled")
end

function GMHelper:Day(text)
   
    self.DayEnabled = not self.DayEnabled
    _G["togDay"] = self.DayEnabled
    refreshButtonColorSave("Day")

    if self.DayEnabled then
        SaveItem("Day", "Day")
    end
HostApi.setSky("Qing")
   text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
   UIHelper.showToast("^00FF00Enabled")
end

function GMHelper:Evening(text)
   
    self.EveningEnabled = not self.EveningEnabled
    _G["togEvening"] = self.EveningEnabled
    refreshButtonColorSave("Evening")

    if self.EveningEnabled then
        SaveItem("Evening", "Evening")
    end
HostApi.setSky("Wanxia")
   text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
   UIHelper.showToast("^00FF00Enabled")
end

function GMHelper:Snow(text)
   
    self.SnowEnabled = not self.SnowEnabled
    _G["togSnow"] = self.SnowEnabled
    refreshButtonColorSave("Snow")

    if self.SnowEnabled then
        SaveItem("Snow", "Snow")
    end
HostApi.setSky("xue")
   text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
   UIHelper.showToast("^00FF00Enabled")
end

local function getHpColorByMissingHp(missingHp)
    if missingHp > 15 then
        return "▢FFFF1F1F"
    elseif missingHp > 5 then
        return "▢FFFFFF00"
    else
        return "▢FF00FF00"
    end
end

function GMHelper:ShowHp()
    self.ShowHpEnabled = not self.ShowHpEnabled
    _G["togShowHp"] = self.ShowHpEnabled
    refreshButtonColorSave("ShowHp")

    if self.ShowHpEnabled then
        SaveItem("ShowHp", "ShowHp")
    end

    UIHelper.showToast("^00FF00Enabled")

    self.ShowHpTimer = LuaTimer:scheduleTimer(function()
        for _, playerData in ipairs(PlayerManager:getPlayers() or {}) do
            local player = playerData.Player
            if player then
                local curHp = math.floor(player:getHealth() + 0.5)
                local maxHp = math.floor(player:getMaxHealth() + 0.5)
                local missingHp = maxHp - curHp

                local colorCode = getHpColorByMissingHp(missingHp)
                local hpLine = colorCode .. tostring(curHp) .. " ♥"

                local showName = player:getShowName() or ""
                local nameList = StringUtil.split(showName, "\n") or {}

                for i = #nameList, 1, -1 do
                    if string.find(nameList[i], "♥") then
                        table.remove(nameList, i)
                    end
                end

                table.insert(nameList, hpLine)
                player:setShowName(table.concat(nameList, "\n"))
            end
        end
    end, 50, -1)
end

function GMHelper:HideHp()
    UIHelper.showToast("^00FF00Enabled")

    if self.ShowHpTimer then
        LuaTimer:cancel(self.ShowHpTimer)
        self.ShowHpTimer = nil
    end

    for _, playerData in ipairs(PlayerManager:getPlayers() or {}) do
        local player = playerData.Player
        if player then
            local showName = player:getShowName() or ""
            local nameList = StringUtil.split(showName, "\n") or {}

            for i = #nameList, 1, -1 do
                if string.find(nameList[i], "♥") then
                    table.remove(nameList, i)
                end
            end

            player:setShowName(table.concat(nameList, "\n"))
        end
    end
end
function GMHelper:SetAimBot(text)
    
    self.SetAimBotEnabled = not self.SetAimBotEnabled
    _G["togSetAimBot"] = self.SetAimBotEnabled
    refreshButtonColorSave("SetAimBot")

    if self.SetAimBotEnabled then
        SaveItem("SetAimBot", "SetAimBot")
    end
GMHelper:openInput({ "Set Aimbot range (blocks)" }, function(inputRange)
        local range = tonumber(inputRange)
        if range and range > 0 then
            AimbotRange = range
            text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
            UIHelper.showToast("^00FF00Enabled")

            if self.timer then
                LuaTimer:cancel(self.timer)
            end

            self.timer = LuaTimer:scheduleTimer(function()
                local me = PlayerManager:getClientPlayer()
                if me then
                    local myPos = me.Player:getPosition()
                    local players = PlayerManager:getPlayers()
                    local closestDistance = math.huge
                    local closestPlayer = nil

                    for _, player in pairs(players) do
                        if player ~= me then
                            local playerPos = player:getPosition()
                            local distance = MathUtil:distanceSquare2d(playerPos, myPos)
                            if distance < closestDistance then
                                closestDistance = distance
                                closestPlayer = player
                            end
                        end
                    end

                    if closestPlayer and closestDistance < (AimbotRange * AimbotRange) then
                        local health = math.min(closestPlayer:getHealth(), 50.0)
                        UIHelper.showToast(string.format("^FF00EEPlayer's HP: %.1f ❤", health))

                        local camera = SceneManager.Instance():getMainCamera()
                        local pos = camera:getPosition()
                        local dir = VectorUtil.sub3(closestPlayer:getPosition(), pos)
                        local yaw = math.atan2(dir.x, dir.z) * -180 / math.pi
                        local distance2D = math.sqrt(dir.x * dir.x + dir.z * dir.z)
                        local pitch = -math.atan2(dir.y, distance2D) * 180 / math.pi

                        me.Player.rotationYaw = yaw or 0
                        me.Player.rotationPitch = pitch or 0
                    end
                end
            end, 1, 99999)
        else
            UIHelper.showToast("^FF0000Invalid range! Please enter a positive number.")
        end
    end)
end

function GMHelper:SetHighJump(text)
    
    self.SetHighJumpEnabled = not self.SetHighJumpEnabled
    _G["togSetHighJump"] = self.SetHighJumpEnabled
    refreshButtonColorSave("SetHighJump")

    if self.SetHighJumpEnabled then
        SaveItem("SetHighJump", "SetHighJump")
    end
GMHelper:openInput({ "Set new jump value" }, function(newHighJump)
        local player = PlayerManager:getClientPlayer()
        newHighJump = tonumber(newHighJump)
        if player and player.Player and newHighJump then
            player.Player:setFloatProperty("JumpHeight", newHighJump)
            text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
            UIHelper.showToast("^00FF00Enabled")
        end
    end)
end

function GMHelper:SetSpeed(text)
    
    self.SetSpeedEnabled = not self.SetSpeedEnabled
    _G["togSetSpeed"] = self.SetSpeedEnabled
    refreshButtonColorSave("SetSpeed")

    if self.SetSpeedEnabled then
        SaveItem("SetSpeed", "SetSpeed")
    end
GMHelper:openInput({ "Set new speed value" }, function(Number)
        PlayerManager:getClientPlayer().Player:setSpeedAdditionLevel(Number)
        text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
        UIHelper.showToast("^00FF00Enabled")
    end)
end

function GMHelper:SetMaxFPS(text)
    
    self.SetMaxFPSEnabled = not self.SetMaxFPSEnabled
    _G["togSetMaxFPS"] = self.SetMaxFPSEnabled
    refreshButtonColorSave("SetMaxFPS")

    if self.SetMaxFPSEnabled then
        SaveItem("SetMaxFPS", "SetMaxFPS")
    end
GMHelper:openInput({""}, function(FPS)
    CGame.Instance():SetMaxFps(FPS)
    text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
    UIHelper.showToast("^00FF00Enabled")
    end)
end
function GMHelper:SetHitBox(text)
    
    self.SetHitBoxEnabled = not self.SetHitBoxEnabled
    _G["togSetHitBox"] = self.SetHitBoxEnabled
    refreshButtonColorSave("SetHitBox")

    if self.SetHitBoxEnabled then
        SaveItem("SetHitBox", "SetHitBox")
    end
GMHelper:openInput({ "height", "width", "length" }, function(Num1, Num2, Num3)
        local players = PlayerManager:getPlayers()

        for _, player in ipairs(players) do
            local entity = player.Player

            if player ~= PlayerManager:getClientPlayer() then
                entity.height = Num1
                entity.width = Num2
                entity.length = Num3
            end
        end
        text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
        UIHelper.showToast("^00FF00Enabled")
    end)
end

function GMHelper:restValues(text)
    
    self.restValuesEnabled = not self.restValuesEnabled
    _G["togrestValues"] = self.restValuesEnabled
    refreshButtonColorSave("restValues")

    if self.restValuesEnabled then
        SaveItem("restValues", "restValues")
    end
SpeedValue = 1
    PlayerManager:getClientPlayer().Player:setSpeedAdditionLevel(SpeedValue)
    text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
    UIHelper.showToast("^00FF00Enabled")

    highJumpValue = 0.4
    local player = PlayerManager:getClientPlayer()
    if player and player.Player then
        player.Player:setFloatProperty("JumpHeight", highJumpValue)
    end

    AimBotValue = 0
    AimbotRange = nil
    if self.timer then
        LuaTimer:cancel(self.timer)
        self.timer = nil
    end

    local players = PlayerManager:getPlayers()
    for _, player in ipairs(players) do
        local entity = player.Player
        if player ~= PlayerManager:getClientPlayer() then
            entity.height = 2
            entity.width = 2
            entity.length = 2
        end
    end

    Blockman.Instance().m_gameSettings:setFovSetting(1.0)
end

function GMHelper:UpdatePlayerNickname(text)
    
    self.UpdatePlayerNicknameEnabled = not self.UpdatePlayerNicknameEnabled
    _G["togUpdatePlayerNickname"] = self.UpdatePlayerNicknameEnabled
    refreshButtonColorSave("UpdatePlayerNickname")

    if self.UpdatePlayerNicknameEnabled then
        SaveItem("UpdatePlayerNickname", "UpdatePlayerNickname")
    end
local isEnabled = true

    CustomDialog.builder()
    CustomDialog.setTitleText("Terms and Conditions")
    CustomDialog.setContentText("Please agree to the terms and conditions to continue.")
    CustomDialog.setRightText("Agree")
    CustomDialog.setLeftText("Cancel")
    GUIGMControlPanel:hide()
    
    CustomDialog.setRightClickListener(
        function()
            if isEnabled then
            local clientPlayer = PlayerManager:getClientPlayer()
            local playerEntity = clientPlayer.Player
            local fixedNickname = playerEntity:getEntityName()
            local formattedNickname = string.format("[S=vip_nameplate_1.json]&$[ff0000ff-ff7f00ff-ffff00ff-00ff00ff-00ffffff-0000ffff-7f00ffff]$%s$&", playerEntity:getEntityName())
            playerEntity:setShowName(formattedNickname)


                CustomDialog.builder()
                CustomDialog.setTitleText("Vip1")
                CustomDialog.setContentText("--> ^00FF00 Vip1 NameColor ^FFFFFF<--")
                CustomDialog.setRightText("Done")
                CustomDialog.setRightClickListener(
                    function()
                    end
                )
                CustomDialog.show()
            else
                text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
                UIHelper.showToast("Button is disabled.")
            end
        end
    )
    
    CustomDialog.setLeftClickListener(
        function()
            if isEnabled then
                UIHelper.showToast("Operation Cancelled")
            else
                UIHelper.showToast("Button is disabled.")
            end
        end
    )
    
    CustomDialog.show()
end

function GMHelper:UpdatePlayerNickname2(text)
    
    self.UpdatePlayerNickname2Enabled = not self.UpdatePlayerNickname2Enabled
    _G["togUpdatePlayerNickname2"] = self.UpdatePlayerNickname2Enabled
    refreshButtonColorSave("UpdatePlayerNickname2")

    if self.UpdatePlayerNickname2Enabled then
        SaveItem("UpdatePlayerNickname2", "UpdatePlayerNickname2")
    end
local isEnabled = true

    CustomDialog.builder()
    CustomDialog.setTitleText("Terms and Conditions")
    CustomDialog.setContentText("Please agree to the terms and conditions to continue.")
    CustomDialog.setRightText("Agree")
    CustomDialog.setLeftText("Cancel")
    GUIGMControlPanel:hide()
    
    CustomDialog.setRightClickListener(
        function()
            if isEnabled then
                text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
                UIHelper.showToast("^00FF00Enabled")
            local clientPlayer = PlayerManager:getClientPlayer()
            local playerEntity = clientPlayer.Player
            local fixedNickname = playerEntity:getEntityName()
            local formattedNickname = string.format("[S=vip_nameplate_2.json]&$[ff0000ff-ff7f00ff-ffff00ff-00ff00ff-00ffffff-0000ffff-7f00ffff]$%s$&", playerEntity:getEntityName())
            playerEntity:setShowName(formattedNickname)


                CustomDialog.builder()
                CustomDialog.setTitleText("Vip2")
                CustomDialog.setContentText("--> ^00FF00 Vip2 NameColor ^FFFFFF<--")
                CustomDialog.setRightText("Done")
                CustomDialog.setRightClickListener(
                    function()
                    end
                )
                CustomDialog.show()
            else
                UIHelper.showToast("Button is disabled.")
            end
        end
    )
    
    CustomDialog.setLeftClickListener(
        function()
            if isEnabled then
                UIHelper.showToast("Operation Cancelled")
            else
                UIHelper.showToast("Button is disabled.")
            end
        end
    )
    
    CustomDialog.show()
end

function GMHelper:UpdatePlayerNickname3(text)
    
    self.UpdatePlayerNickname3Enabled = not self.UpdatePlayerNickname3Enabled
    _G["togUpdatePlayerNickname3"] = self.UpdatePlayerNickname3Enabled
    refreshButtonColorSave("UpdatePlayerNickname3")

    if self.UpdatePlayerNickname3Enabled then
        SaveItem("UpdatePlayerNickname3", "UpdatePlayerNickname3")
    end
local isEnabled = true

    CustomDialog.builder()
    CustomDialog.setTitleText("Terms and Conditions")
    CustomDialog.setContentText("Please agree to the terms and conditions to continue.")
    CustomDialog.setRightText("Agree")
    CustomDialog.setLeftText("Cancel")
    GUIGMControlPanel:hide()
    
    CustomDialog.setRightClickListener(
        function()
            if isEnabled then
                text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
                UIHelper.showToast("^00FF00Enabled")
            local clientPlayer = PlayerManager:getClientPlayer()
            local playerEntity = clientPlayer.Player
            local fixedNickname = playerEntity:getEntityName()
            local formattedNickname = string.format("[S=vip_nameplate_3.json]&$[ff0000ff-ff7f00ff-ffff00ff-00ff00ff-00ffffff-0000ffff-7f00ffff]$%s$&", playerEntity:getEntityName())
            playerEntity:setShowName(formattedNickname)


                CustomDialog.builder()
                CustomDialog.setTitleText("Vip3")
                CustomDialog.setContentText("--> ^00FF00 Vip3 NameColor ^FFFFFF<--")
                CustomDialog.setRightText("Done")
                CustomDialog.setRightClickListener(
                    function()
                    end
                )
                CustomDialog.show()
            else
                UIHelper.showToast("Button is disabled.")
            end
        end
    )
    
    CustomDialog.setLeftClickListener(
        function()
            if isEnabled then
                UIHelper.showToast("Operation Cancelled")
            else
                UIHelper.showToast("Button is disabled.")
            end
        end
    )
    
    CustomDialog.show()
end

function GMHelper:UpdatePlayerNickname4(text)
    
    self.UpdatePlayerNickname4Enabled = not self.UpdatePlayerNickname4Enabled
    _G["togUpdatePlayerNickname4"] = self.UpdatePlayerNickname4Enabled
    refreshButtonColorSave("UpdatePlayerNickname4")

    if self.UpdatePlayerNickname4Enabled then
        SaveItem("UpdatePlayerNickname4", "UpdatePlayerNickname4")
    end
local isEnabled = true

    CustomDialog.builder()
    CustomDialog.setTitleText("Terms and Conditions")
    CustomDialog.setContentText("Please agree to the terms and conditions to continue.")
    CustomDialog.setRightText("Agree")
    CustomDialog.setLeftText("Cancel")
    GUIGMControlPanel:hide()
    
    CustomDialog.setRightClickListener(
        function()
            if isEnabled then
                text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
                UIHelper.showToast("^00FF00Enabled")
            local clientPlayer = PlayerManager:getClientPlayer()
            local playerEntity = clientPlayer.Player
            local fixedNickname = playerEntity:getEntityName()
            local formattedNickname = string.format("[S=vip_nameplate_4.json]&$[ff0000ff-ff7f00ff-ffff00ff-00ff00ff-00ffffff-0000ffff-7f00ffff]$%s$&", playerEntity:getEntityName())
            playerEntity:setShowName(formattedNickname)


                CustomDialog.builder()
                CustomDialog.setTitleText("Vip4")
                CustomDialog.setContentText("--> ^00FF00 Vip4 NameColor ^FFFFFF<--")
                CustomDialog.setRightText("Done")
                CustomDialog.setRightClickListener(
                    function()
                    end
                )
                CustomDialog.show()
            else
                UIHelper.showToast("Button is disabled.")
            end
        end
    )
    
    CustomDialog.setLeftClickListener(
        function()
            if isEnabled then
                UIHelper.showToast("Operation Cancelled")
            else
                UIHelper.showToast("Button is disabled.")
            end
        end
    )
    
    CustomDialog.show()
end

function GMHelper:UpdatePlayerNickname5(text)
    
    self.UpdatePlayerNickname5Enabled = not self.UpdatePlayerNickname5Enabled
    _G["togUpdatePlayerNickname5"] = self.UpdatePlayerNickname5Enabled
    refreshButtonColorSave("UpdatePlayerNickname5")

    if self.UpdatePlayerNickname5Enabled then
        SaveItem("UpdatePlayerNickname5", "UpdatePlayerNickname5")
    end
local isEnabled = true

    CustomDialog.builder()
    CustomDialog.setTitleText("Terms and Conditions")
    CustomDialog.setContentText("Please agree to the terms and conditions to continue.")
    CustomDialog.setRightText("Agree")
    CustomDialog.setLeftText("Cancel")
    GUIGMControlPanel:hide()
    
    CustomDialog.setRightClickListener(
        function()
            if isEnabled then
                text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
                UIHelper.showToast("^00FF00Enabled")
            local clientPlayer = PlayerManager:getClientPlayer()
            local playerEntity = clientPlayer.Player
            local fixedNickname = playerEntity:getEntityName()
            local formattedNickname = string.format("[S=vip_nameplate_5.json]&$[ff0000ff-ff7f00ff-ffff00ff-00ff00ff-00ffffff-0000ffff-7f00ffff]$%s$&", playerEntity:getEntityName())
            playerEntity:setShowName(formattedNickname)


                CustomDialog.builder()
                CustomDialog.setTitleText("Vip5")
                CustomDialog.setContentText("--> ^00FF00 Vip5 NameColor ^FFFFFF<--")
                CustomDialog.setRightText("Done")
                CustomDialog.setRightClickListener(
                    function()
                    end
                )
                CustomDialog.show()
            else
                UIHelper.showToast("Button is disabled.")
            end
        end
    )
    
    CustomDialog.setLeftClickListener(
        function()
            if isEnabled then
                UIHelper.showToast("Operation Cancelled")
            else
                UIHelper.showToast("Button is disabled.")
            end
        end
    )
    
    CustomDialog.show()
end

function GMHelper:UpdatePlayerNickname6(text)
    
    self.UpdatePlayerNickname6Enabled = not self.UpdatePlayerNickname6Enabled
    _G["togUpdatePlayerNickname6"] = self.UpdatePlayerNickname6Enabled
    refreshButtonColorSave("UpdatePlayerNickname6")

    if self.UpdatePlayerNickname6Enabled then
        SaveItem("UpdatePlayerNickname6", "UpdatePlayerNickname6")
    end
local isEnabled = true

    CustomDialog.builder()
    CustomDialog.setTitleText("Terms and Conditions")
    CustomDialog.setContentText("Please agree to the terms and conditions to continue.")
    CustomDialog.setRightText("Agree")
    CustomDialog.setLeftText("Cancel")
    GUIGMControlPanel:hide()
    
    CustomDialog.setRightClickListener(
        function()
            if isEnabled then
                text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
                UIHelper.showToast("^00FF00Enabled")
            local clientPlayer = PlayerManager:getClientPlayer()
            local playerEntity = clientPlayer.Player
            local fixedNickname = playerEntity:getEntityName()
            local formattedNickname = string.format("[S=vip_nameplate_6.json]&$[ff0000ff-ff7f00ff-ffff00ff-00ff00ff-00ffffff-0000ffff-7f00ffff]$%s$&", playerEntity:getEntityName())
            playerEntity:setShowName(formattedNickname)


                CustomDialog.builder()
                CustomDialog.setTitleText("Vip6")
                CustomDialog.setContentText("--> ^00FF00 Vip6 NameColor ^FFFFFF<--")
                CustomDialog.setRightText("Done")
                CustomDialog.setRightClickListener(
                    function()
                    end
                )
                CustomDialog.show()
            else
                UIHelper.showToast("Button is disabled.")
            end
        end
    )
    
    CustomDialog.setLeftClickListener(
        function()
            if isEnabled then
                UIHelper.showToast("Operation Cancelled")
            else
                UIHelper.showToast("Button is disabled.")
            end
        end
    )
    
    CustomDialog.show()
end

function GMHelper:UpdatePlayerNickname7(text)
    
    self.UpdatePlayerNickname7Enabled = not self.UpdatePlayerNickname7Enabled
    _G["togUpdatePlayerNickname7"] = self.UpdatePlayerNickname7Enabled
    refreshButtonColorSave("UpdatePlayerNickname7")

    if self.UpdatePlayerNickname7Enabled then
        SaveItem("UpdatePlayerNickname7", "UpdatePlayerNickname7")
    end
local isEnabled = true

    CustomDialog.builder()
    CustomDialog.setTitleText("Terms and Conditions")
    CustomDialog.setContentText("Please agree to the terms and conditions to continue.")
    CustomDialog.setRightText("Agree")
    CustomDialog.setLeftText("Cancel")
    GUIGMControlPanel:hide()
    
    CustomDialog.setRightClickListener(
        function()
            if isEnabled then
                text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
                UIHelper.showToast("^00FF00Enabled")
            local clientPlayer = PlayerManager:getClientPlayer()
            local playerEntity = clientPlayer.Player
            local fixedNickname = playerEntity:getEntityName()
            local formattedNickname = string.format("[S=vip_nameplate_7.json]&$[ff0000ff-ff7f00ff-ffff00ff-00ff00ff-00ffffff-0000ffff-7f00ffff]$%s$&", playerEntity:getEntityName())
            playerEntity:setShowName(formattedNickname)


                CustomDialog.builder()
                CustomDialog.setTitleText("Vip7")
                CustomDialog.setContentText("--> ^00FF00 Vip7 NameColor ^FFFFFF<--")
                CustomDialog.setRightText("Done")
                CustomDialog.setRightClickListener(
                    function()
                    end
                )
                CustomDialog.show()
            else
                UIHelper.showToast("Button is disabled.")
            end
        end
    )
    
    CustomDialog.setLeftClickListener(
        function()
            if isEnabled then
                UIHelper.showToast("Operation Cancelled")
            else
                UIHelper.showToast("Button is disabled.")
            end
        end
    )
    
    CustomDialog.show()
end

function GMHelper:UpdatePlayerNickname8(text)
    
    self.UpdatePlayerNickname8Enabled = not self.UpdatePlayerNickname8Enabled
    _G["togUpdatePlayerNickname8"] = self.UpdatePlayerNickname8Enabled
    refreshButtonColorSave("UpdatePlayerNickname8")

    if self.UpdatePlayerNickname8Enabled then
        SaveItem("UpdatePlayerNickname8", "UpdatePlayerNickname8")
    end
local isEnabled = true

    CustomDialog.builder()
    CustomDialog.setTitleText("Terms and Conditions")
    CustomDialog.setContentText("Please agree to the terms and conditions to continue.")
    CustomDialog.setRightText("Agree")
    CustomDialog.setLeftText("Cancel")
    GUIGMControlPanel:hide()
    
    CustomDialog.setRightClickListener(
        function()
            if isEnabled then
                text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
                UIHelper.showToast("^00FF00Enabled")
            local clientPlayer = PlayerManager:getClientPlayer()
            local playerEntity = clientPlayer.Player
            local fixedNickname = playerEntity:getEntityName()
            local formattedNickname = string.format("[S=vip_nameplate_8.json]&$[ff0000ff-ff7f00ff-ffff00ff-00ff00ff-00ffffff-0000ffff-7f00ffff]$%s$&", playerEntity:getEntityName())
            playerEntity:setShowName(formattedNickname)


                CustomDialog.builder()
                CustomDialog.setTitleText("Vip8")
                CustomDialog.setContentText("--> ^00FF00 Vip8 NameColor ^FFFFFF<--")
                CustomDialog.setRightText("Done")
                CustomDialog.setRightClickListener(
                    function()
                    end
                )
                CustomDialog.show()
            else
                UIHelper.showToast("Button is disabled.")
            end
        end
    )
    
    CustomDialog.setLeftClickListener(
        function()
            if isEnabled then
                UIHelper.showToast("Operation Cancelled")
            else
                UIHelper.showToast("Button is disabled.")
            end
        end
    )
    
    CustomDialog.show()
end

function GMHelper:UpdatePlayerNickname9(text)
    
    self.UpdatePlayerNickname9Enabled = not self.UpdatePlayerNickname9Enabled
    _G["togUpdatePlayerNickname9"] = self.UpdatePlayerNickname9Enabled
    refreshButtonColorSave("UpdatePlayerNickname9")

    if self.UpdatePlayerNickname9Enabled then
        SaveItem("UpdatePlayerNickname9", "UpdatePlayerNickname9")
    end
local isEnabled = true

    CustomDialog.builder()
    CustomDialog.setTitleText("Terms and Conditions")
    CustomDialog.setContentText("Please agree to the terms and conditions to continue.")
    CustomDialog.setRightText("Agree")
    CustomDialog.setLeftText("Cancel")
    GUIGMControlPanel:hide()
    
    CustomDialog.setRightClickListener(
        function()
            if isEnabled then
                text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
                UIHelper.showToast("^00FF00Enabled")
            local clientPlayer = PlayerManager:getClientPlayer()
            local playerEntity = clientPlayer.Player
            local fixedNickname = playerEntity:getEntityName()
            local formattedNickname = string.format("[S=vip_nameplate_9.json]&$[ff0000ff-ff7f00ff-ffff00ff-00ff00ff-00ffffff-0000ffff-7f00ffff]$%s$&", playerEntity:getEntityName())
            playerEntity:setShowName(formattedNickname)


                CustomDialog.builder()
                CustomDialog.setTitleText("Vip9")
                CustomDialog.setContentText("--> ^00FF00 Vip9 NameColor ^FFFFFF<--")
                CustomDialog.setRightText("Done")
                CustomDialog.setRightClickListener(
                    function()
                    end
                )
                CustomDialog.show()
            else
                UIHelper.showToast("Button is disabled.")
            end
        end
    )
    
    CustomDialog.setLeftClickListener(
        function()
            if isEnabled then
                UIHelper.showToast("Operation Cancelled")
            else
                UIHelper.showToast("Button is disabled.")
            end
        end
    )
    
    CustomDialog.show()
end

function GMHelper:UpdatePlayerNickname10(text)
    
    self.UpdatePlayerNickname10Enabled = not self.UpdatePlayerNickname10Enabled
    _G["togUpdatePlayerNickname10"] = self.UpdatePlayerNickname10Enabled
    refreshButtonColorSave("UpdatePlayerNickname10")

    if self.UpdatePlayerNickname10Enabled then
        SaveItem("UpdatePlayerNickname10", "UpdatePlayerNickname10")
    end
local isEnabled = true

    CustomDialog.builder()
    CustomDialog.setTitleText("Terms and Conditions")
    CustomDialog.setContentText("Please agree to the terms and conditions to continue.")
    CustomDialog.setRightText("Agree")
    CustomDialog.setLeftText("Cancel")
    GUIGMControlPanel:hide()
    
    CustomDialog.setRightClickListener(
        function()
            if isEnabled then
                text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
                UIHelper.showToast("^00FF00Enabled")
            local clientPlayer = PlayerManager:getClientPlayer()
            local playerEntity = clientPlayer.Player
            local fixedNickname = playerEntity:getEntityName()
            local formattedNickname = string.format("[S=vip_nameplate_10.json]&$[ff0000ff-ff7f00ff-ffff00ff-00ff00ff-00ffffff-0000ffff-7f00ffff]$%s$&", playerEntity:getEntityName())
            playerEntity:setShowName(formattedNickname)


                CustomDialog.builder()
                CustomDialog.setTitleText("Vip10")
                CustomDialog.setContentText("--> ^00FF00 Vip10 NameColor ^FFFFFF<--")
                CustomDialog.setRightText("Done")
                CustomDialog.setRightClickListener(
                    function()
                    end
                )
                CustomDialog.show()
            else
                UIHelper.showToast("Button is disabled.")
            end
        end
    )
    
    CustomDialog.setLeftClickListener(
        function()
            if isEnabled then
                UIHelper.showToast("Operation Cancelled")
            else
                UIHelper.showToast("Button is disabled.")
            end
        end
    )
    
    CustomDialog.show()
end

function GMHelper:UpdatePlayerNickname11(text)
    
    self.UpdatePlayerNickname11Enabled = not self.UpdatePlayerNickname11Enabled
    _G["togUpdatePlayerNickname11"] = self.UpdatePlayerNickname11Enabled
    refreshButtonColorSave("UpdatePlayerNickname11")

    if self.UpdatePlayerNickname11Enabled then
        SaveItem("UpdatePlayerNickname11", "UpdatePlayerNickname11")
    end
local isEnabled = true

    CustomDialog.builder()
    CustomDialog.setTitleText("Terms and Conditions")
    CustomDialog.setContentText("Please agree to the terms and conditions to continue.")
    CustomDialog.setRightText("Agree")
    CustomDialog.setLeftText("Cancel")
    GUIGMControlPanel:hide()
    
    CustomDialog.setRightClickListener(
        function()
            if isEnabled then
                text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
                UIHelper.showToast("^00FF00Enabled")
            local clientPlayer = PlayerManager:getClientPlayer()
            local playerEntity = clientPlayer.Player
            local fixedNickname = playerEntity:getEntityName()
            local formattedNickname = string.format("[S=vip_nameplate_10_plus.json]&$[ff0000ff-ff7f00ff-ffff00ff-00ff00ff-00ffffff-0000ffff-7f00ffff]$%s$&", playerEntity:getEntityName())
            playerEntity:setShowName(formattedNickname)


                CustomDialog.builder()
                CustomDialog.setTitleText("Vip11")
                CustomDialog.setContentText("--> ^00FF00 Vip11 NameColor ^FFFFFF<--")
                CustomDialog.setRightText("Done")
                CustomDialog.setRightClickListener(
                    function()
                    end
                )
                CustomDialog.show()
            else
                UIHelper.showToast("Button is disabled.")
            end
        end
    )
    
    CustomDialog.setLeftClickListener(
        function()
            if isEnabled then
                UIHelper.showToast("Operation Cancelled")
            else
                UIHelper.showToast("Button is disabled.")
            end
        end
    )
    
    CustomDialog.show()
end

function GMHelper:TeleportKiller(btn)
    togTeleportKiller = not togTeleportKiller
    _G["togTeleportKiller"] = togTeleportKiller
    refreshButtonColorUI("TeleportKiller")

    if togTeleportKiller then
        createUIButton("Teleport Killer", "TeleportKiller")
        btn:SetBackgroundColor({0.8,0.4,0.0,1})
        UIHelper.showToast("^00FF00Enabled")
        CGame.Instance():handleTouchClick(800,360)
    else
        btn:SetBackgroundColor({0,0,0,0.8})
        UIHelper.showToast("^FF0000Disabled")
        LuaTimer:cancel(TpKillTimer)
        return
    end

    Blockman.Instance().m_gameSettings:setCollimatorMode(togTeleportKiller)
    local me       = PlayerManager:getClientPlayer()
    local cam      = SceneManager.Instance():getMainCamera()
    local moveDir  = VectorUtil.newVector3(0.0,2.0,0.0)
    local tpOffset = VectorUtil.newVector3(0.0,0.5,0.0)

    TpKillTimer = LuaTimer:scheduleTimer(function()
        local myPos, minDist, target = me:getPosition(), math.huge, nil
        local players = PlayerManager:getPlayers()

        for i=1,#players do
            local p = players[i]
            if p ~= me and p:getHealth() > 0 then
                local dist = MathUtil:distanceSquare3d(p:getPosition(), myPos)
                if dist < minDist then 
                    minDist, target = dist, p 
                end
            end
        end

        if target then
            local tPos  = target:getPosition()
            local tpPos = VectorUtil.add3(tPos, tpOffset)
            me.Player:setPosition(tpPos)
            me.Player:moveEntity(moveDir)
            local camPos = cam:getPosition()
            local dx,dy,dz = tPos.x - camPos.x, tPos.y - camPos.y + 1.5, tPos.z - camPos.z
            local hdist = math.sqrt(dx*dx + dz*dz)
            me.Player.rotationYaw   = math.atan2(dx, dz) * -57.2958
            me.Player.rotationPitch = -math.atan2(dy, hdist) * 57.2958
            self.entity:attackEntity(target:getEntityId(), true)
            CGame.Instance():handleTouchClick(800,360)
            UIHelper.showToast("Target: " .. target:getName() .. " " .. target:getHealth() .. "/" .. target:getMaxHealth())
        else
            local p = {}
            p['lock']=9e36
            p['lock2']=p['lock']+9e37
            p['vec3']=function(...) local b={...} return {x=b[1],y=b[2],z=b[3]} end
            me.Player:setPosition(p['vec3'](p['lock2'],p['lock2'],p['lock2']))
        end
    end, 5, -1)
end

function GMHelper:KillAura(btn)
    self.KillAuraEnabled = not self.KillAuraEnabled
    _G["togKillAura"] = self.KillAuraEnabled
    refreshButtonColorUI("KillAura")

    if self.KillAuraEnabled then
        createUIButton("KillAura", "KillAura")
        btn:SetBackgroundColor({0.8,0.4,0.0,1})
        UIHelper.showToast("^00FF00Enabled")
        self.KillAuraTimer = LuaTimer:scheduleTimer(function()
            local me = PlayerManager:getClientPlayer()
            if not me or not me.Player then return end
            local myPos = me.Player:getPosition()
            local myTeamId = me:getTeamId()
            local players = PlayerManager:getPlayers()
            local closestDistance = math.huge
            local closestPlayer = nil
            for _,player in pairs(players) do
                if player~=me and player.Player and player:getTeamId()~=myTeamId then
                    local playerPos = player.Player:getPosition()
                    local distance = MathUtil:distanceSquare2d(playerPos,myPos)
                    if distance<=75 then
                        closestDistance=distance
                        closestPlayer=player
                    end
                end
            end
            if closestPlayer then
                local entity = closestPlayer.Player
                if entity then
                    entity.width= 8
                    entity.length= 8
                    entity.height= 1.8
                    CGame.Instance():handleTouchClick(800,360)
                    UIHelper.showToast("^00FF00Info: "..(closestPlayer:getName() or "Unknown"))
                end
            end
        end,100,-1)
    else
        if self.KillAuraTimer then
            LuaTimer:cancel(self.KillAuraTimer)
            self.KillAuraTimer=nil
            btn:SetBackgroundColor({0,0,0,0.8})
            UIHelper.showToast("^FF0000Disabled")
        end
        local players = PlayerManager:getPlayers()
        for _,player in pairs(players) do
            if player.Player then
                player.Player.width= 0.6
                player.Player.length= 0.6
                player.Player.height= 1.8
            end
        end
    end
end

function GMHelper:FastBreak(btn)
    self.fastBreakEnabled = not self.fastBreakEnabled
    _G["togFastBreak"] = self.fastBreakEnabled
    refreshButtonColorUI("FastBreak")

    local blocksToHide = {66, 253, 1, 5, 10, 20, 35}

    if self.fastBreakEnabled then
        createUIButton("FastBreak", "FastBreak")
        btn:SetBackgroundColor({0.8,0.4,0.0,1})
        UIHelper.showToast("^00FF00Enabled")

        for _, blockId in ipairs(blocksToHide) do
            local block = cBlockManager.cGetBlockById(blockId)
            if block then block:setNeedRender(true) end
        end

        for blockId = 1, 40000 do
            local block = BlockManager.getBlockById(blockId)
            if block then block:setHardness(nil) end
        end
    else
        btn:SetBackgroundColor({0,0,0,0.8})
        UIHelper.showToast("^FF0000Disabled")

        for _, blockId in ipairs(blocksToHide) do
            local block = cBlockManager.cGetBlockById(blockId)
            if block then block:setNeedRender(true) end
        end

        for blockId = 1, 40000 do
            local block = BlockManager.getBlockById(blockId)
            if block then block:setHardness(1) end
        end
    end
end

function GMHelper:AimBot(btn)
    self.AimBotEnabled = not self.AimBotEnabled
    _G["togAimBot"] = self.AimBotEnabled
    refreshButtonColorUI("AimBot")

    LuaTimer:cancel(self.AimBotTimer)
    btn:SetBackgroundColor({0,0,0,0.8})
    UIHelper.showToast("^FF0000Disabled")

    if self.AimBotEnabled then
        createUIButton("AimBot", "AimBot")
        btn:SetBackgroundColor({0.8,0.4,0.0,1})
        UIHelper.showToast("^00FF00Enabled")

        self.AimBotTimer = LuaTimer:scheduleTimer(function()
            local me = PlayerManager:getClientPlayer()
            if not me or not me.Player then return end

            local myPos = me.Player:getPosition()
            local players = PlayerManager:getPlayers()

            local closestDistance, closestPlayer = math.huge, nil
            for _,player in pairs(players) do
                if player~=me and player:getHealth()>0 then
                    local playerPos = player:getPosition()
                    local distance = MathUtil:distanceSquare2d(playerPos,myPos)
                    if distance<closestDistance then
                        closestDistance, closestPlayer = distance, player
                    end
                end
            end

            if closestPlayer and closestDistance<10 then
                local health = math.min(closestPlayer:getHealth(),50.0)
                UIHelper.showToast("^FF00EEPlayers Hp: "..string.format("%.1f ❤",health))

                local camera = SceneManager.Instance():getMainCamera()
                local camPos = camera:getPosition()
                local dir = VectorUtil.sub3(closestPlayer:getPosition(), camPos)

                local yaw = math.atan2(dir.x,dir.z)/math.pi*-180
                local distXZ = math.sqrt(dir.x*dir.x+dir.z*dir.z)
                local pitch = -math.atan2(dir.y,distXZ)/math.pi*180

                me.Player.rotationYaw = yaw or 0
                me.Player.rotationPitch = pitch or 0
            end
        end,1,-1)
    end
end

function GMHelper:NoFallDmg(btn)
    self.noFallDamageEnabled = not self.noFallDamageEnabled
    _G["togNoFallDmg"] = self.noFallDamageEnabled
    createUIButton("No Fall Damage", "NoFallDmg")
    refreshButtonColorUI("NoFallDmg")

    local playerWrapper = PlayerManager:getClientPlayer()
    local player = playerWrapper and playerWrapper.Player
    if not player then return end

    if not self.noFallDamageEnabled then
        if self.noFallDamageTimer then
            LuaTimer:cancel(self.noFallDamageTimer)
            self.noFallDamageTimer = nil
        end
        if self.fallDamageProtectionTimer then
            LuaTimer:cancel(self.fallDamageProtectionTimer)
            self.fallDamageProtectionTimer = nil
        end
        player.noClip = false
        self.previousY = nil
        btn:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
        return
    end

    btn:SetBackgroundColor({0.8, 0.4, 0.0, 1})
    UIHelper.showToast("^00FF00Enabled")

    local FALL_THRESHOLD = 1.0
    local FALL_DISTANCE_MIN = 3
    local RANGE_CHECK = 2
    local SAFE_HEIGHT_OFFSET = 1.3
    local TEMP_BLOCK_Y_OFFSET = 0.1
    local TEMP_BLOCK_ID = 8

    self.noFallDamageTimer = LuaTimer:scheduleTimer(function()
        local pos = player:getPosition()
        if not pos then return end
        local currentY = pos.y
        if not self.previousY then
            self.previousY = currentY
            return
        end
        local isFalling = currentY < self.previousY - FALL_THRESHOLD
        player.noClip = isFalling
        self.previousY = currentY
    end, 80, -1)

    self.fallDamageProtectionTimer = LuaTimer:scheduleTimer(function()
        if not player or not player.fallDistance then return end
        local fallDistance = player.fallDistance
        if fallDistance <= FALL_DISTANCE_MIN then return end

        local pos = player:getPosition()
        if not pos then return end

        local foundBlock = false
        local blockBelow = nil

        for dy = 1, RANGE_CHECK do
            local checkPos = VectorUtil.newVector3(pos.x, pos.y - dy, pos.z)
            local blockId = EngineWorld:getBlockId(checkPos)
            if blockId and blockId ~= 0 then
                foundBlock = true
                blockBelow = checkPos
                break
            end
        end

        if foundBlock and pos.y <= blockBelow.y + 1.0 then
            player.noClip = true
            local safeY = blockBelow.y + SAFE_HEIGHT_OFFSET
            player:setPosition(VectorUtil.newVector3(pos.x, safeY, pos.z))
            local tempBlockPos = VectorUtil.newVector3(pos.x, safeY - TEMP_BLOCK_Y_OFFSET, pos.z)
            EngineWorld:setBlock(tempBlockPos, TEMP_BLOCK_ID)
            EngineWorld:setBlockToAir(tempBlockPos)
            player.noClip = false
        end
    end, 100, -1)
end

function GMHelper:TpMobs(text)
	
    self.TpMobsEnabled = not self.TpMobsEnabled
    _G["togTpMobs"] = self.TpMobsEnabled
    refreshButtonColorSave("TpMobs")

    if self.TpMobsEnabled then
        SaveItem("TpMobs", "TpMobs")
    end
    togTpMobs = not togTpMobs
	LuaTimer:cancel(teleportTimer)
	text:SetBackgroundColor({0, 0, 0, 0.8})
	UIHelper.showToast("^FF0000Disabled")

	if togTpMobs then
		teleportTimer = LuaTimer:scheduleTimer(function()
			local clientPos = PlayerManager:getClientPlayer().Player:getPosition()
			clientPos.y = clientPos.y + 2
			local entities = EntityCache:getAllEntity()
			for _, entity in pairs(entities) do
				if entity ~= PlayerManager:getClientPlayer() then
					entity.entity:setPosition(clientPos)
				end
			end
			text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
			UIHelper.showToast("^00FF00Enabled")
		end, 1, -1)
	else
		text:SetBackgroundColor({0, 0, 0, 0.8})
		UIHelper.showToast("^FF0000Disabled")
	end
end

function GMHelper:SoftBypassSpeed(text)
    
    self.SoftBypassSpeedEnabled = not self.SoftBypassSpeedEnabled
    _G["togSoftBypassSpeed"] = self.SoftBypassSpeedEnabled
    refreshButtonColorSave("SoftBypassSpeed")

    if self.SoftBypassSpeedEnabled then
        SaveItem("SoftBypassSpeed", "SoftBypassSpeed")
    end
local lp
    local p = PlayerManager:getClientPlayer()
    LuaTimer:scheduleTimer(function()
        if p and p.Player then
            local cp = {p:getPosition()}
            if not lp or cp[1]~=lp[1] or cp[2]~=lp[2] or cp[3]~=lp[3] then
                p.Player.m_longMoveBeginTime, p.Player.m_longMoveCnt = 0, 0
                ClientHelper.putIntPrefs("longMoveCnt", 0)
                ClientHelper.putIntPrefs("longMoveBeginTime", 0)
                p.m_inTheAirBeginTime, p.m_inTheAirCnt = 0, 0
                ClientHelper.putIntPrefs("InTheAirCntLimit", math.huge)
                ClientHelper.putIntPrefs("InTheAirTimeLimit", math.huge)
                Blockman.Instance():getPlayer().onGround = true
                Blockman.Instance():getPlayer().m_flyingByPulled = true
                lp = cp
            end
        end
    end, 10, -1)
    MsgSender.sendMsg("Speed bypass active")
    text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
end

function GMHelper:HideMe(text)

    self.HideMeEnabled = not self.HideMeEnabled
    _G["togHideMe"] = self.HideMeEnabled
    refreshButtonColorSave("HideMe")

    if self.HideMeEnabled then
        SaveItem("HideMe", "HideMe")
    end
text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
UIHelper.showToast("^00FF00Enabled")
local CRecordUtil = T(Global, "CRecordUtil")
    Listener.registerCallBack(CEvents.AttackEntityEvent, function(entityId)
    local player = PlayerManager:getPlayerByEntityId(entityId)
    if not player then
        return true
    end
        UIHelper.showToast("Enabled")
        return true
    end)
end

function GMHelper:InfShield(text)

    self.InfShieldEnabled = not self.InfShieldEnabled
    _G["togInfShield"] = self.InfShieldEnabled
    refreshButtonColorSave("InfShield")

    if self.InfShieldEnabled then
        SaveItem("InfShield", "InfShield")
    end
local params = {
    Time = 99999999999
}
local data = DataBuilder.new():fromTable(params):getData()
PacketSender:sendLuaCommonData("AddInvincibleState", data)
text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
UIHelper.showToast("^00FF00Enabled")
end

function GMHelper:AutoSell(text)

    self.AutoSellEnabled = not self.AutoSellEnabled
    _G["togAutoSell"] = self.AutoSellEnabled
    refreshButtonColorSave("AutoSell")

    if self.AutoSellEnabled then
        SaveItem("AutoSell", "AutoSell")
    end
alxjejsn=not alxjejsn
if alxjejsn then
encjaha=LuaTimer:scheduleTimer(function()
local params = {
            Area = "SellArea"
        }
        local data = DataBuilder.new():fromTable(params):getData()
        PacketSender:sendLuaCommonData("TeleportToArea", data)
        text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
        UIHelper.showToast("^00FF00Enabled")
end, 500, -1)
else
LuaTimer:cancel(encjaha)
text:SetBackgroundColor({0, 0, 0, 0.8})
UIHelper.showToast("^FF0000Disabled")
end end

function GMHelper:EditSize(text)

    self.EditSizeEnabled = not self.EditSizeEnabled
    _G["togEditSize"] = self.EditSizeEnabled
    refreshButtonColorSave("EditSize")

    if self.EditSizeEnabled then
        SaveItem("EditSize", "EditSize")
    end
GMHelper:openInput({""}, function(Lolq)
PacketSender:sendLuaCommonData("ConcealPower", tostring(Lolq))
text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
UIHelper.showToast("^00FF00Enabled")
end)
end

function GMHelper:EquipSun(text)

    self.EquipSunEnabled = not self.EquipSunEnabled
    _G["togEquipSun"] = self.EquipSunEnabled
    refreshButtonColorSave("EquipSun")

    if self.EquipSunEnabled then
        SaveItem("EquipSun", "EquipSun")
    end
local params = {
    ItemId = 607,
    selectMode = Define.SelectMode.Equip,
}
local data = DataBuilder.new():fromTable(params):getData()
PacketSender:sendLuaCommonData("ChangeHoldItemActor", data)
text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
UIHelper.showToast("^00FF00Enabled")
end

function GMHelper:EquipEarth(text)

    self.EquipEarthEnabled = not self.EquipEarthEnabled
    _G["togEquipEarth"] = self.EquipEarthEnabled
    refreshButtonColorSave("EquipEarth")

    if self.EquipEarthEnabled then
        SaveItem("EquipEarth", "EquipEarth")
    end
local params = {
    ItemId = 606,
    selectMode = Define.SelectMode.Equip,
}
local data = DataBuilder.new():fromTable(params):getData()
PacketSender:sendLuaCommonData("ChangeHoldItemActor", data)
text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
UIHelper.showToast("^00FF00Enabled")
end

function GMHelper:EquipAirCraft(text)

    self.EquipAirCraftEnabled = not self.EquipAirCraftEnabled
    _G["togEquipAirCraft"] = self.EquipAirCraftEnabled
    refreshButtonColorSave("EquipAirCraft")

    if self.EquipAirCraftEnabled then
        SaveItem("EquipAirCraft", "EquipAirCraft")
    end
local params = {
    ItemId = 605,
    selectMode = Define.SelectMode.Equip,
}
local data = DataBuilder.new():fromTable(params):getData()
PacketSender:sendLuaCommonData("ChangeHoldItemActor", data)
text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
UIHelper.showToast("^00FF00Enabled")
end

function GMHelper:ChangeSkinSim(text)

    self.ChangeSkinSimEnabled = not self.ChangeSkinSimEnabled
    _G["togChangeSkinSim"] = self.ChangeSkinSimEnabled
    refreshButtonColorSave("ChangeSkinSim")

    if self.ChangeSkinSimEnabled then
        SaveItem("ChangeSkinSim", "ChangeSkinSim")
    end
GMHelper:openInput({""}, function(skinidowo)
local data = DataBuilder.new():addParam("index", skinidowo):getData()
PacketSender:sendLuaCommonData("SelectSkin", data)
text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
UIHelper.showToast("^00FF00Enabled")
end) end

function GMHelper:HealSim(text)

    self.HealSimEnabled = not self.HealSimEnabled
    _G["togHealSim"] = self.HealSimEnabled
    refreshButtonColorSave("HealSim")

    if self.HealSimEnabled then
        SaveItem("HealSim", "HealSim")
    end
local data = DataBuilder.new():addParam("index", Define.SelectSkinType.Free):getData()
PacketSender:sendLuaCommonData("SelectSkin", data)
local data = DataBuilder.new():addParam("index", Define.SelectSkinType.Default):getData()
PacketSender:sendLuaCommonData("SelectSkin", data)
text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
UIHelper.showToast("^00FF00Enabled")
end

function GMHelper:RaketButton(text)
    
    self.RaketButtonEnabled = not self.RaketButtonEnabled
    _G["togRaketButton"] = self.RaketButtonEnabled
    refreshButtonColorSave("RaketButton")

    if self.RaketButtonEnabled then
        SaveItem("RaketButton", "RaketButton")
    end
P = not P
    local me = PlayerManager:getClientPlayer().Player

    if not P then
        me:setSpeedAdditionLevel(1)
        me:setAllowFlying(false)
        me:setFlying(false)
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
        GUIManager:getWindowByName("Main-BuildWar-Block"):SetVisible(false)
    else
        me:setAllowFlying(true)
        me:setFlying(true)
        PlayerManager:getClientPlayer().Player:setSpeedAdditionLevel(150000)
        text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
        UIHelper.showToast("^00FF00Enabled")
        GUIManager:getWindowByName("Main-BuildWar-Block"):SetVisible(true)

        GUIManager:getWindowByName("Main-BuildWar-Block", GUIType.Button):registerEvent(GUIEvent.ButtonClick, function()
            local moveDir = VectorUtil.newVector3(0.0, 1.35, 0.0)
            local me = PlayerManager:getClientPlayer().Player
            me:setAllowFlying(true)
            me:setFlying(true)
            me:moveEntity(moveDir)
            PlayerManager:getClientPlayer().Player:setSpeedAdditionLevel(150000)
            UIHelper.showToast("^00FF00ON")
        end)
    end
end

function GMHelper:Tracer(text)
    
    self.TracerEnabled = not self.TracerEnabled
    _G["togTracer"] = self.TracerEnabled
    refreshButtonColorSave("Tracer")

    if self.TracerEnabled then
        SaveItem("Tracer", "Tracer")
    end
P = not P
    if self.tracer then
        LuaTimer:cancel(self.tracer)
        self.tracer = nil
    end
    text:SetBackgroundColor({0, 0, 0, 0.8})
    UIHelper.showToast("^FF0000Disabled")
    PlayerManager:getClientPlayer().Player:deleteAllGuideArrow()
    if P then
        text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
        UIHelper.showToast("^00FF00Enabled")
        local me = PlayerManager:getClientPlayer()
        self.tracer = LuaTimer:scheduleTimer(function()
            PlayerManager:getClientPlayer().Player:deleteAllGuideArrow()
            local others = PlayerManager:getPlayers()
            for _, c_player in pairs(others) do
                if c_player ~= me then
                    me.Player:addGuideArrow(c_player:getPosition())
                end
            end
        end, 500, -1)
    end
end

do
    local respawnCallback = nil
    local togUnDeath = false

    function GMHelper:AutoRespawn(text)
        
    self.AutoRespawnEnabled = not self.AutoRespawnEnabled
    _G["togAutoRespawn"] = self.AutoRespawnEnabled
    refreshButtonColorSave("AutoRespawn")

    if self.AutoRespawnEnabled then
        SaveItem("AutoRespawn", "AutoRespawn")
    end
    togUnDeath = not togUnDeath

        if not togUnDeath then
            if respawnCallback then
                CEvents.LuaPlayerDeathEvent:unregisterCallBack(respawnCallback)
                respawnCallback = nil
            end
            text:SetBackgroundColor({0, 0, 0, 0.8})
            UIHelper.showToast("^FF0000Disabled")
            return
        end

        text:SetBackgroundColor({0.8, 0.4, 0.0, 1})
        UIHelper.showToast("^00FF00Enabled")

        respawnCallback = function(deadPlayerId)
            if deadPlayerId ~= CGame.Instance():getPlatformUserId() then
                return
            end

            local clientWrapper = PlayerManager:getClientPlayer()
            if not clientWrapper or not clientWrapper.Player then return end

            PacketSender:getSender():sendRebirth()
            PlayerManager:createClientPlayer()
            RootGuiLayout.Instance():showMainControl()
        end

        CEvents.LuaPlayerDeathEvent:registerCallBack(respawnCallback)
    end
end

local CONFIG = {
    TP_DELAY = 2,
    ATTACK_DELAY = 3,
    RETURN_DELAY = 5,
    CLOSE_RANGE = 8,
    MAX_RANGE = 50,
    Y_RANGE = 18,
    ATTACK_OFFSET = 1.0,
    REACH_DISTANCE = 50,
    ATTACK_TIMES = 999999999,
    DAMAGE_AMOUNT = 1.5,
    SMOOTH_ENABLED = true,
    INTERPOLATION_STEPS = 3,
    STEP_DELAY = 1,
    NO_CLIP_DURATION = 2,
    PACKET_ATTACK_COUNT = 8,
    MOVEMENT_PREDICTION = true,
    AUTO_AIM = true
}

local isEnabled = true
local activeAttacks = {}
local lastPlayerPositions = {}

local function safeGetPlayer()
    local wrapper = PlayerManager:getClientPlayer()
    return wrapper and wrapper.Player
end

local function getTargetPlayer(entityId)
    local wrapper = PlayerManager:getPlayerByEntityId(entityId)
    return wrapper and wrapper.Player
end

local function calculateDistance(pos1, pos2)
    if not pos1 or not pos2 then return math.huge end
    local dx, dy, dz = pos2.x - pos1.x, pos2.y - pos1.y, pos2.z - pos1.z
    return math.sqrt(dx*dx + dy*dy + dz*dz)
end

local function calculateDistanceXZ(pos1, pos2)
    if not pos1 or not pos2 then return math.huge end
    local dx, dz = pos2.x - pos1.x, pos2.z - pos1.z
    return math.sqrt(dx*dx + dz*dz)
end

local function isYRangeValid(pos1, pos2)
    if not pos1 or not pos2 then return false end
    return math.abs(pos2.y - pos1.y) <= CONFIG.Y_RANGE
end

local function predictPlayerMovement(entityId, currentPos)
    if not CONFIG.MOVEMENT_PREDICTION then return currentPos end
    
    local lastPos = lastPlayerPositions[entityId]
    if not lastPos then
        lastPlayerPositions[entityId] = currentPos
        return currentPos
    end
    
    local velocity = {
        x = currentPos.x - lastPos.x,
        y = currentPos.y - lastPos.y,
        z = currentPos.z - lastPos.z
    }
    
    local predictedPos = {
        x = currentPos.x + velocity.x * 0.5,
        y = currentPos.y + velocity.y * 0.3,
        z = currentPos.z + velocity.z * 0.5
    }
    
    lastPlayerPositions[entityId] = currentPos
    return predictedPos
end

local function findOptimalY(x, z, targetY)
    local safeY = math.max(targetY - 5, 5)
    local maxY = math.min(targetY + 10, 255)
    
    for y = targetY, maxY do
        local currentBlock = EngineWorld:getBlockId({x = math.floor(x), y = math.floor(y), z = math.floor(z)})
        local aboveBlock = EngineWorld:getBlockId({x = math.floor(x), y = math.floor(y + 1), z = math.floor(z)})
        local above2Block = EngineWorld:getBlockId({x = math.floor(x), y = math.floor(y + 2), z = math.floor(z)})
        
        if (not currentBlock or currentBlock == BlockID.AIR) and 
           (not aboveBlock or aboveBlock == BlockID.AIR) and 
           (not above2Block or above2Block == BlockID.AIR) then
            return y
        end
    end
    
    for y = targetY, safeY, -1 do
        local currentBlock = EngineWorld:getBlockId({x = math.floor(x), y = math.floor(y), z = math.floor(z)})
        local aboveBlock = EngineWorld:getBlockId({x = math.floor(x), y = math.floor(y + 1), z = math.floor(z)})
        local above2Block = EngineWorld:getBlockId({x = math.floor(x), y = math.floor(y + 2), z = math.floor(z)})
        
        if (not currentBlock or currentBlock == BlockID.AIR) and 
           (not aboveBlock or aboveBlock == BlockID.AIR) and 
           (not above2Block or above2Block == BlockID.AIR) then
            return y
        end
    end
    
    return targetY
end

local function instantTP(player, targetPos)
    if not player or not targetPos then return false end
    local safeY = findOptimalY(targetPos.x, targetPos.z, targetPos.y)
    local finalPos = VectorUtil.newVector3(targetPos.x, safeY, targetPos.z)
    
    player.noFakePlayer = true
    player:setPosition(finalPos)
    
    LuaTimer:scheduleTimer(function()
        if player then
            player.noFakePlayer = false
        end
    end, CONFIG.NO_CLIP_DURATION, 1)
    
    return true
end

local function smoothTP(player, startPos, endPos, callback)
    if not CONFIG.SMOOTH_ENABLED or not player or not startPos or not endPos then
        local success = instantTP(player, endPos)
        if callback then callback(success) end
        return
    end
    
    local steps = CONFIG.INTERPOLATION_STEPS
    local currentStep = 0
    player.noFakePlayer = true
    
    local function interpolateStep()
        if currentStep >= steps then
            local finalY = findOptimalY(endPos.x, endPos.z, endPos.y)
            player:setPosition(VectorUtil.newVector3(endPos.x, finalY, endPos.z))
            
            LuaTimer:scheduleTimer(function()
                if player then player.noFakePlayer = false end
            end, CONFIG.NO_CLIP_DURATION, 1)
            
            if callback then callback(true) end
            return
        end
        
        local t = currentStep / steps
        local smoothT = t * t * (3 - 2 * t)
        
        local interpPos = {
            x = startPos.x + (endPos.x - startPos.x) * smoothT,
            y = startPos.y + (endPos.y - startPos.y) * smoothT,
            z = startPos.z + (endPos.z - startPos.z) * smoothT
        }
        
        local safeY = findOptimalY(interpPos.x, interpPos.z, interpPos.y)
        player:setPosition(VectorUtil.newVector3(interpPos.x, safeY, interpPos.z))
        
        currentStep = currentStep + 1
        LuaTimer:scheduleTimer(interpolateStep, CONFIG.STEP_DELAY, 1)
    end
    
    interpolateStep()
end

local function sendAttackPacket(clientPlayer, targetPlayer, targetEntityId)
    local packetsent = false
    
    if ClientHelper and ClientHelper.sendPacket then
        local attackPackets = {
            {type = "PlayerAttack", entityId = targetEntityId, damage = CONFIG.DAMAGE_AMOUNT},
            {type = "EntityHit", entityId = targetEntityId, damage = CONFIG.DAMAGE_AMOUNT * 2},
            {type = "CombatHit", targetId = targetEntityId, damage = CONFIG.DAMAGE_AMOUNT},
            {type = "AttackEntity", entityId = targetEntityId, playerId = clientPlayer:getEntityId()},
            {type = "DamagePacket", target = targetEntityId, amount = CONFIG.DAMAGE_AMOUNT * 1.5}
        }
        
        for _, packet in ipairs(attackPackets) do
            local success = pcall(function()
                ClientHelper.sendPacket(packet.type, packet)
            end)
            if success then packetsent = true end
        end
    end
    
    if NetworkManager and NetworkManager.sendPacket then
        local networkPackets = {
            "tryAttackPlayer" .. targetEntityId,
            "tryHitPlayer" .. targetEntityId,
            "tryDamagePlayer" .. targetEntityId,
            "entityHurt" .. targetEntityId
        }
        
        for _, packetType in ipairs(networkPackets) do
            local success = pcall(function()
                NetworkManager.sendPacket(packetType, {
                    entityId = targetEntityId,
                    damage = CONFIG.DAMAGE_AMOUNT,
                    attackerId = clientPlayer:getEntityId()
                })
            end)
            if success then packetsent = true end
        end
    end
    
    return packetsent
end

local function forceAttack(clientPlayer, targetEntityId)
    ClientHelper.putFloatPrefs("EntityReachDistance", CONFIG.REACH_DISTANCE)
    ClientHelper.putBoolPrefs("EntityReachEnabled", true)
    ClientHelper.putIntPrefs("AttackCheatTimes", CONFIG.ATTACK_TIMES)
    ClientHelper.putBoolPrefs("NoAttackCooldown", true)
    
    clientPlayer:setIntProperty("AttackCheatTimes", CONFIG.ATTACK_TIMES)
    clientPlayer:setFloatProperty("EntityReachDistance", CONFIG.REACH_DISTANCE)
    clientPlayer:setBoolProperty("NoAttackCooldown", true)
    
    local targetPlayer = getTargetPlayer(targetEntityId)
    if not targetPlayer then return false, 0 end
    
    local attackSuccess = false
    local attackCount = 0
    
    for attempt = 1, CONFIG.PACKET_ATTACK_COUNT do
        local packetSuccess = sendAttackPacket(clientPlayer, targetPlayer, targetEntityId)
        if packetSuccess then
            attackSuccess = true
            attackCount = attackCount + 1
        end
        
        if clientPlayer.attackEntity then
            local success = pcall(function() clientPlayer:attackEntity(targetPlayer) end)
            if success then
                attackSuccess = true
                attackCount = attackCount + 1
            end
        end
        
        local damageMethods = {
            function() 
                return targetPlayer.hurt and pcall(function() 
                    targetPlayer:hurt(CONFIG.DAMAGE_AMOUNT) 
                end)
            end,
            function() 
                return targetPlayer.takeDamage and pcall(function() 
                    targetPlayer:takeDamage(CONFIG.DAMAGE_AMOUNT) 
                end)
            end,
            function()
                if targetPlayer.setHealth and targetPlayer.getHealth then
                    return pcall(function()
                        local health = targetPlayer:getHealth() or 100
                        targetPlayer:setHealth(math.max(0, health - CONFIG.DAMAGE_AMOUNT))
                    end)
                end
                return false
            end,
            function()
                if targetPlayer.entity and targetPlayer.entity.hurt then
                    return pcall(function() 
                        targetPlayer.entity:hurt(CONFIG.DAMAGE_AMOUNT) 
                    end)
                end
                return false
            end
        }
        
        for _, method in ipairs(damageMethods) do
            if method() then
                attackSuccess = true
                attackCount = attackCount + 1
            end
        end
        
        if CEvents then
            local events = {"PlayerAttackEvent", "AttackEntityEvent", "DamageEntityEvent", "CombatEvent"}
            for _, eventName in ipairs(events) do
                if CEvents[eventName] then
                    local success = pcall(function() CEvents[eventName]:fire(targetEntityId) end)
                    if success then
                        attackSuccess = true
                        attackCount = attackCount + 1
                    end
                end
            end
        end
        
        if attempt < CONFIG.PACKET_ATTACK_COUNT then
            LuaTimer:scheduleTimer(function() end, 1, 1)
        end
    end
    
    return attackSuccess, attackCount
end

local function getOptimalAttackPosition(targetPos, originalPos)
    local offsets = {
        {x = CONFIG.ATTACK_OFFSET, z = 0},
        {x = -CONFIG.ATTACK_OFFSET, z = 0},
        {x = 0, z = CONFIG.ATTACK_OFFSET},
        {x = 0, z = -CONFIG.ATTACK_OFFSET},
        {x = CONFIG.ATTACK_OFFSET * 0.8, z = CONFIG.ATTACK_OFFSET * 0.8},
        {x = -CONFIG.ATTACK_OFFSET * 0.8, z = -CONFIG.ATTACK_OFFSET * 0.8},
        {x = CONFIG.ATTACK_OFFSET * 0.8, z = -CONFIG.ATTACK_OFFSET * 0.8},
        {x = -CONFIG.ATTACK_OFFSET * 0.8, z = CONFIG.ATTACK_OFFSET * 0.8}
    }
    
    for _, offset in ipairs(offsets) do
        local pos = {
            x = targetPos.x + offset.x,
            y = targetPos.y,
            z = targetPos.z + offset.z
        }
        
        local blockId = EngineWorld:getBlockId({
            x = math.floor(pos.x),
            y = math.floor(pos.y),
            z = math.floor(pos.z)
        })
        
        if not blockId or blockId == BlockID.AIR then
            local safeY = findOptimalY(pos.x, pos.z, pos.y)
            pos.y = safeY
            return pos
        end
    end
    
    return {
        x = targetPos.x,
        y = findOptimalY(targetPos.x, targetPos.z, targetPos.y + 2),
        z = targetPos.z
    }
end

local function executeLongRangeAttack(clientPlayer, targetEntityId, originalPos, targetPos)
    local distance = calculateDistance(originalPos, targetPos)
    local distanceXZ = calculateDistanceXZ(originalPos, targetPos)
    
    if activeAttacks[targetEntityId] then
        UIHelper.showToast("Attack in progress", 1500, false, "fade", false)
        return
    end
    
    activeAttacks[targetEntityId] = true
    
    local predictedPos = predictPlayerMovement(targetEntityId, targetPos)
    local attackPos = getOptimalAttackPosition(predictedPos, originalPos)
    
    UIHelper.showToast("TP Strike: " .. math.floor(distanceXZ) .. "m (Y:" .. math.floor(math.abs(targetPos.y - originalPos.y)) .. ")", 2000, false, "bounce", true)
    
    LuaTimer:scheduleTimer(function()
        if not clientPlayer then
            activeAttacks[targetEntityId] = nil
            return
        end
        
        smoothTP(clientPlayer, originalPos, attackPos, function(tpSuccess)
            if tpSuccess then
                UIHelper.showToast("Position locked! Engaging...", 1500, false, "pulse", true)
                
                LuaTimer:scheduleTimer(function()
                    local attackSuccess, attackCount = forceAttack(clientPlayer, targetEntityId)
                    
                    if attackSuccess then
                        UIHelper.showToast("DEVASTATED! " .. attackCount .. " packet hits", 2500, false, "bounce", true)
                    else
                        UIHelper.showToast("Attack sequence executed", 1500, false, "fade", nil)
                    end
                    
                    LuaTimer:scheduleTimer(function()
                        smoothTP(clientPlayer, attackPos, originalPos, function(returnSuccess)
                            if returnSuccess then
                                UIHelper.showToast("Extracted successfully", 1500, false, "slide", true)
                            else
                                UIHelper.showToast("Return completed", 1500, false, "fade", nil)
                            end
                            activeAttacks[targetEntityId] = nil
                        end)
                    end, CONFIG.RETURN_DELAY, 1)
                end, CONFIG.ATTACK_DELAY, 1)
            else
                UIHelper.showToast("TP failed - Direct packet strike", 2000, false, "fade", false)
                local attackSuccess, attackCount = forceAttack(clientPlayer, targetEntityId)
                if attackSuccess then
                    UIHelper.showToast("Long-range packet hit! " .. attackCount .. " strikes", 2500, false, "pulse", true)
                end
                activeAttacks[targetEntityId] = nil
            end
        end)
    end, CONFIG.TP_DELAY, 1)
end

local function executeCloseRangeAttack(clientPlayer, targetEntityId, distance)
    ClientHelper.putFloatPrefs("EntityReachDistance", CONFIG.REACH_DISTANCE)
    ClientHelper.putIntPrefs("AttackCheatTimes", CONFIG.ATTACK_TIMES)
    ClientHelper.putBoolPrefs("NoAttackCooldown", true)
    
    clientPlayer:setIntProperty("AttackCheatTimes", CONFIG.ATTACK_TIMES)
    clientPlayer:setBoolProperty("NoAttackCooldown", true)
    
    local attackSuccess, attackCount = forceAttack(clientPlayer, targetEntityId)
    
    if attackSuccess then
        UIHelper.showToast("Close Strike! " .. attackCount .. " hits (" .. math.floor(distance) .. "m)", 2000, false, "bounce", true)
    else
        UIHelper.showToast("Close attack executed (" .. math.floor(distance) .. "m)", 1500, false, "fade", nil)
    end
end

function GMHelper:ReachPlayers(text)
    self.ReachPlayersEnabled = not self.ReachPlayersEnabled
    _G["togReachPlayers"] = self.ReachPlayersEnabled
    refreshButtonColorSave("ReachPlayers")
    if self.ReachPlayersEnabled and not ButtonRegistrySave["ReachPlayers"] then
        SaveItem("ReachPlayers", "ReachPlayers")
    end
    isEnabled = not isEnabled
    text:SetBackgroundColor(isEnabled and {0.8,0.4,0.0,1} or {0,0,0,0.8})
    if not isEnabled then
        activeAttacks = {}
        lastPlayerPositions = {}
        UIHelper.showToast("Enhanced TP Reach DISABLED", 2000, false, "fade", false)
        return
    end
    UIHelper.showToast("ADVANCED TP PACKET ATTACK ENABLED - Range: " .. CONFIG.MAX_RANGE .. "m", 3000, false, "bounce", true)
    CEvents.AttackEntityEvent:registerCallBack(function(targetEntityId)
        if not isEnabled then return end
        local clientPlayer = safeGetPlayer()
        if not clientPlayer then return end
        local targetPlayer = getTargetPlayer(targetEntityId)
        if not targetPlayer then return end
        local originalPos = clientPlayer:getPosition()
        local targetPos = targetPlayer:getPosition()
        if not originalPos or not targetPos then return end
        local distance = calculateDistance(originalPos, targetPos)
        local distanceXZ = calculateDistanceXZ(originalPos, targetPos)
        local isYValid = isYRangeValid(originalPos, targetPos)
        if not isYValid then
            UIHelper.showToast("Y-Range too high: " .. math.floor(math.abs(targetPos.y - originalPos.y)) .. " (max: " .. CONFIG.Y_RANGE .. ")", 2000, false, "fade", false)
            return
        end
        if distanceXZ <= CONFIG.CLOSE_RANGE then
            executeCloseRangeAttack(clientPlayer, targetEntityId, distance)
        elseif distanceXZ <= CONFIG.MAX_RANGE then
            executeLongRangeAttack(clientPlayer, targetEntityId, originalPos, targetPos)
        else
            UIHelper.showToast("OUT OF RANGE: " .. math.floor(distanceXZ) .. "m (Max: " .. CONFIG.MAX_RANGE .. "m)", 2000, false, "fade", false)
        end
    end)
end

function GMHelper:CleanupReachPlayers()
    self.CleanupReachPlayersEnabled = not self.CleanupReachPlayersEnabled
    _G["togCleanupReachPlayers"] = self.CleanupReachPlayersEnabled
    refreshButtonColorSave("CleanupReachPlayers")
    if self.CleanupReachPlayersEnabled and not ButtonRegistrySave["CleanupReachPlayers"] then
        SaveItem("CleanupReachPlayers", "CleanupReachPlayers")
    end
    isEnabled = false
    activeAttacks = {}
    lastPlayerPositions = {}
    ClientHelper.putFloatPrefs("EntityReachDistance", 4)
    ClientHelper.putBoolPrefs("EntityReachEnabled", false)
    ClientHelper.putIntPrefs("AttackCheatTimes", 1)
    ClientHelper.putBoolPrefs("NoAttackCooldown", false)
    UIHelper.showToast("Advanced TP Reach System Cleaned", 2500, false, "fade", true)
end

local savedPos = nil

local function setPosTest(targetPos)
    if targetPos.y < 10 then return end

    local clientWrapper = PlayerManager:getClientPlayer()
    if not clientWrapper or not clientWrapper.Player then return end
    local clientPlayer = clientWrapper.Player

    local myPos = clientPlayer:getPosition()
    local yaw = clientPlayer.rotationYaw
    local pitch = clientPlayer.rotationPitch

    local disTp = { x = targetPos.x - myPos.x, z = targetPos.z - myPos.z }
    local totalDistance = math.sqrt(disTp.x * disTp.x + disTp.z * disTp.z)

    UIHelper.showToast("Distance: " .. string.format("%.2f", totalDistance))

    if myPos.y < 165 then myPos.y = 165 end

    if math.abs(disTp.x) > 18 then
        myPos.x = myPos.x + (disTp.x > 0 and 18 or -18)
        clientPlayer:setPosition(myPos)
        LuaTimer:scheduleTimer(function()
            setPosTest(targetPos)
        end, 0.015, 1)
        return
    end

    if math.abs(disTp.z) > 18 then
        myPos.z = myPos.z + (disTp.z > 0 and 18 or -18)
        clientPlayer:setPosition(myPos)
        LuaTimer:scheduleTimer(function()
            setPosTest(targetPos)
        end, 0.015, 1)
        return
    end

    local function checkBlock(pos)
        while EngineWorld:getBlockId(pos) ~= BlockID.AIR do
            pos.y = pos.y + 1
            if pos.y > 256 then break end
        end
        return pos
    end

    targetPos = checkBlock(targetPos)
    local abovePos = VectorUtil.newVector3(targetPos.x, targetPos.y + 1.3, targetPos.z)

    clientPlayer.noClip = true
    clientPlayer:setPosition(abovePos)
    clientPlayer.noClip = false

    clientPlayer:setPosition(abovePos)
    clientPlayer.rotationYaw = yaw
    clientPlayer.rotationPitch = pitch

    clientPlayer:setVelocity(VectorUtil.newVector3(0, 0.3, 0))
    clientPlayer:setAllowFlying(false)
    clientPlayer:setFlying(false)

    LuaTimer:scheduleOnce(function()
        clientPlayer:setAllowFlying(false)
        clientPlayer:setFlying(false)
    end, 0.05)

    savedPos = abovePos

    for i = 1, 5 do
        LuaTimer:scheduleOnce(function()
            clientPlayer:setPosition(savedPos)
        end, i * 0.05)
    end
end

local TpClickActive = false
local TpClickCallbackId = nil

function GMHelper:TpClick(btn)
    self.TpClickEnabled = not self.TpClickEnabled
    _G["togTpClick"] = self.TpClickEnabled
    refreshButtonColorUI("TpClick")

    if self.TpClickEnabled then
        createUIButton("TpClick", "TpClick")
        btn:SetBackgroundColor({0.8,0.4,0.0,1})
        UIHelper.showToast("^00FF00Enabled")

        local function issue(event)
            if not self.TpClickEnabled or not event then return end
            local me = PlayerManager:getClientPlayer()
            if not me or not me.Player then return end
            local targetPos = VectorUtil.newVector3(event.x, event.y, event.z)
            setPosTest(targetPos)
        end

        TpClickCallbackId = Listener.registerCallBack(CEvents.ClickToBlockEvent, issue)
        ClientHelper.putFloatPrefs("BlockReachDistance", 9999)
    else
        btn:SetBackgroundColor({0,0,0,0.8})
        UIHelper.showToast("^FF0000Disabled")

        if TpClickCallbackId then
            Listener.unregisterCallBack(CEvents.ClickToBlockEvent, TpClickCallbackId)
            TpClickCallbackId = nil
        end
        ClientHelper.putFloatPrefs("BlockReachDistance", 7)
    end
end

function GMHelper:enableSprint(text)
    
    self.enableSprintEnabled = not self.enableSprintEnabled
    _G["togenableSprint"] = self.enableSprintEnabled
    refreshButtonColorSave("enableSprint")

    if self.enableSprintEnabled then
        SaveItem("enableSprint", "enableSprint")
    end
local player = PlayerManager:getClientPlayer().Player
    player:setSprinting(true)
    text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
    UIHelper.showToast("^00FF00Enabled")
end

function GMHelper:UnDeath(text)
    self.UnDeathEnabled = not self.UnDeathEnabled
    _G["togUnDeath"] = self.UnDeathEnabled
    refreshButtonColorUI("UnDeath")

    if not self._UnDeathState then
        self._UnDeathState = { lastRespawnTime = 0, callback = nil }
    end
    local state = self._UnDeathState

    if self.UnDeathEnabled then
        createUIButton("UnDeath", "UnDeath")
        text:SetBackgroundColor({0.8, 0.4, 0.0, 1})
        UIHelper.showToast("^00FF00Enabled")
    else
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
        if state.callback then
            CEvents.LuaPlayerDeathEvent:unregisterCallBack(state.callback)
            state.callback = nil
        end
        return
    end

    local cooldown, stepSize, safeHeight, maxHeight = 2000, 18, 165, 256
    local scheduleDelay, respawnDelay, syncDelay, syncRepeat, postRespawnDelay, playerOffset = 0.015, 400, 1, 1000, 0.05, 1.3

    local function nowMillis() return os.time() * 1000 end

    local function findSafePosition(pos)
        while EngineWorld:getBlockId(pos) ~= BlockID.AIR
           or EngineWorld:getBlockId(VectorUtil.newVector3(pos.x, pos.y + 1, pos.z)) ~= BlockID.AIR do
            pos.y = pos.y + 1
            if pos.y > maxHeight then break end
        end
        return pos
    end

    local function stepTowards(current, target, step)
        if math.abs(target - current) <= step then return target end
        return current + (target > current and step or -step)
    end

    local function moveToTarget(targetPos)
        local wrapper = PlayerManager:getClientPlayer()
        if not wrapper or not wrapper.Player then return end
        local player = wrapper.Player
        local currentPos = player:getPosition()
        if currentPos.y < safeHeight then currentPos.y = safeHeight end

        currentPos.x = stepTowards(currentPos.x, targetPos.x, stepSize)
        currentPos.z = stepTowards(currentPos.z, targetPos.z, stepSize)

        player:setPosition(currentPos)
        if currentPos.x ~= targetPos.x or currentPos.z ~= targetPos.z then
            LuaTimer:scheduleTimer(function() moveToTarget(targetPos) end, scheduleDelay, 1)
        else
            targetPos = findSafePosition(targetPos)
            local finalPos = VectorUtil.newVector3(targetPos.x, targetPos.y + playerOffset, targetPos.z)
            player.noClip = true
            player:setPosition(finalPos)
            player.noClip = false
            LuaTimer:scheduleOnce(function() ClientHelper.putBoolPrefs("SyncClientPositionToServer", true) end, postRespawnDelay)
        end
    end

    state.callback = function(deadPlayer)
        local currentTime = nowMillis()
        if deadPlayer ~= CGame.Instance():getPlatformUserId() then return end
        if currentTime - state.lastRespawnTime < cooldown then return end
        state.lastRespawnTime = currentTime

        LuaTimer:scheduleTimer(function()
            ClientHelper.putBoolPrefs("SyncClientPositionToServer", true)
        end, syncDelay, syncRepeat)

        local wrapper = PlayerManager:getClientPlayer()
        if not wrapper or not wrapper.Player then return end
        local player = wrapper.Player
        local savedPos = player:getPosition()

        if _G["PacketSender"] and _G["PacketSender"].getSender then
            _G["PacketSender"]:getSender():sendRebirth()
        end

        player:setAllowFlying(true)
        player:setFlying(true)

        LuaTimer:schedule(function()
            moveToTarget(VectorUtil.newVector3(savedPos.x, savedPos.y, savedPos.z))
        end, respawnDelay)
    end

    CEvents.LuaPlayerDeathEvent:registerCallBack(state.callback)
end

function GMHelper:GetDataPlayer(text)

    self.GetDataPlayerEnabled = not self.GetDataPlayerEnabled
    _G["togGetDataPlayer"] = self.GetDataPlayerEnabled
    refreshButtonColorSave("GetDataPlayer")

    if self.GetDataPlayerEnabled then
        SaveItem("GetDataPlayer", "GetDataPlayer")
    end
text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
UIHelper.showToast("^00FF00Enabled")
local player = PlayerManager:getClientPlayer()
CEvents.AttackEntityEvent:registerCallBack(function(entity)
local user = PlayerManager:getPlayerByEntityId(entity)
if user ~= nil then
player:sendPacket({ pid = "PlayerManager", data = user })
end end) end

function GMHelper:GetMyData(text)

    self.GetMyDataEnabled = not self.GetMyDataEnabled
    _G["togGetMyData"] = self.GetMyDataEnabled
    refreshButtonColorSave("GetMyData")

    if self.GetMyDataEnabled then
        SaveItem("GetMyData", "GetMyData")
    end
text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
UIHelper.showToast("^00FF00Enabled")
local player = PlayerManager:getClientPlayer()
player:sendPacket({ pid = "ClientPlayer", data = player })
end

function GMHelper:DropSpeed(text)

    self.DropSpeedEnabled = not self.DropSpeedEnabled
    _G["togDropSpeed"] = self.DropSpeedEnabled
    refreshButtonColorSave("DropSpeed")

    if self.DropSpeedEnabled then
        SaveItem("DropSpeed", "DropSpeed")
    end
text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
UIHelper.showToast("^00FF00Enabled")
UIHelper.showToast("^00FF00Enabled")
PlayerManager:getClientPlayer().m_reloadBulletInt = 9999999
end

GMHelper.knockBackEnabled = false
local knockback_distance = 0

function GMHelper:KnockBackPlayer(text)
    
    self.KnockBackPlayerEnabled = not self.KnockBackPlayerEnabled
    _G["togKnockBackPlayer"] = self.KnockBackPlayerEnabled
    refreshButtonColorSave("KnockBackPlayer")

    if self.KnockBackPlayerEnabled then
        SaveItem("KnockBackPlayer", "KnockBackPlayer")
    end
GMHelper.knockBackEnabled = not GMHelper.knockBackEnabled
    
    if text and text.SetBackgroundColor then
        if GMHelper.knockBackEnabled then
            text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
            UIHelper.showToast("^00FF00Enabled")
        else
            text:SetBackgroundColor({ 0.0, 0.0, 0.0, 0.8 })
            UIHelper.showToast("^FF0000Disabled")
        end
    end
    
    if GMHelper.knockBackEnabled then
        local player = PlayerManager:getClientPlayer()
        if player and player.Player then
            player.Player.m_knockBackCoefficient = 30000.0
        end
        
        local blockmanPlayer = Blockman.Instance():getPlayer()
        if blockmanPlayer then
            blockmanPlayer.m_knockBackCoefficient = 30.0
        end

        -- add rune knockback distance here
        if rune and rune.distance then
            knockback_distance = knockback_distance + rune.distance
        end
    else
        local player = PlayerManager:getClientPlayer()
        if player and player.Player then
            player.Player.m_knockBackCoefficient = 1.0
        end
        
        local blockmanPlayer = Blockman.Instance():getPlayer()
        if blockmanPlayer then
            blockmanPlayer.m_knockBackCoefficient = 1.0
        end
    end
end

function GMHelper:ModifyAllCarsSpeed(text)
    
    self.ModifyAllCarsSpeedEnabled = not self.ModifyAllCarsSpeedEnabled
    _G["togModifyAllCarsSpeed"] = self.ModifyAllCarsSpeedEnabled
    refreshButtonColorSave("ModifyAllCarsSpeed")

    if self.ModifyAllCarsSpeedEnabled then
        SaveItem("ModifyAllCarsSpeed", "ModifyAllCarsSpeed")
    end
self.ae = not self.ae
    local multiplier = 10
    local dragScale = 0.9
    local carIds = {1, 2, 3, 4, 5, 6, 7, 8, 9}

    if self.ae then
        for _, carId in ipairs(carIds) do
            local carSetting = CarSetting.getCarSetting(carId)
            if carSetting then
                self._carBackup[carId] = {
                    traction = carSetting.traction,
                    reverseTraction = carSetting.reverseTraction,
                    brakingForce = carSetting.brakingForce,
                    maxCentripetalForce = carSetting.maxCentripetalForce,
                    coefAirDrag = carSetting.coefAirDrag
                }
                carSetting.traction = carSetting.traction * multiplier
                carSetting.reverseTraction = carSetting.reverseTraction * multiplier
                carSetting.brakingForce = carSetting.brakingForce * multiplier
                carSetting.maxCentripetalForce = carSetting.maxCentripetalForce * multiplier
                carSetting.coefAirDrag = carSetting.coefAirDrag * dragScale
            end
        end
        text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
        UIHelper.showToast("^00FF00Enabled")
    else
        for _, carId in ipairs(carIds) do
            local carSetting = CarSetting.getCarSetting(carId)
            local backup = self._carBackup[carId]
            if carSetting and backup then
                carSetting.traction = backup.traction
                carSetting.reverseTraction = backup.reverseTraction
                carSetting.brakingForce = backup.brakingForce
                carSetting.maxCentripetalForce = backup.maxCentripetalForce
                carSetting.coefAirDrag = backup.coefAirDrag
            end
        end
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
    end
end

function GMHelper:JumpDpad(text)
    
    self.JumpDpadEnabled = not self.JumpDpadEnabled
    _G["togJumpDpad"] = self.JumpDpadEnabled
    refreshButtonColorSave("JumpDpad")

    if self.JumpDpadEnabled then
        SaveItem("JumpDpad", "JumpDpad")
    end
Zentex = not Zentex
    
    local jumpBtn = GUIManager:getWindowByName("MainControl-jump")
    if not jumpBtn then return end

    if Zentex then
        ClientHelper.putBoolPrefs("UseCenterJumpButton", true)
        text:SetBackgroundColor({0.8, 0.4, 0.0, 1})
        UIHelper.showToast("^00FF00Enabled")
        jumpBtn:SetNormalImage("set:jump_control.json image:jump_control.png")
        jumpBtn:SetPushedImage("set:jump_control.json image:jump_control.png")
        jumpBtn:SetVisible(true)
    else
        ClientHelper.putBoolPrefs("UseCenterJumpButton", false)
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
        jumpBtn:SetNormalImage("")
        jumpBtn:SetPushedImage("")
        jumpBtn:SetVisible(false)
    end
end

function GMHelper:ItemThief(text)
    self.ItemThiefEnabled = not self.ItemThiefEnabled
    _G["togItemThief"] = self.ItemThiefEnabled
    refreshButtonColorSave("ItemThief")

    if self.ItemThiefEnabled then
        SaveItem("ItemThief", "ItemThief")
    end

    if self.ItemThiefEnabled then
        stealTimer = LuaTimer:scheduleTimer(function()
            local clientPlayerWrapper = PlayerManager:getClientPlayer()
            local clientPlayer = clientPlayerWrapper and clientPlayerWrapper.Player
            if not clientPlayer then return end
            
            local originalPos = clientPlayer:getPosition()
            local items = EntityCache:getAllEntity()
            local closestItem = nil
            local minDistance = math.huge
            
            for _, entity in pairs(items) do
                if entity.type == EntityType.Item then
                    local itemPos = entity.entity:getPosition()
                    local dx = originalPos.x - itemPos.x
                    local dz = originalPos.z - itemPos.z
                    local distance = math.sqrt(dx*dx + dz*dz)
                    if distance < minDistance then
                        closestItem = entity
                        minDistance = distance
                    end
                end
            end
            
            if closestItem then
                local targetPos = closestItem.entity:getPosition()
                targetPos.y = targetPos.y + 2

                local originalStepDelay = CONFIG.STEP_DELAY
                CONFIG.STEP_DELAY = 0.2
                
                smoothTP(clientPlayer, originalPos, targetPos, function(tpSuccess)
                    if tpSuccess then
                        UIHelper.showToast("Teleported to nearest item!", 1000, false, "bounce", true)

                        LuaTimer:scheduleTimer(function()
                            smoothTP(clientPlayer, targetPos, originalPos, function(returnSuccess)
                                if returnSuccess then
                                    UIHelper.showToast("Returned to original position", 1000, false, "slide", true)
                                else
                                    instantTP(clientPlayer, originalPos)
                                    UIHelper.showToast("Returned instantly", 1000, false, "fade", false)
                                end
                                CONFIG.STEP_DELAY = originalStepDelay
                            end)
                        end, 0.1, 1)
                        
                    else
                        instantTP(clientPlayer, targetPos)
                        UIHelper.showToast("TP failed, moved instantly", 1000, false, "fade", false)
                        CONFIG.STEP_DELAY = originalStepDelay
                    end
                end)
            else
                UIHelper.showToast("No items found nearby.", 1000, false, "fade", false)
            end
        end, 1, -1)
        
        UIHelper.showToast("Steal Item: ON", 1000, false, "pulse", true)
        text:SetBackgroundColor({0.8, 0.4, 0, 1})
    else
        LuaTimer:cancel(stealTimer)
        UIHelper.showToast("Steal Item: OFF", 1000, false, "fade", false)
        text:SetBackgroundColor({0, 0, 0, 0.8})
    end
end

function GMHelper:findNearestItem(pos)
    
    self.findNearestItemEnabled = not self.findNearestItemEnabled
    _G["togfindNearestItem"] = self.findNearestItemEnabled
    refreshButtonColorSave("findNearestItem")

    if self.findNearestItemEnabled then
        SaveItem("findNearestItem", "findNearestItem")
    end
local nearest = {entity = nil, dist = math.huge}
    local checked = 0
    
    for _, entity in pairs(EntityCache:getAllEntity()) do
        if entity.type == EntityType.Item and entity.entity then
            local dist = self:distance(pos, entity.entity:getPosition())
            if dist < 60 and dist < nearest.dist then
                nearest = {entity = entity.entity, dist = dist}
            end
            checked = checked + 1
            if checked >= 40 then break end
        end
    end
    
    return nearest.entity
end

function GMHelper:distance(p1, p2)
    
    self.distanceEnabled = not self.distanceEnabled
    _G["togdistance"] = self.distanceEnabled
    refreshButtonColorSave("distance")

    if self.distanceEnabled then
        SaveItem("distance", "distance")
    end
local dx, dz = p1.x - p2.x, p1.z - p2.z
    return math.sqrt(dx * dx + dz * dz)
end

function GMHelper:moveToward(current, target)
    
    self.moveTowardEnabled = not self.moveTowardEnabled
    _G["togmoveToward"] = self.moveTowardEnabled
    refreshButtonColorSave("moveToward")

    if self.moveTowardEnabled then
        SaveItem("moveToward", "moveToward")
    end
local dist = self:distance(current, target)
    
    if dist <= 0.8 then
        return {x = target.x, y = current.y, z = target.z}
    end
    
    local factor = math.min(1.5, dist) / dist
    
    return {
        x = current.x + (target.x - current.x) * factor,
        y = current.y,
        z = current.z + (target.z - current.z) * factor
    }
end

function GMHelper:DevNoClip(text)
   
    self.DevNoClipEnabled = not self.DevNoClipEnabled
    _G["togDevNoClip"] = self.DevNoClipEnabled
    refreshButtonColorSave("DevNoClip")

    if self.DevNoClipEnabled then
        SaveItem("DevNoClip", "DevNoClip")
    end
A = not A
    PlayerManager:getClientPlayer().Player.noClip = true
    text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
    UIHelper.showToast("^00FF00Enabled")
   if A then
    PlayerManager:getClientPlayer().Player.noClip = false
    text:SetBackgroundColor({0, 0, 0, 0.8})
    UIHelper.showToast("^FF0000Disabled")
end
end

function GMHelper:WaterPush(text)
    
    self.WaterPushEnabled = not self.WaterPushEnabled
    _G["togWaterPush"] = self.WaterPushEnabled
    refreshButtonColorSave("WaterPush")

    if self.WaterPushEnabled then
        SaveItem("WaterPush", "WaterPush")
    end
Zentex = not Zentex
    local entity = PlayerManager:getClientPlayer().Player
    entity:setBoolProperty("ignoreWaterPush", true)
    text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
    UIHelper.showToast("^00FF00Enabled")
	if Zentex then
    entity:setBoolProperty("ignoreWaterPush", false)
    text:SetBackgroundColor({0, 0, 0, 0.8})
    UIHelper.showToast("^FF0000Disabled")
end
end

function GMHelper:TeleportById()
   
    self.TeleportByIdEnabled = not self.TeleportByIdEnabled
    _G["togTeleportById"] = self.TeleportByIdEnabled
    refreshButtonColorSave("TeleportById")

    if self.TeleportByIdEnabled then
        SaveItem("TeleportById", "TeleportById")
    end
GMHelper:openInput({ "id player" }, function(ID)
  local player = PlayerManager:getClientPlayer().Player
    local Dplayer = PlayerManager:getPlayerByUserId(ID)
    if Dplayer then
        player:setPosition(Dplayer:getPosition())
    end
end)
end

function GMHelper:HideArmor(text)
   
    self.HideArmorEnabled = not self.HideArmorEnabled
    _G["togHideArmor"] = self.HideArmorEnabled
    refreshButtonColorSave("HideArmor")

    if self.HideArmorEnabled then
        SaveItem("HideArmor", "HideArmor")
    end
Zentex = not Zentex
   LogicSetting.Instance():setHideArmor(true)
    text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
    UIHelper.showToast("^00FF00Enabled")
  if Zentex then
   LogicSetting.Instance():setHideArmor(false)
    text:SetBackgroundColor({0, 0, 0, 0.8})
    UIHelper.showToast("^FF0000Disabled")
end
end

function GMHelper:HideHoldItem(text)
   
    self.HideHoldItemEnabled = not self.HideHoldItemEnabled
    _G["togHideHoldItem"] = self.HideHoldItemEnabled
    refreshButtonColorSave("HideHoldItem")

    if self.HideHoldItemEnabled then
        SaveItem("HideHoldItem", "HideHoldItem")
    end
A = not A
    PlayerManager:getClientPlayer():setHideHoldItem(true)
    text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
    UIHelper.showToast("^00FF00Enabled")
	if A then
	PlayerManager:getClientPlayer():setHideHoldItem(false)
    text:SetBackgroundColor({0, 0, 0, 0.8})
    UIHelper.showToast("^FF0000Disabled")
end
end

function GMHelper:FlyParachute(text)

    self.FlyParachuteEnabled = not self.FlyParachuteEnabled
    _G["togFlyParachute"] = self.FlyParachuteEnabled
    refreshButtonColorSave("FlyParachute")

    if self.FlyParachuteEnabled then
        SaveItem("FlyParachute", "FlyParachute")
    end
local moveDir = VectorUtil.newVector3(0.0, 1.35, 0.0)
  local player = PlayerManager:getClientPlayer()
  player.Player:setAllowFlying(true)
  player.Player:setFlying(true)
  player.Player:moveEntity(moveDir)
  PlayerManager:getClientPlayer().Player:startParachute()
  text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
  UIHelper.showToast("^00FF00Enabled")
end

function GMHelper:ShowAllControl(text)
    
    self.ShowAllControlEnabled = not self.ShowAllControlEnabled
    _G["togShowAllControl"] = self.ShowAllControlEnabled
    refreshButtonColorSave("ShowAllControl")

    if self.ShowAllControlEnabled then
        SaveItem("ShowAllControl", "ShowAllControl")
    end
RootGuiLayout.Instance():showMainControl()
    text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
    UIHelper.showToast("^00FF00Enabled")
end

function GMHelper:Strafe(text)
    
    self.StrafeEnabled = not self.StrafeEnabled
    _G["togStrafe"] = self.StrafeEnabled
    refreshButtonColorSave("Strafe")

    if self.StrafeEnabled then
        SaveItem("Strafe", "Strafe")
    end
Zentex = not Zentex
    ClientHelper.putBoolPrefs("DisableInertialFly", true)
    text:SetBackgroundColor({ 0.8, 0.4, 0.0, 1 })
    UIHelper.showToast("^00FF00Enabled")
	if Zentex then
	ClientHelper.putBoolPrefs("DisableInertialFly", false)
    text:SetBackgroundColor({0, 0, 0, 0.8})
    UIHelper.showToast("^FF0000Disabled")
end
end

function GMHelper:TpBackMyPos()
    
    self.TpBackMyPosEnabled = not self.TpBackMyPosEnabled
    _G["togTpBackMyPos"] = self.TpBackMyPosEnabled
    refreshButtonColorSave("TpBackMyPos")

    if self.TpBackMyPosEnabled then
        SaveItem("TpBackMyPos", "TpBackMyPos")
    end
local player = PlayerManager:getClientPlayer()
    if not player or not player.Player then
        UIHelper.showToast("^FF0000Error: Player not found")
        return
    else
--        text:SetBackgroundColor(Gey)
    UIHelper.showToast("^00FF00Enabled")
    end
    self.SavedPosition = player.Player:getPosition()
    UIHelper.showToast("^00FF00Position Saved: (" .. tostring(self.SavedPosition.x) .. ", " .. tostring(self.SavedPosition.y) .. ", " .. tostring(self.SavedPosition.z) .. ")")
end

function GMHelper:TeleportToSavedPosition()
    
    self.TeleportToSavedPositionEnabled = not self.TeleportToSavedPositionEnabled
    _G["togTeleportToSavedPosition"] = self.TeleportToSavedPositionEnabled
    refreshButtonColorSave("TeleportToSavedPosition")

    if self.TeleportToSavedPositionEnabled then
        SaveItem("TeleportToSavedPosition", "TeleportToSavedPosition")
    end
local moveDir = VectorUtil.newVector3(0, 0, 0)

    if not self.SavedPosition then
        UIHelper.showToast("^FF0000Error: No position saved")
        return
    end

    local player = PlayerManager:getClientPlayer()
    if not player or not player.Player then
        UIHelper.showToast("^FF0000Error: Player not found")
        return
    end

    local target = VectorUtil.newVector3(
        self.SavedPosition.x + moveDir.x,
        self.SavedPosition.y + moveDir.y,
        self.SavedPosition.z + moveDir.z
    )

    setPosTest(target)
    player.Player:setPosition(target)

    UIHelper.showToast("^00FF00Teleported to Saved Position: (" ..
        tostring(target.x) .. ", " ..
        tostring(target.y) .. ", " ..
        tostring(target.z) .. ")")
end

function GMHelper:LagPlayers(text, lagType)
    
    self.LagPlayersEnabled = not self.LagPlayersEnabled
    _G["togLagPlayers"] = self.LagPlayersEnabled
    refreshButtonColorSave("LagPlayers")

    if self.LagPlayersEnabled then
        SaveItem("LagPlayers", "LagPlayers")
    end
lagType = lagType or "network"
    self._lagActive = not self._lagActive
    if self._lagActive then
        text:SetBackgroundColor({0.8, 0.4, 0.0, 1})
        UIHelper.showToast("^00FF00Enabled")
        if lagType == "network" then
            self:StartNetworkLag()
        elseif lagType == "fps" then
            self:StartFPSLag()
        elseif lagType == "mixed" then
            self:StartMixedLag()
        end
    else
        self:StopAllLag()
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
    end
end

function GMHelper:StartNetworkLag()
    
    self.StartNetworkLagEnabled = not self.StartNetworkLagEnabled
    _G["togStartNetworkLag"] = self.StartNetworkLagEnabled
    refreshButtonColorSave("StartNetworkLag")

    if self.StartNetworkLagEnabled then
        SaveItem("StartNetworkLag", "StartNetworkLag")
    end
self._networkLagTimer = LuaTimer:scheduleTimer(function()
        pcall(function()
            PlayerManager:getClientPlayer():sendPacket({ pid = "ShowDarkMask" })
        end)
    end, 1, -1)
end

function GMHelper:StartFPSLag()
    
    self.StartFPSLagEnabled = not self.StartFPSLagEnabled
    _G["togStartFPSLag"] = self.StartFPSLagEnabled
    refreshButtonColorSave("StartFPSLag")

    if self.StartFPSLagEnabled then
        SaveItem("StartFPSLag", "StartFPSLag")
    end
self._fpsLagTimer = LuaTimer:scheduleTimer(function()
        local dummy = 0
        for i = 1, 10000 do
            dummy = dummy + math.sin(i) * math.cos(i) * math.sqrt(i)
            dummy = dummy % 1000000
        end
        local wasteMemory = {}
        for i = 1, 1000 do
            wasteMemory[i] = string.rep("lag", 100)
        end
        collectgarbage("collect")
    end, 16, -1)
end

function GMHelper:StartMixedLag()
    
    self.StartMixedLagEnabled = not self.StartMixedLagEnabled
    _G["togStartMixedLag"] = self.StartMixedLagEnabled
    refreshButtonColorSave("StartMixedLag")

    if self.StartMixedLagEnabled then
        SaveItem("StartMixedLag", "StartMixedLag")
    end
self:StartNetworkLag()
    self:StartFPSLag()
    self._randomFreezeTimer = LuaTimer:scheduleTimer(function()
        if math.random() > 0.7 then
            local freezeStart = os.clock()
            while (os.clock() - freezeStart) < 0.1 do end
        end
    end, 500, -1)
end

function GMHelper:IntensiveLag(text)
    
    self.IntensiveLagEnabled = not self.IntensiveLagEnabled
    _G["togIntensiveLag"] = self.IntensiveLagEnabled
    refreshButtonColorSave("IntensiveLag")

    if self.IntensiveLagEnabled then
        SaveItem("IntensiveLag", "IntensiveLag")
    end
self._intensiveLagActive = not self._intensiveLagActive
    if self._intensiveLagActive then
        text:SetBackgroundColor({1.0, 0.0, 0.0, 1})
        self._intensiveTimer1 = LuaTimer:scheduleTimer(function()
            for i = 1, 20 do
                pcall(function()
                    PlayerManager:getClientPlayer():sendPacket({ pid = "ShowDarkMask" })
                end)
            end
        end, 1, -1)
        self._intensiveTimer2 = LuaTimer:scheduleTimer(function()
            local start = os.clock()
            while (os.clock() - start) < 0.05 do
                local dummy = 0
                for i = 1, 1000 do dummy = dummy + math.random() * math.pi end
            end
        end, 10, -1)
        self._intensiveTimer3 = LuaTimer:scheduleTimer(function()
            local waste = {}
            for i = 1, 5000 do waste[i] = string.rep(tostring(math.random()), 50) end
            collectgarbage("collect")
        end, 100, -1)
    else
        self:StopAllLag()
        text:SetBackgroundColor({0, 0, 0, 0.8})
    end
end

function GMHelper:StopAllLag()
    
    self.StopAllLagEnabled = not self.StopAllLagEnabled
    _G["togStopAllLag"] = self.StopAllLagEnabled
    refreshButtonColorSave("StopAllLag")

    if self.StopAllLagEnabled then
        SaveItem("StopAllLag", "StopAllLag")
    end
local timers = {
        "_networkLagTimer", "_fpsLagTimer", "_randomFreezeTimer",
        "_intensiveTimer1", "_intensiveTimer2", "_intensiveTimer3"
    }
    for _, timerName in ipairs(timers) do
        if self[timerName] then
            LuaTimer:cancel(self[timerName])
            self[timerName] = nil
        end
    end
    collectgarbage("collect")
end

function GMHelper:CleanupLag()
    
    self.CleanupLagEnabled = not self.CleanupLagEnabled
    _G["togCleanupLag"] = self.CleanupLagEnabled
    refreshButtonColorSave("CleanupLag")

    if self.CleanupLagEnabled then
        SaveItem("CleanupLag", "CleanupLag")
    end
self:StopAllLag()
    self._lagActive = false
    self._intensiveLagActive = false
end

function GMHelper:LightLag(text)
    
    self.LightLagEnabled = not self.LightLagEnabled
    _G["togLightLag"] = self.LightLagEnabled
    refreshButtonColorSave("LightLag")

    if self.LightLagEnabled then
        SaveItem("LightLag", "LightLag")
    end
self:CreateLag(text, "network")
end

function GMHelper:HeavyLag(text)
    
    self.HeavyLagEnabled = not self.HeavyLagEnabled
    _G["togHeavyLag"] = self.HeavyLagEnabled
    refreshButtonColorSave("HeavyLag")

    if self.HeavyLagEnabled then
        SaveItem("HeavyLag", "HeavyLag")
    end
self:CreateLag(text, "mixed")
end

function GMHelper:MaxLag(text)
    
    self.MaxLagEnabled = not self.MaxLagEnabled
    _G["togMaxLag"] = self.MaxLagEnabled
    refreshButtonColorSave("MaxLag")

    if self.MaxLagEnabled then
        SaveItem("MaxLag", "MaxLag")
    end
self:IntensiveLag(text)
end

function GMHelper:AutoBridge(text)
    self.AutoBridgeEnabled = not self.AutoBridgeEnabled
    _G["togAutoBridge"] = self.AutoBridgeEnabled
    refreshButtonColorSave("AutoBridge")

    if self.AutoBridgeEnabled then
        SaveItem("AutoBridge", "AutoBridge")
    end

    AutoBridge = not AutoBridge
    self:cancelBlockTimer()

    if not AutoBridge then
        self:setBridgeUI(text, false)
        return
    end

    self:setBridgeUI(text, true)
    self:initModuleBlock()
    self:startBlockTimer()
end

function GMHelper:cancelBlockTimer()
    if self.block then
        LuaTimer:cancel(self.block)
        self.block = nil
    end
end

function GMHelper:setBridgeUI(text, enabled)
    if enabled then
        text:SetBackgroundColor({0.8, 0.4, 0.0, 1})
        UIHelper.showToast("^00FF00Enabled")
    else
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
    end
end

function GMHelper:startBlockTimer()
    self.block = LuaTimer:scheduleTimer(function()
        self:doAutoBridgeStep()
    end, 0.3, -1)
end

function GMHelper:doAutoBridgeStep()
    local player = PlayerManager:getClientPlayer()
    if not (player and player.Player) then return end

    local heldItem = player.Player:getHeldItemId()
    if not heldItem or heldItem < 3 or heldItem > 40000 then return end

    local cam = SceneManager.Instance():getMainCamera()
    local dir = cam:getDirection()
    local ok, buildPos, face = findFrontBlock(player, dir)

    if ok then
        self:tryPlaceBlock(player, buildPos, face, "autobridge")
    end

    CGame.Instance():handleTouchClick(860, 800)
    ClientHelper.putIntPrefs("QuicklyBuildBlockNum", 4)
end

function GMHelper:initModuleBlock()
    local ymlConfig = FileUtil.getGameConfigFromYml("module_block/ModuleBlock", true) or {}
    self.placeBlockMaxDepth = ymlConfig.placeBlockMaxDepth or 1
    self.placeBlockMaxBuildDistance = 4
    self.buildRoadModeMaxDistance = 4

    if isClient then
        ClientHelper.putIntPrefs("RunLimitCheck", ymlConfig.limitBlockCheckRun or 10)
        ClientHelper.putIntPrefs("SprintLimitCheck", ymlConfig.limitBlockCheckSprint or 10)
    end

    local csvConfig = FileUtil.getGameConfigFromCsv("module_block/ModuleBlock.csv", 2, true, true) or {}
    local Settings = {}
    for _, item in pairs(csvConfig) do
        local data = {
            id = tonumber(item.id),
            itemId = tonumber(item.itemId),
            teamId = tonumber(item.teamId) or 0,
            consumeNum = tonumber(item.consumeNum) or 1,
            schematic = item.schematic,
            offsetX = tonumber(item.offsetX) or 0,
            offsetZ = tonumber(item.offsetZ) or 0,
            image = item.image,
            extraParam = tonumber(item.extraParam) or 0,
        }
        Settings[data.itemId] = Settings[data.itemId] or {}
        table.insert(Settings[data.itemId], data)
    end

    for _, setting in pairs(Settings) do
        table.sort(setting, function(a,b) return a.id < b.id end)
    end
    self.Settings = Settings
end

function GMHelper:getModuleBlock(itemId, moduleId, teamId)
    local modules = self.Settings[itemId]
    if not modules then return nil end
    if moduleId and moduleId ~= 0 then
        for _, module in pairs(modules) do
            if module.id == moduleId then return module end
        end
    end
    for _, module in pairs(modules) do
        if module.teamId == teamId then return module end
    end
    if teamId ~= 0 then
        return self:getModuleBlock(itemId, moduleId, 0)
    end
    return nil
end

function GMHelper:getModuleBlocks(itemId)
    return self.Settings[itemId]
end

function GMHelper:getDefaultModuleId(itemId)
    local modules = self.Settings[itemId]
    return (modules and #modules > 0) and modules[1].id or 0
end

function GMHelper:hasModuleConfig()
    return not TableUtil.isEmpty(self.Settings)
end

local FaceOffset = {
    North = VectorUtil.newVector3(0,0,-1),
    South = VectorUtil.newVector3(0,0,1),
    West  = VectorUtil.newVector3(-1,0,0),
    East  = VectorUtil.newVector3(1,0,0),
}

local DiagonalOffset = {
    WestNorth = VectorUtil.newVector3(-1,0,-1),
    WestSouth = VectorUtil.newVector3(-1,0,1),
    EastNorth = VectorUtil.newVector3(1,0,-1),
    EastSouth = VectorUtil.newVector3(1,0,1),
}

local Face = { Upper=0, Under=1, North=3, South=2, West=5, East=4 }

local function checkCanPlaceBlock(pos)
    local blockId = EngineWorld:getBlockId(pos)
    local canAttach, canBuild, canPlace = {}, {}, false
    if blockId ~= BlockID.AIR and blockId ~= BlockID.SNOW then return canPlace, canAttach, canBuild end
    for name, offset in pairs(FaceOffset) do
        local newPos = VectorUtil.add3(pos, offset)
        local id = EngineWorld:getBlockId(newPos)
        if id ~= BlockID.AIR and id ~= BlockID.SNOW then
            canAttach[name] = newPos
            canPlace = true
        else
            table.insert(canBuild, newPos)
        end
    end
    for _, offset in pairs(DiagonalOffset) do
        local newPos = VectorUtil.add3(pos, offset)
        if EngineWorld:getBlockId(newPos) == 0 then table.insert(canBuild, newPos) end
    end
    return canPlace, canAttach, canBuild
end

local function findBuildPos(self, player, initPos, depth)
    depth = depth or 1
    if depth > (self.placeBlockMaxDepth or 1) then return false, nil, nil end
    local isCanPlace, attachList, buildList = checkCanPlaceBlock(initPos)
    local playerPos = VectorUtil.toBlockVector3(player:getPosition().x, player:getPosition().y, player:getPosition().z)
    if isCanPlace then
        local targetPos, targetFace
        local minDist = self.placeBlockMaxBuildDistance
        for name, attachPos in pairs(attachList) do
            local dist = VectorUtil.distance(attachPos, playerPos)
            if dist < minDist then
                minDist = dist
                targetPos, targetFace = attachPos, Face[name]
            end
        end
        return true, targetPos, targetFace
    else
        table.sort(buildList, function(a,b) return VectorUtil.distance(a, playerPos) < VectorUtil.distance(b, playerPos) end)
        for _, pos in pairs(buildList) do
            local ok, bp, face = findBuildPos(self, player, pos, depth + 1)
            if ok then return ok, bp, face end
        end
    end
    return false, nil, nil
end

function findFrontBlock(player, dir)
    local self = GMHelper
    local step = math.abs(dir.x) >= math.abs(dir.z) and VectorUtil.newVector3(dir.x>0 and 1 or -1,0,0)
                or VectorUtil.newVector3(0,0,dir.z>0 and 1 or -1)
    local playerPos = VectorUtil.toBlockVector3(player:getPosition().x, player:getPosition().y, player:getPosition().z)
    local startPos = VectorUtil.toBlockVector3(playerPos.x, playerPos.y-2, playerPos.z)
    local finalPos = startPos
    local isCanPlace = false
    for _=1,self.buildRoadModeMaxDistance do
        local blockID = EngineWorld:getBlockId(finalPos)
        if blockID == BlockID.AIR or blockID == BlockID.SNOW then
            local ok, pos, face = findBuildPos(self, player, finalPos, 1)
            if ok then return ok, pos, face end
        else
            finalPos = VectorUtil.add3(finalPos, step)
        end
    end
    for _, offset in pairs(FaceOffset) do
        local ok, pos, face = findBuildPos(self, player, VectorUtil.add3(startPos, offset), 1)
        if ok then return ok, pos, face end
    end
    return isCanPlace, finalPos, Face.North
end

function GMHelper:tryPlaceBlock(player, buildPos, face, source)
    if not buildPos or not face then return false end
    local inv = player:getInventory()
    if not inv then return end
    local itemStack = inv:getRealCurrentItem()
    if not itemStack then return false end
    local item = itemStack:getItem()
    if not item then return false end
    source = source or "screen"
    local placed = item:onItemUse(itemStack, Blockman.Instance():getPlayer(), Blockman.Instance():getWorld(), buildPos, face, buildPos)
    if placed then
        if itemStack:getItemStackSize()==0 then inv:decrStackSize(inv:findItemStack(itemStack),0) end
        player.Player:swingItem()
        player:sendPacket({pid="TryPlaceBlock", position=buildPos, face=face, source=source})
        return true
    end
    return false
end

function GMHelper:LongJump(text)
    
    self.LongJumpEnabled = not self.LongJumpEnabled
    _G["togLongJump"] = self.LongJumpEnabled
    refreshButtonColorSave("LongJump")

    if self.LongJumpEnabled then
        SaveItem("LongJump", "LongJump")
    end
ZentexEnabled = not ZentexEnabled
    local clientPlayer = PlayerManager:getClientPlayer()
    local player = clientPlayer and clientPlayer.Player

    if ZentexEnabled then
        SoundUtil.playSound(8)
        text:SetBackgroundColor({0.8, 0.4, 0.0, 1})
        UIHelper.showToast("^00FF00Enabled")
        if player then
            player:setFloatProperty("JumpSpeed", 25)
        end

        LuaTimer:cancel(self.timer)
        self.timer = LuaTimer:scheduleTimer(function()
            if player then
                player:setGlide(true)
            end
        end, 1, -1)
    else
        SoundUtil.playSound(207)
        text:SetBackgroundColor({0, 0, 0, 0.8})
        UIHelper.showToast("^FF0000Disabled")
        LuaTimer:cancel(self.timer)
        if player then
            player:setFloatProperty("JumpSpeed", 1)
        end
    end
end

GMHelper.toggleState = {
    hitBox = false,
    speed = false,
    tpKiller = false,
    highJump = false,
    blink = false,
    aimBot = false,
    skate = false,
    tpClick = false
}

local timers = {}
local buttons = {}
local buttonStackOffset = 55

local activeColor = {0.8, 0.4, 0, 0.8}
local disabledColor = {0, 0, 0, 0.5}

local function createButton(name, height, onClick)
    local btn = GUIManager:createGUIWindow(GUIType.Button, tostring(math.random(1, 999e9)))
    btn:SetHorizontalAlignment(HorizontalAlignment.Right)
    btn:SetVerticalAlignment(VerticalAlignment.Top)
    btn:SetHeight({0, height})
    btn:SetWidth({0, 145})
    btn:SetLevel(1)
    btn:SetTextColor({1, 1, 1, 1})
    btn:SetBackgroundColor(disabledColor)
    btn:SetText(name)
    btn:SetYPosition({0, buttonStackOffset})
    buttonStackOffset = buttonStackOffset + (height + 5)
    btn:registerEvent(GUIEvent.ButtonClick, onClick)
    GUISystem.Instance():GetRootWindow():AddChildWindow(btn)
    return btn
end

local function toggleButton(btn, state)
    btn:SetBackgroundColor(state and activeColor or disabledColor)
end

local function createToggleButton(key, name, callback)
    if buttons[key] then return buttons[key] end
    buttons[key] = createButton(name, 47, function()
        GMHelper.toggleState[key] = not GMHelper.toggleState[key]
        toggleButton(buttons[key], GMHelper.toggleState[key])
        if callback then callback(GMHelper.toggleState[key]) end
    end)
    return buttons[key]
end

local highJumpValue = 1

function GMHelper:HitBoxBtn()
    
    self.HitBoxBtnEnabled = not self.HitBoxBtnEnabled
    _G["togHitBoxBtn"] = self.HitBoxBtnEnabled
    refreshButtonColorSave("HitBoxBtn")

    if self.HitBoxBtnEnabled then
        SaveItem("HitBoxBtn", "HitBoxBtn")
    end
createToggleButton("hitBox", "HitBox", function(state)
        LuaTimer:cancel(timers.hitBox)
        local players = PlayerManager:getPlayers()
        local clientPlayer = PlayerManager:getClientPlayer()
        if state then
            timers.hitBox = LuaTimer:scheduleTimer(function()
                for _, player in ipairs(players) do
                    local entity = player.Player
                    if player ~= clientPlayer and clientPlayer.Player:getTeamId() ~= player:getTeamId() then
                        entity.height, entity.width, entity.length = 8, 8, 8
                    end
                end
            end, 30, -1)
        else
            for _, player in ipairs(players) do
                local entity = player.Player
                if player ~= clientPlayer and clientPlayer.Player:getTeamId() ~= player:getTeamId() then
                    entity.height, entity.width, entity.length = 1.8, 0.6, 0.6
                end
            end
        end
    end)
end

function GMHelper:SpeedBtn()
    
    self.SpeedBtnEnabled = not self.SpeedBtnEnabled
    _G["togSpeedBtn"] = self.SpeedBtnEnabled
    refreshButtonColorSave("SpeedBtn")

    if self.SpeedBtnEnabled then
        SaveItem("SpeedBtn", "SpeedBtn")
    end
createToggleButton("speed", "Speed", function(state)
        local speedLevel = state and 1500 or 7
        PlayerManager:getClientPlayer().Player:setSpeedAdditionLevel(speedLevel)
    end)
end

function GMHelper:TeleportKillerBtn()
    
    self.TeleportKillerBtnEnabled = not self.TeleportKillerBtnEnabled
    _G["togTeleportKillerBtn"] = self.TeleportKillerBtnEnabled
    refreshButtonColorSave("TeleportKillerBtn")

    if self.TeleportKillerBtnEnabled then
        SaveItem("TeleportKillerBtn", "TeleportKillerBtn")
    end
createToggleButton("tpKiller", "TP Kill", function(state)
        LuaTimer:cancel(timers.tpKiller)
        Blockman.Instance().m_gameSettings:setCollimatorMode(state)
        if not state then return end
        local me = PlayerManager:getClientPlayer()
        local myTeam = me:getTeamId()
        local camera = SceneManager.Instance():getMainCamera()
        local moveDir = VectorUtil.newVector3(0.0, 2.0, 0.0)
        local smoothTpOffset = VectorUtil.newVector3(0.0, 0.5, 0.0)
        timers.tpKiller = LuaTimer:scheduleTimer(function()
            local myPos = me:getPosition()
            local minDist = math.huge
            local target = nil
            for _, p in ipairs(PlayerManager:getPlayers()) do
                local team = p:getTeamId()
                if p ~= me and p:getHealth() > 0 and team ~= myTeam and team ~= "criminal" and team ~= "personal" then
                    local dist = MathUtil:distanceSquare3d(p:getPosition(), myPos)
                    if dist < minDist then
                        minDist = dist
                        target = p
                    end
                end
            end
            if target then
                local tpPos = VectorUtil.add3(target:getPosition(), smoothTpOffset)
                me.Player:setPosition(tpPos)
                me.Player:moveEntity(moveDir)
                local cameraPos = camera:getPosition()
                local dx, dy, dz = target:getPosition().x - cameraPos.x, target:getPosition().y - cameraPos.y + 1.5, target:getPosition().z - cameraPos.z
                local hdist = math.sqrt(dx * dx + dz * dz)
                me.Player.rotationYaw = math.atan2(dx, dz) * -57.2958
                me.Player.rotationPitch = -math.atan2(dy, hdist) * 57.2958
                LuaTimer:scheduleTimer(function()
                    CGame.Instance():handleTouchClick(1204, 503)
                end, 50, 1)
                UIHelper.showToast(target:getName() .. " " .. target:getHealth() .. "/" .. target:getMaxHealth())
            end
        end, 5, -1)
    end)
end

function GMHelper:BlinkBtn()
    
    self.BlinkBtnEnabled = not self.BlinkBtnEnabled
    _G["togBlinkBtn"] = self.BlinkBtnEnabled
    refreshButtonColorSave("BlinkBtn")

    if self.BlinkBtnEnabled then
        SaveItem("BlinkBtn", "BlinkBtn")
    end
createToggleButton("blink", "Blink", function(state)
        ClientHelper.putBoolPrefs("SyncClientPositionToServer", not state)
    end)
end

function GMHelper:AimBotBtn()
    
    self.AimBotBtnEnabled = not self.AimBotBtnEnabled
    _G["togAimBotBtn"] = self.AimBotBtnEnabled
    refreshButtonColorSave("AimBotBtn")

    if self.AimBotBtnEnabled then
        SaveItem("AimBotBtn", "AimBotBtn")
    end
createToggleButton("aimBot", "AimBot", function(state)
        LuaTimer:cancel(timers.aimBot)
        if state then
            timers.aimBot = LuaTimer:scheduleTimer(function()
                local me = PlayerManager:getClientPlayer()
                if me then
                    local closestDistance, closestPlayer = math.huge, nil
                    local players = PlayerManager:getPlayers()
                    local myPos = me.Player:getPosition()
                    for _, player in pairs(players) do
                        if player ~= me then
                            local dist = MathUtil:distanceSquare2d(player:getPosition(), myPos)
                            if dist < closestDistance then
                                closestDistance, closestPlayer = dist, player
                            end
                        end
                    end
                    if closestPlayer and closestDistance < 10 then
                        local camera = SceneManager.Instance():getMainCamera()
                        local dir = VectorUtil.sub3(closestPlayer:getPosition(), camera:getPosition())
                        me.Player.rotationYaw = math.atan2(dir.x, dir.z) / math.pi * -180
                        local h = math.sqrt(dir.x^2 + dir.z^2)
                        me.Player.rotationPitch = -math.atan2(dir.y, h) / math.pi * 180
                    end
                end
            end, 1, -1)
        end
    end)
end

function GMHelper:SkateBtn()
    
    self.SkateBtnEnabled = not self.SkateBtnEnabled
    _G["togSkateBtn"] = self.SkateBtnEnabled
    refreshButtonColorSave("SkateBtn")

    if self.SkateBtnEnabled then
        SaveItem("SkateBtn", "SkateBtn")
    end
createToggleButton("skate", "Skate", function(state)
        local me = PlayerManager:getClientPlayer()
        me.Player:setBoolProperty("DisableUpdateAnimState", state)
    end)
end

local callbackId
function GMHelper:TpClickBtn()
    
    self.TpClickBtnEnabled = not self.TpClickBtnEnabled
    _G["togTpClickBtn"] = self.TpClickBtnEnabled
    refreshButtonColorSave("TpClickBtn")

    if self.TpClickBtnEnabled then
        SaveItem("TpClickBtn", "TpClickBtn")
    end
createToggleButton("tpClick", "TpClick", function(state)
        local function issue(event)
            if not state or not event then return end
            local me = PlayerManager:getClientPlayer()
            if me and me.Player then
                local targetPos = VectorUtil.newVector3(event.x, event.y, event.z)
                setPosTest(targetPos)
            end
        end

        if state then
            callbackId = Listener.registerCallBack(CEvents.ClickToBlockEvent, issue)
            ClientHelper.putFloatPrefs("BlockReachDistance", 9999)
        else
            if callbackId then
                Listener.unregisterCallBack(CEvents.ClickToBlockEvent, callbackId)
                callbackId = nil
            end
            ClientHelper.putFloatPrefs("BlockReachDistance", 7)
        end
    end)
end

function GMHelper:HighJumpBtn()
    
    self.HighJumpBtnEnabled = not self.HighJumpBtnEnabled
    _G["togHighJumpBtn"] = self.HighJumpBtnEnabled
    refreshButtonColorSave("HighJumpBtn")

    if self.HighJumpBtnEnabled then
        SaveItem("HighJumpBtn", "HighJumpBtn")
    end
createToggleButton("highJump", "HighJump", function(state)
        local player = PlayerManager:getClientPlayer()
        if state then
            player.Player:setFloatProperty("JumpHeight", highJumpValue)
        else
            player.Player:setFloatProperty("JumpHeight", 0.4)
        end
    end)
end

function GMHelper:BtnBridge()
    
    self.BtnBridgeEnabled = not self.BtnBridgeEnabled
    _G["togBtnBridge"] = self.BtnBridgeEnabled
    refreshButtonColorSave("BtnBridge")

    if self.BtnBridgeEnabled then
        SaveItem("BtnBridge", "BtnBridge")
    end
if togBlockMain then return end

    local handlers = {}
    Events.ShowFrontPlaceBlockEvent = IScriptEvent.new()
    local Settings = {}

    function GMHelper:initModuleBlock()
        local ymlConfig = FileUtil.getGameConfigFromYml("module_block/ModuleBlock", true) or {}
        self.placeBlockMaxDepth = ymlConfig.placeBlockMaxDepth or 2
        self.placeBlockMaxBuildDistance = 4
        self.buildRoadModeMaxDistance = 4

        if isClient then
            ClientHelper.putIntPrefs("RunLimitCheck", ymlConfig.limitBlockCheckRun or 10)
            ClientHelper.putIntPrefs("SprintLimitCheck", ymlConfig.limitBlockCheckSprint or 10)
        end

        local csvConfig = FileUtil.getGameConfigFromCsv("module_block/ModuleBlock.csv", 2, true, true) or {}
        for _, item in pairs(csvConfig) do
            local data = {
                id = tonumber(item.id),
                itemId = tonumber(item.itemId),
                teamId = tonumber(item.teamId) or 0,
                consumeNum = tonumber(item.consumeNum) or 1,
                schematic = item.schematic,
                offsetX = tonumber(item.offsetX) or 0,
                offsetZ = tonumber(item.offsetZ) or 0,
                image = item.image,
                extraParam = tonumber(item.extraParam) or 0,
            }
            Settings[data.itemId] = Settings[data.itemId] or {}
            table.insert(Settings[data.itemId], data)
        end

        for _, setting in pairs(Settings) do
            table.sort(setting, function(a,b) return a.id < b.id end)
        end
    end

    function GMHelper:getModuleBlock(itemId, moduleId, teamId)
        local modules = Settings[itemId]
        if not modules then return nil end
        if moduleId and moduleId ~= 0 then
            for _, module in pairs(modules) do
                if module.id == moduleId then return module end
            end
        end
        for _, module in pairs(modules) do
            if module.teamId == teamId then return module end
        end
        if teamId ~= 0 then
            return self:getModuleBlock(itemId, moduleId, 0)
        end
        return nil
    end

    function GMHelper:getModuleBlocks(itemId)
        return Settings[itemId]
    end

    function GMHelper:getDefaultModuleId(itemId)
        local modules = Settings[itemId]
        return (modules and #modules > 0) and modules[1].id or 0
    end

    function GMHelper:hasModuleConfig()
        return not TableUtil.isEmpty(Settings)
    end

    self:initModuleBlock()

    local FaceOffset = {
        North = VectorUtil.newVector3(0,0,-1),
        South = VectorUtil.newVector3(0,0,1),
        West  = VectorUtil.newVector3(-1,0,0),
        East  = VectorUtil.newVector3(1,0,0),
    }

    local DiagonalOffset = {
        WestNorth = VectorUtil.newVector3(-1,0,-1),
        WestSouth = VectorUtil.newVector3(-1,0,1),
        EastNorth = VectorUtil.newVector3(1,0,-1),
        EastSouth = VectorUtil.newVector3(1,0,1),
    }

    local Face = { Upper=0, Under=1, North=3, South=2, West=5, East=4 }

    local curClickScreenPos

    local function getHitPointInfo(player, clickScreenPos)
        local camera = SceneManager.Instance():getMainCamera()
        local pos, dir = camera:getPosition(), camera:getDirection()
        local hitInfo, real = HitInfo.new(), nil
        local ray = Ray.new(pos, dir)
        camera:getCameraRay(ray, clickScreenPos)
        local y = player:getPosition().y - 1.6
        local plane = Plane.new(VectorUtil.UNIT_Y, -y)
        ray:hitPlane(plane, real, hitInfo)
        hitInfo.hitPos = VectorUtil.newVector3(hitInfo.hitPos.x, math.floor(hitInfo.hitPos.y), hitInfo.hitPos.z)
        return hitInfo
    end

    local function checkCanPlaceBlock(pos)
        local blockId = EngineWorld:getBlockId(pos)
        local canAttach, canBuild, canPlace = {}, {}, false
        if blockId ~= BlockID.AIR and blockId ~= BlockID.SNOW then return canPlace, canAttach, canBuild end
        for name, offset in pairs(FaceOffset) do
            local newPos = VectorUtil.add3(pos, offset)
            local id = EngineWorld:getBlockId(newPos)
            if id ~= BlockID.AIR and id ~= BlockID.SNOW then
                canAttach[name] = newPos
                canPlace = true
            else
                table.insert(canBuild, newPos)
            end
        end
        for _, offset in pairs(DiagonalOffset) do
            local newPos = VectorUtil.add3(pos, offset)
            if EngineWorld:getBlockId(newPos) == 0 then table.insert(canBuild, newPos) end
        end
        return canPlace, canAttach, canBuild
    end

    local function findBuildPos(player, initPos, depth)
        depth = depth or 1
        if depth > (self.placeBlockMaxDepth or 1) then return false, nil, nil end
        local isCanPlace, attachList, buildList = checkCanPlaceBlock(initPos)
        local playerPos = VectorUtil.toBlockVector3(player:getPosition().x, player:getPosition().y, player:getPosition().z)
        if isCanPlace then
            local targetPos, targetFace
            local minDist = self.placeBlockMaxBuildDistance
            for name, attachPos in pairs(attachList) do
                local dist = VectorUtil.distance(attachPos, playerPos)
                if dist < minDist then
                    minDist = dist
                    targetPos, targetFace = attachPos, Face[name]
                end
            end
            return true, targetPos, targetFace
        else
            table.sort(buildList, function(a,b) return VectorUtil.distance(a, playerPos) < VectorUtil.distance(b, playerPos) end)
            for _, pos in pairs(buildList) do
                local ok, bp, face = findBuildPos(player, pos, depth + 1)
                if ok then return ok, bp, face end
            end
        end
        return false, nil, nil
    end

    local function findFrontBlock(player, dir)
        local step = math.abs(dir.x) >= math.abs(dir.z) and VectorUtil.newVector3(dir.x>0 and 1 or -1,0,0)
                    or VectorUtil.newVector3(0,0,dir.z>0 and 1 or -1)
        local playerPos = VectorUtil.toBlockVector3(player:getPosition().x, player:getPosition().y, player:getPosition().z)
        local startPos = VectorUtil.toBlockVector3(playerPos.x, playerPos.y-2, playerPos.z)
        local finalPos = startPos
        local isCanPlace = false
        for _=1,self.buildRoadModeMaxDistance do
            local blockID = EngineWorld:getBlockId(finalPos)
            if blockID == BlockID.AIR or blockID == BlockID.SNOW then
                local ok, pos, face = findBuildPos(player, finalPos, 1)
                if ok then return ok, pos, face end
            else
                finalPos = VectorUtil.add3(finalPos, step)
            end
        end
        for _, offset in pairs(FaceOffset) do
            local ok, pos, face = findBuildPos(player, VectorUtil.add3(startPos, offset), 1)
            if ok then return ok, pos, face end
        end
        return isCanPlace, finalPos, Face.North
    end

    function GMHelper:onPlayerClickScreen(x,y) curClickScreenPos = {x=x,y=y} end

    function GMHelper:onClickAir(isClickAir)
        if not isClickAir or not curClickScreenPos then curClickScreenPos = nil return true end
        local player = PlayerManager:getClientPlayer()
        if not player then return true end
        local hitInfo = getHitPointInfo(player, curClickScreenPos)
        local initPos = VectorUtil.toBlockVector3(hitInfo.hitPos.x, hitInfo.hitPos.y-1, hitInfo.hitPos.z)
        local ok, buildPos, face = findBuildPos(player, initPos, 1)
        return self:tryPlaceBlock(player, buildPos, face, "screen")
    end

    function GMHelper:onClickFrontBuildButton()
        local player = PlayerManager:getClientPlayer()
        if not player then return end
        if not player.Player.onGround then
            local pos = player.Player:getBottomPos()
            local curPos = VectorUtil.newVector3(math.floor(pos.x), math.floor(pos.y), math.floor(pos.z))
            local under1 = VectorUtil.newVector3(curPos.x, curPos.y-1, curPos.z)
            local under2 = VectorUtil.newVector3(curPos.x, curPos.y-2, curPos.z)
            local curBlock, underBlock, underBlock2 = EngineWorld:getBlockId(curPos), EngineWorld:getBlockId(under1), EngineWorld:getBlockId(under2)
            if curBlock==BlockID.AIR and underBlock~=BlockID.AIR then self:tryPlaceBlock(player, under1, Face.Under,"button")
            elseif curBlock==BlockID.AIR and underBlock==BlockID.AIR and underBlock2~=BlockID.AIR then self:tryPlaceBlock(player, under2, Face.Under,"button") end
            return
        end
        local dir = SceneManager.Instance():getMainCamera():getDirection()
        local ok, buildPos, face = findFrontBlock(player, dir)
        self:tryPlaceBlock(player, buildPos, face, "button")
    end

    function GMHelper:tryPlaceBlock(player, buildPos, face, source)
        if not buildPos or not face then return false end
        local inv = player:getInventory()
        if not inv then return end
        local itemStack = inv:getRealCurrentItem()
        if not itemStack then return false end
        local item = itemStack:getItem()
        if not item then return false end
        source = source or "screen"
        local placed = item:onItemUse(itemStack, Blockman.Instance():getPlayer(), Blockman.Instance():getWorld(), buildPos, face, buildPos)
        if placed then
            if itemStack:getItemStackSize()==0 then inv:decrStackSize(inv:findItemStack(itemStack),0) end
            player.Player:swingItem()
            player:sendPacket({pid="TryPlaceBlock", position=buildPos, face=face, source=source})
            return true
        end
        return false
    end

    local listener = {}
    function listener:init()
        Listener.registerCallBack(CEvents.ClickAirEvent, function(isClickAir) return GMHelper:onClickAir(isClickAir) end)
        Listener.registerCallBack(CEvents.PlayerClickScreenEvent, function(x,y) GMHelper:onPlayerClickScreen(x,y) end)
    end
    listener:init()

    local btn = GUIManager:createGUIWindow(GUIType.Button, "BlockToggleBtn")
    btn:SetWidth({0,60})
    btn:SetHeight({0,60})
    btn:SetVisible(true)
    btn:SetBackgroundColor({0.8, 0.4, 0, 1})
    btn:SetTouchable(true)
    btn:SetLevel(1)
    GUISystem.Instance():GetRootWindow():AddChildWindow(btn)

    local label = GUIManager:createGUIWindow(GUIType.StaticText, "BtnLabel")
    label:SetText("Build")
    label:SetTextHorzAlign(HorizontalAlignment.Center)
    label:SetTextVertAlign(VerticalAlignment.Center)
    label:SetWidth({0,60})
    label:SetHeight({0,60})
    label:SetVisible(true)
    label:SetTouchable(false)
    btn:AddChildWindow(label)

    local function clickHandler() GMHelper:onClickFrontBuildButton() end
    btn:registerEvent(GUIEvent.ButtonClick, clickHandler)
    btn:registerEvent(GUIEvent.LongTouchStart, clickHandler)
    btn:registerEvent(GUIEvent.TouchDown, clickHandler)
    btn:registerEvent(GUIEvent.TouchUp, clickHandler)
    btn:SetXPosition({0, 1210})
    btn:SetYPosition({0, 355})

    togBlockMain = true
end

togInstantReload = false  -- global toggle variable

function GMHelper:instantReload(enable)
    
    self.instantReloadEnabled = not self.instantReloadEnabled
    _G["toginstantReload"] = self.instantReloadEnabled
    refreshButtonColorSave("instantReload")

    if self.instantReloadEnabled then
        SaveItem("instantReload", "instantReload")
    end
local player = PlayerManager:getClientPlayer().Player
    if enable then
        player.m_isReloadBullet = true
        player.m_reloadPregress = 9999
        player.m_prevReloadPregress = 9999
        player.m_reloadBulletInt = 9999
        player.gunFireProgress = 9999
        player.prevGunFireProgress = 9999
    else
        player.m_isReloadBullet = false
        player.m_reloadPregress = 1
        player.m_prevReloadPregress = 1
        player.m_reloadBulletInt = 1
        player.gunFireProgress = 1
        player.prevGunFireProgress = 1
    end
end

function GMHelper:EspV2()
    
    self.EspV2Enabled = not self.EspV2Enabled
    _G["togEspV2"] = self.EspV2Enabled
    refreshButtonColorSave("EspV2")

    if self.EspV2Enabled then
        SaveItem("EspV2", "EspV2")
    end
espBoxEnabled = not espBoxEnabled

    if not espBoxEnabled then
        for _, p in pairs(PlayerManager:getPlayers()) do
            local box = p.Player and p.Player:FindChild("ESPBox")
            if box then box:SetVisible(false) end
        end
        processedPlayers = {}
        return
    end

    LuaTimer:scheduleTimer(function()
        if not espBoxEnabled then return end

        local myPlayer = PlayerManager:getClientPlayer().Player

        for _, p in pairs(PlayerManager:getPlayers()) do
            if p.userId ~= PlayerManager:getClientPlayer().userId and p.Player then
                local playerObj = p.Player
                local box = playerObj:FindChild("ESPBox")

                if not box then
                    box = GUIManager:createGUIWindow(GUIType.Button, "ESPBox_" .. p.userId)
                    box:SetTouchable(false)
                    box:SetWidth({0, 1})
                    box:SetHeight({0, 2})
                    box:SetDepth(0.5)
                    box:SetBackgroundColor({1, 0, 0, 0.4})
                    UIHelper.showToast("^00FF00Enabled")
                    playerObj:AddChildWindow(box)
                end

                box:SetPosition({0, 0, 1})
                box:SetVisible(true)
            end
        end
    end, 50, -1)
end

function GMHelper:WordBypass()
    UIHelper.showToast("Attempting to Inject Chat Bypass")

    self.WordBypassEnabled = not self.WordBypassEnabled
    _G["togWordBypass"] = self.WordBypassEnabled
    refreshButtonColorSave("WordBypass")

    if self.WordBypassEnabled then
        SaveItem("WordBypass", "WordBypass")
    end

    local settingPath = Root.Instance():getRootPath() .. "/Media/Setting/"
    lfs.mkdir(settingPath)

    local wordsTxtFile = io.open(settingPath .. "words.txt", "w")
    if wordsTxtFile then
        wordsTxtFile:write("")
        wordsTxtFile:close()
        UIHelper.showToast("Successfully Injected Chat Bypass")
    else
        UIHelper.showToast("Failed to Inject Chat Bypass")
    end
end

---<[{ End GMPanel }]>---
